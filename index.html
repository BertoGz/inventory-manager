<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Inventory Manager</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>

    <!-- Babel for in-browser JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- JSZip for ZIP export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- SheetJS for Excel export (fallback) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- ExcelJS for Excel export with image support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>

    <!-- jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- sql.js for SQLite database creation -->
    <script src="https://cdn.jsdelivr.net/npm/sql.js@1.10.3/dist/sql-wasm.js"></script>

    <!-- Transformers.js (AI Model) -->
    <script type="module">
      import {
        pipeline,
        env,
      } from "https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.0";

      // Skip local model checks since we are in a browser without a file system
      env.allowLocalModels = false;

      // Attach to window so our React app can use it
      window.pipeline = pipeline;
      window.transformersLoaded = true;
    </script>

    <style>
      /* Custom Scrollbar */
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }

      ::-webkit-scrollbar-track {
        background: #0f172a;
      }

      ::-webkit-scrollbar-thumb {
        background: #334155;
        border-radius: 5px;
        border: 2px solid #0f172a;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: #475569;
      }

      input[type="number"]::-webkit-inner-spin-button,
      input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      /* Animations */
      @keyframes pulse-subtle {
        0%,
        100% {
          opacity: 1;
        }

        50% {
          opacity: 0.7;
        }
      }

      .animate-pulse-subtle {
        animation: pulse-subtle 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }
    </style>
  </head>

  <body class="bg-slate-950 text-slate-100 overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, useMemo, useCallback } = React;

      // --- Icons ---
      const IconBase = ({ children, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          {children}
        </svg>
      );

      const FolderOpen = (props) => (
        <IconBase {...props}>
          <path d="m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-3.25 7a2 2 0 0 1-1.94 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2" />
        </IconBase>
      );
      const Package = (props) => (
        <IconBase {...props}>
          <path d="m7.5 4.27 9 5.15" />
          <path d="M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z" />
          <path d="m3.3 7 8.7 5 8.7-5" />
          <path d="M12 22v-9" />
        </IconBase>
      );
      const Save = (props) => (
        <IconBase {...props}>
          <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
          <polyline points="17 21 17 13 7 13 7 21" />
          <polyline points="7 3 7 8 15 8" />
        </IconBase>
      );
      const AlertCircle = (props) => (
        <IconBase {...props}>
          <circle cx="12" cy="12" r="10" />
          <line x1="12" x2="12" y1="8" y2="12" />
          <line x1="12" x2="12.01" y1="16" y2="16" />
        </IconBase>
      );
      const ImageIcon = (props) => (
        <IconBase {...props}>
          <rect width="18" height="18" x="3" y="3" rx="2" ry="2" />
          <circle cx="9" cy="9" r="2" />
          <path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" />
        </IconBase>
      );
      const Split = (props) => (
        <IconBase {...props}>
          <rect width="18" height="18" x="3" y="3" rx="2" ry="2" />
          <line x1="12" x2="12" y1="3" y2="21" />
        </IconBase>
      );
      const Settings = (props) => (
        <IconBase {...props}>
          <path d="M12 8a4 4 0 1 0 0 8 4 4 0 0 0 0-8z" />
          <path d="M19.43 12.97c.04-.32.07-.64.07-.97s-.03-.65-.07-.97l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.06-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.63.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.32-.07.65-.07.97s.03.65.07.97l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.06.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.63-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z" />
        </IconBase>
      );
      const RefreshCw = (props) => (
        <IconBase {...props}>
          <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
          <path d="M21 3v5h-5" />
          <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
          <path d="M8 16H3v5" />
        </IconBase>
      );
      const Search = (props) => (
        <IconBase {...props}>
          <circle cx="11" cy="11" r="8" />
          <path d="m21 21-4.3-4.3" />
        </IconBase>
      );
      const Brain = (props) => (
        <IconBase {...props}>
          <path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z" />
          <path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z" />
        </IconBase>
      );
      const X = (props) => (
        <IconBase {...props}>
          <path d="M18 6 6 18" />
          <path d="m6 6 12 12" />
        </IconBase>
      );
      const MoreVertical = (props) => (
        <IconBase {...props}>
          <circle cx="12" cy="5" r="1.5" fill="currentColor" />
          <circle cx="12" cy="12" r="1.5" fill="currentColor" />
          <circle cx="12" cy="19" r="1.5" fill="currentColor" />
        </IconBase>
      );
      const ChevronDown = (props) => (
        <IconBase {...props}>
          <path d="m6 9 6 6 6-6" />
        </IconBase>
      );
      const FileText = (props) => (
        <IconBase {...props}>
          <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" />
          <polyline points="14 2 14 8 20 8" />
          <line x1="16" x2="8" y1="13" y2="13" />
          <line x1="16" x2="8" y1="17" y2="17" />
          <polyline points="10 9 9 9 8 9" />
        </IconBase>
      );
      const Plus = (props) => (
        <IconBase {...props}>
          <line x1="12" y1="5" x2="12" y2="19" />
          <line x1="5" y1="12" x2="19" y2="12" />
        </IconBase>
      );
      const List = (props) => (
        <IconBase {...props}>
          <line x1="8" y1="6" x2="21" y2="6" />
          <line x1="8" y1="12" x2="21" y2="12" />
          <line x1="8" y1="18" x2="21" y2="18" />
          <line x1="3" y1="6" x2="3.01" y2="6" />
          <line x1="3" y1="12" x2="3.01" y2="12" />
          <line x1="3" y1="18" x2="3.01" y2="18" />
        </IconBase>
      );
      const Filter = (props) => (
        <IconBase {...props}>
          <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3" />
        </IconBase>
      );

      // --- Constants & Helpers ---

      const ROW_HEIGHT = 80;
      const BUFFER_ITEMS = 5;

      const RARITY_MAP = {
        0: {
          label: "Common",
          color: "text-gray-400 border-gray-600 bg-gray-800",
        },
        1: {
          label: "Rare",
          color: "text-blue-400 border-blue-600 bg-blue-900/20",
        },
        2: {
          label: "Ultra Rare",
          color: "text-purple-400 border-purple-600 bg-purple-900/20",
        },
      };

      function cosineSimilarity(a, b) {
        let dot = 0;
        for (let i = 0; i < a.length; i++) {
          dot += a[i] * b[i];
        }
        let magA = 0,
          magB = 0;
        for (let i = 0; i < a.length; i++) magA += a[i] * a[i];
        for (let i = 0; i < b.length; i++) magB += b[i] * b[i];

        return dot / (Math.sqrt(magA) * Math.sqrt(magB));
      }

      // --- IndexedDB Helpers ---
      const DB_NAME = "vmkInventoryDB";
      const DB_VERSION = 5;
      const STORE_ITEMS = "items";
      const STORE_IMAGES = "images";
      const STORE_METADATA = "metadata";
      const STORE_EMBEDDINGS = "embeddings";
      const STORE_ITEM_CATALOG = "itemCatalog";
      const STORE_INVENTORY_ITEMS = "inventoryItems";
      const STORE_INVENTORIES = "inventories";
      const STORE_SUBLISTS = "sublists";

      function openDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            const oldVersion = event.oldVersion;

            if (oldVersion < 4) {
              if (db.objectStoreNames.contains(STORE_ITEMS))
                db.deleteObjectStore(STORE_ITEMS);
              if (db.objectStoreNames.contains(STORE_EMBEDDINGS))
                db.deleteObjectStore(STORE_EMBEDDINGS);
            }

            if (!db.objectStoreNames.contains(STORE_ITEMS)) {
              db.createObjectStore(STORE_ITEMS, { keyPath: "type" });
            }
            if (!db.objectStoreNames.contains(STORE_IMAGES)) {
              db.createObjectStore(STORE_IMAGES, { keyPath: "filename" });
            }
            if (!db.objectStoreNames.contains(STORE_METADATA)) {
              db.createObjectStore(STORE_METADATA, { keyPath: "key" });
            }
            if (!db.objectStoreNames.contains(STORE_EMBEDDINGS)) {
              db.createObjectStore(STORE_EMBEDDINGS, { keyPath: "type" });
            }

            // --- VERSION 5: Create new multi-inventory stores ---
            if (!db.objectStoreNames.contains(STORE_ITEM_CATALOG)) {
              db.createObjectStore(STORE_ITEM_CATALOG, { keyPath: "type" });
            }
            if (!db.objectStoreNames.contains(STORE_INVENTORY_ITEMS)) {
              const inventoryItemsStore = db.createObjectStore(
                STORE_INVENTORY_ITEMS,
                { autoIncrement: true }
              );
              inventoryItemsStore.createIndex("inventoryId", "inventoryId", {
                unique: false,
              });
              inventoryItemsStore.createIndex("type", "type", {
                unique: false,
              });
              inventoryItemsStore.createIndex(
                "inventoryId_type",
                ["inventoryId", "type"],
                { unique: true }
              );
            }
            if (!db.objectStoreNames.contains(STORE_INVENTORIES)) {
              db.createObjectStore(STORE_INVENTORIES, { keyPath: "id" });
            }
            if (!db.objectStoreNames.contains(STORE_SUBLISTS)) {
              const sublistsStore = db.createObjectStore(STORE_SUBLISTS, {
                keyPath: "id",
              });
              sublistsStore.createIndex("inventoryId", "inventoryId", {
                unique: false,
              });
            }
          };
        });
      }

      async function loadInventories() {
        try {
          const db = await openDB();
          const tx = db.transaction([STORE_INVENTORIES], "readonly");
          const inventories = await new Promise((resolve, reject) => {
            const req = tx.objectStore(STORE_INVENTORIES).getAll();
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });
          return inventories || [];
        } catch (e) {
          console.error("Error loading inventories:", e);
          return [];
        }
      }

      async function createInventory(name) {
        try {
          const db = await openDB();
          const inventory = {
            id: `inv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            name: name || "New Inventory",
            createdAt: Date.now(),
            updatedAt: Date.now(),
          };
          const tx = db.transaction([STORE_INVENTORIES], "readwrite");
          await new Promise((resolve, reject) => {
            tx.objectStore(STORE_INVENTORIES).put(inventory);
            tx.oncomplete = () => resolve(inventory);
            tx.onerror = () => reject(tx.error);
          });
          return inventory;
        } catch (e) {
          console.error("Error creating inventory:", e);
          throw e;
        }
      }

      async function loadSublists(inventoryId) {
        try {
          const db = await openDB();
          const tx = db.transaction([STORE_SUBLISTS], "readonly");
          const sublistsStore = tx.objectStore(STORE_SUBLISTS);
          const sublistsIndex = sublistsStore.index("inventoryId");

          const sublists = await new Promise((resolve, reject) => {
            const req = sublistsIndex.getAll(inventoryId);
            req.onsuccess = () => resolve(req.result || []);
            req.onerror = () => reject(req.error);
          });

          return sublists;
        } catch (e) {
          console.error("Error loading sublists:", e);
          return [];
        }
      }

      async function saveSublist(sublist) {
        try {
          const db = await openDB();
          const tx = db.transaction([STORE_SUBLISTS], "readwrite");
          const sublistsStore = tx.objectStore(STORE_SUBLISTS);

          const sublistToSave = {
            ...sublist,
            updatedAt: Date.now(),
          };

          if (!sublistToSave.id) {
            sublistToSave.id = `sublist_${Date.now()}_${Math.random()
              .toString(36)
              .substr(2, 9)}`;
            sublistToSave.createdAt = Date.now();
          }

          await new Promise((resolve, reject) => {
            const req = sublistsStore.put(sublistToSave);
            req.onsuccess = () => resolve(sublistToSave);
            req.onerror = () => reject(req.error);
          });

          return sublistToSave;
        } catch (e) {
          console.error("Error saving sublist:", e);
          throw e;
        }
      }

      async function addItemToSublist(sublistId, itemType, quantity = 1) {
        try {
          const db = await openDB();
          const tx = db.transaction([STORE_SUBLISTS], "readwrite");
          const sublistsStore = tx.objectStore(STORE_SUBLISTS);

          const sublist = await new Promise((resolve, reject) => {
            const req = sublistsStore.get(sublistId);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          if (!sublist) {
            throw new Error("Sublist not found");
          }

          // Update sublist - add item type if not already present
          if (!sublist.itemTypes) {
            sublist.itemTypes = [];
          }
          if (!sublist.itemTypes.includes(itemType)) {
            sublist.itemTypes.push(itemType);
          }

          sublist.updatedAt = Date.now();

          await new Promise((resolve, reject) => {
            const req = sublistsStore.put(sublist);
            req.onsuccess = () => resolve(sublist);
            req.onerror = () => reject(req.error);
          });

          return sublist;
        } catch (e) {
          console.error("Error adding item to sublist:", e);
          throw e;
        }
      }

      async function loadInventoryItems(inventoryId) {
        try {
          const db = await openDB();
          const tx = db.transaction(
            [STORE_INVENTORY_ITEMS, STORE_ITEM_CATALOG],
            "readonly"
          );

          const inventoryItemsStore = tx.objectStore(STORE_INVENTORY_ITEMS);
          const index = inventoryItemsStore.index("inventoryId");
          const inventoryItems = await new Promise((resolve, reject) => {
            const req = index.getAll(inventoryId);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          const catalogStore = tx.objectStore(STORE_ITEM_CATALOG);
          const catalogMap = new Map();
          const catalogItems = await new Promise((resolve, reject) => {
            const req = catalogStore.getAll();
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });
          catalogItems.forEach((item) => catalogMap.set(item.type, item));

          const mergedItems = inventoryItems
            .map((invItem) => {
              const catalogItem = catalogMap.get(invItem.type);
              return {
                ...catalogItem,
                ...invItem,
                quantity: invItem.quantity || 0,
                price: invItem.price || 0,
              };
            })
            .filter((item) => item.name);

          return mergedItems;
        } catch (e) {
          console.error("Error loading inventory items:", e);
          return [];
        }
      }

      async function getInventoryItemCount(inventoryId) {
        try {
          const items = await loadInventoryItems(inventoryId);
          return items.reduce((total, item) => total + (item.quantity || 0), 0);
        } catch (e) {
          console.error("Error getting inventory item count:", e);
          return 0;
        }
      }

      async function saveItemsToInventory(inventoryId, items) {
        try {
          const db = await openDB();

          // 1. Update Catalog (Shared) - Batch write
          // Use the values from items directly (they already have resolutions applied if there were conflicts)
          const catalogTx = db.transaction([STORE_ITEM_CATALOG], "readwrite");
          const catalogStore = catalogTx.objectStore(STORE_ITEM_CATALOG);
          items.forEach((item) => {
            catalogStore.put({
              type: item.type,
              name: item.name || "Unknown Item",
              image: item.image || "",
              rarity: item.rarity !== undefined ? item.rarity : 0,
            });
          });
          await new Promise((resolve, reject) => {
            catalogTx.oncomplete = () => resolve();
            catalogTx.onerror = () => reject(catalogTx.error);
          });

          // 2. Prepare Inventory Updates
          // Load existing items for this inventory to check for existence/keys
          const readTx = db.transaction([STORE_INVENTORY_ITEMS], "readonly");
          const invStoreRead = readTx.objectStore(STORE_INVENTORY_ITEMS);
          const invIndexRead = invStoreRead.index("inventoryId");

          // We use Promises to get results since getAll is async within transaction
          const [existingValues, existingKeys] = await Promise.all([
            new Promise((resolve, reject) => {
              const req = invIndexRead.getAll(inventoryId);
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
            }),
            new Promise((resolve, reject) => {
              const req = invIndexRead.getAllKeys(inventoryId);
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
            }),
          ]);

          // Map Type -> PrimaryKey
          const typeToKeyMap = new Map();
          existingValues.forEach((val, i) => {
            typeToKeyMap.set(val.type, existingKeys[i]);
          });

          // 3. Perform Updates
          const writeTx = db.transaction([STORE_INVENTORY_ITEMS], "readwrite");
          const invStoreWrite = writeTx.objectStore(STORE_INVENTORY_ITEMS);

          items.forEach((item) => {
            const existingKey = typeToKeyMap.get(item.type);
            const inventoryItem = {
              inventoryId: inventoryId,
              type: item.type,
              quantity: item.quantity || item.count || 0,
              price: item.price !== undefined ? item.price : 0,
            };

            if (existingKey !== undefined) {
              // Update existing entry using its Primary Key
              invStoreWrite.put(inventoryItem, existingKey);
            } else {
              // Add new entry
              invStoreWrite.add(inventoryItem);
            }
          });

          await new Promise((resolve, reject) => {
            writeTx.oncomplete = () => resolve();
            writeTx.onerror = () => reject(writeTx.error);
          });
        } catch (e) {
          console.error("Error saving items to inventory:", e);
          throw e;
        }
      }

      async function deleteInventory(inventoryId) {
        try {
          const db = await openDB();

          // 1. Get keys to delete
          const readTx = db.transaction(
            [STORE_INVENTORY_ITEMS, STORE_SUBLISTS],
            "readonly"
          );

          const invItemsStore = readTx.objectStore(STORE_INVENTORY_ITEMS);
          const invIndex = invItemsStore.index("inventoryId");
          const itemKeys = await new Promise((resolve, reject) => {
            const req = invIndex.getAllKeys(inventoryId);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          const sublistsStore = readTx.objectStore(STORE_SUBLISTS);
          const sublistsIndex = sublistsStore.index("inventoryId");
          const sublistKeys = await new Promise((resolve, reject) => {
            const req = sublistsIndex.getAllKeys(inventoryId);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          // 2. Perform Deletions
          const writeTx = db.transaction(
            [STORE_INVENTORIES, STORE_INVENTORY_ITEMS, STORE_SUBLISTS],
            "readwrite"
          );

          writeTx.objectStore(STORE_INVENTORIES).delete(inventoryId);

          const writeInvItems = writeTx.objectStore(STORE_INVENTORY_ITEMS);
          itemKeys.forEach((key) => writeInvItems.delete(key));

          const writeSublists = writeTx.objectStore(STORE_SUBLISTS);
          sublistKeys.forEach((key) => writeSublists.delete(key));

          await new Promise((resolve, reject) => {
            writeTx.oncomplete = () => resolve();
            writeTx.onerror = () => reject(writeTx.error);
          });
        } catch (e) {
          console.error("Error deleting inventory:", e);
          throw e;
        }
      }

      // FIXED: Transfer items without reusing closed transactions AND using Primary Keys
      async function transferItems(
        sourceInventoryId,
        targetInventoryId,
        itemType,
        quantity
      ) {
        try {
          const db = await openDB();

          // 1. Get Source Item Data & Key
          const sourceTx = db.transaction([STORE_INVENTORY_ITEMS], "readonly");
          const sourceStore = sourceTx.objectStore(STORE_INVENTORY_ITEMS);
          const sourceIndex = sourceStore.index("inventoryId_type");

          const sourceKey = await new Promise((resolve, reject) => {
            const req = sourceIndex.getKey([sourceInventoryId, itemType]);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () =>
              reject(req.error || new Error("Failed to get source key"));
          });

          const sourceItem = await new Promise((resolve, reject) => {
            const req = sourceIndex.get([sourceInventoryId, itemType]);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          if (!sourceItem || sourceItem.quantity < quantity) {
            throw new Error("Insufficient quantity");
          }

          // 2. Get Target Item Data & Key (New Transaction)
          const targetTx = db.transaction([STORE_INVENTORY_ITEMS], "readonly");
          const targetStore = targetTx.objectStore(STORE_INVENTORY_ITEMS);
          const targetIndex = targetStore.index("inventoryId_type");

          const targetKey = await new Promise((resolve, reject) => {
            const req = targetIndex.getKey([targetInventoryId, itemType]);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          const targetItem = await new Promise((resolve, reject) => {
            const req = targetIndex.get([targetInventoryId, itemType]);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          // 3. Write Updates (New Transaction)
          const writeTx = db.transaction([STORE_INVENTORY_ITEMS], "readwrite");
          const writeStore = writeTx.objectStore(STORE_INVENTORY_ITEMS);

          // Update Source - keep item even if quantity is 0
          const newSourceQuantity = sourceItem.quantity - quantity;
          // We must use the Primary Key to update
          writeStore.put(
            {
              ...sourceItem,
              quantity: Math.max(0, newSourceQuantity), // Ensure quantity is never negative
            },
            sourceKey
          );

          // Update or Create Target
          if (targetItem && targetKey) {
            writeStore.put(
              {
                ...targetItem,
                quantity: targetItem.quantity + quantity,
              },
              targetKey
            );
          } else {
            // Create new target item
            writeStore.put({
              inventoryId: targetInventoryId,
              type: itemType,
              quantity: quantity,
              price: sourceItem.price || 0,
            });
          }

          await new Promise((resolve, reject) => {
            writeTx.oncomplete = () => resolve();
            writeTx.onerror = () =>
              reject(writeTx.error || new Error("Transaction failed"));
            writeTx.onabort = () => reject(new Error("Transaction aborted"));
          });
        } catch (e) {
          console.error("Error transferring items:", e);
          // Ensure we don't throw null
          throw e || new Error("Unknown error during transfer");
        }
      }

      async function saveImagesToIndexedDB(
        imageFileMap,
        existingImageMap = null
      ) {
        try {
          const db = await openDB();
          const tx = db.transaction([STORE_IMAGES], "readwrite");
          const imagesStore = tx.objectStore(STORE_IMAGES);

          let newCount = 0;
          for (const [filename, fileObj] of imageFileMap.entries()) {
            if (!existingImageMap || !existingImageMap.has(filename)) {
              imagesStore.put({ filename, blob: fileObj });
              newCount++;
            }
          }

          await new Promise((resolve, reject) => {
            tx.oncomplete = () => {
              if (newCount > 0) {
                console.log(`Saved ${newCount} new images to IndexedDB.`);
              }
              resolve();
            };
            tx.onerror = () => reject(tx.error);
            tx.onabort = () => reject(new Error("Image transaction aborted"));
          });
        } catch (e) {
          console.error("Failed to save images:", e);
          throw e;
        }
      }

      async function saveDataToIndexedDB(items, metadata) {
        try {
          if (!items || items.length === 0) {
            return;
          }

          const db = await openDB();
          const tx = db.transaction([STORE_ITEMS, STORE_METADATA], "readwrite");

          const itemsStore = tx.objectStore(STORE_ITEMS);

          let putCount = 0;
          items.forEach((item) => {
            try {
              itemsStore.put(item);
              putCount++;
            } catch (err) {
              console.error("Error putting item:", item, err);
            }
          });

          if (metadata) {
            const metadataStore = tx.objectStore(STORE_METADATA);
            metadataStore.put({ key: "extraction", ...metadata });
          }

          await new Promise((resolve, reject) => {
            tx.oncomplete = () => {
              console.log(`Successfully saved ${putCount} items to DB.`);
              resolve();
            };
            tx.onerror = () => reject(tx.error);
            tx.onabort = () => reject(new Error("Data transaction aborted"));
          });
        } catch (e) {
          console.error("Failed to save data:", e);
          throw e;
        }
      }

      async function saveEmbeddingsToIndexedDB(embeddingsMap) {
        try {
          if (!embeddingsMap || embeddingsMap.size === 0) return;

          const db = await openDB();
          const tx = db.transaction([STORE_EMBEDDINGS], "readwrite");
          const embeddingsStore = tx.objectStore(STORE_EMBEDDINGS);

          let savedCount = 0;
          for (const [itemType, vector] of embeddingsMap.entries()) {
            try {
              embeddingsStore.put({
                type: itemType,
                vector: Array.from(vector),
              });
              savedCount++;
            } catch (err) {
              console.error("Error saving embedding for item:", itemType, err);
            }
          }

          await new Promise((resolve, reject) => {
            tx.oncomplete = () => {
              if (savedCount > 0) {
                console.log(`Saved ${savedCount} embeddings to IndexedDB.`);
              }
              resolve();
            };
            tx.onerror = () => reject(tx.error);
            tx.onabort = () =>
              reject(new Error("Embeddings transaction aborted"));
          });
        } catch (e) {
          console.error("Failed to save embeddings:", e);
          throw e;
        }
      }

      async function loadEmbeddingsFromIndexedDB() {
        try {
          const db = await openDB();
          const tx = db.transaction([STORE_EMBEDDINGS], "readonly");
          const embeddingsStore = tx.objectStore(STORE_EMBEDDINGS);

          const embeddingsRecords = await new Promise((resolve, reject) => {
            const req = embeddingsStore.getAll();
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          const embeddingsMap = new Map();
          for (const record of embeddingsRecords) {
            embeddingsMap.set(record.type, record.vector);
          }

          return embeddingsMap;
        } catch (e) {
          console.error("Error loading embeddings from IndexedDB:", e);
          return new Map();
        }
      }

      async function loadFromIndexedDB() {
        try {
          const db = await openDB();
          const tx = db.transaction(
            [STORE_ITEMS, STORE_IMAGES, STORE_METADATA, STORE_EMBEDDINGS],
            "readonly"
          );

          const itemsStore = tx.objectStore(STORE_ITEMS);
          const items = await new Promise((resolve, reject) => {
            const req = itemsStore.getAll();
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          const imagesStore = tx.objectStore(STORE_IMAGES);
          const imageRecords = await new Promise((resolve, reject) => {
            const req = imagesStore.getAll();
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          const imageMap = new Map();
          for (const record of imageRecords) {
            imageMap.set(record.filename, URL.createObjectURL(record.blob));
          }

          const metadataStore = tx.objectStore(STORE_METADATA);
          const metadataRecord = await new Promise((resolve, reject) => {
            const req = metadataStore.get("extraction");
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          const metadata = metadataRecord
            ? {
                timestamp: metadataRecord.timestamp,
                Date: metadataRecord.Date,
              }
            : null;

          const embeddingsStore = tx.objectStore(STORE_EMBEDDINGS);
          const embeddingsRecords = await new Promise((resolve, reject) => {
            const req = embeddingsStore.getAll();
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          const embeddingsMap = new Map();
          for (const record of embeddingsRecords) {
            embeddingsMap.set(record.type, record.vector);
          }

          return { items, imageMap, metadata, embeddingsMap };
        } catch (e) {
          console.error("Error loading from IndexedDB:", e);
          return {
            items: [],
            imageMap: new Map(),
            metadata: null,
            embeddingsMap: new Map(),
          };
        }
      }

      async function clearIndexedDB() {
        try {
          const db = await openDB();
          const tx = db.transaction(
            [
              STORE_ITEMS,
              STORE_IMAGES,
              STORE_METADATA,
              STORE_EMBEDDINGS,
              STORE_INVENTORIES,
              STORE_INVENTORY_ITEMS,
              STORE_SUBLISTS,
            ],
            "readwrite"
          );
          await tx.objectStore(STORE_ITEMS).clear();
          await tx.objectStore(STORE_IMAGES).clear();
          await tx.objectStore(STORE_METADATA).clear();
          await tx.objectStore(STORE_EMBEDDINGS).clear();
          await tx.objectStore(STORE_INVENTORIES).clear();
          await tx.objectStore(STORE_INVENTORY_ITEMS).clear();
          await tx.objectStore(STORE_SUBLISTS).clear();
          await new Promise((resolve, reject) => {
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
          });
        } catch (e) {
          console.error("Error clearing IndexedDB:", e);
        }
      }

      async function getImagesFromIndexedDB() {
        try {
          const db = await openDB();
          const tx = db.transaction([STORE_IMAGES], "readonly");
          const imagesStore = tx.objectStore(STORE_IMAGES);
          const imageRecords = await new Promise((resolve, reject) => {
            const req = imagesStore.getAll();
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });

          const imageMap = new Map();
          for (const record of imageRecords) {
            imageMap.set(record.filename, record.blob);
          }
          return imageMap;
        } catch (e) {
          console.error("Error getting images from IndexedDB:", e);
          return new Map();
        }
      }

      // Save open tabs to IndexedDB
      async function saveOpenTabsToIndexedDB(
        openInventoryIds,
        activeInventoryId
      ) {
        try {
          const db = await openDB();
          const tx = db.transaction([STORE_METADATA], "readwrite");
          const metadataStore = tx.objectStore(STORE_METADATA);

          // Save open inventory IDs
          metadataStore.put({
            key: "openInventoryIds",
            value: JSON.stringify(openInventoryIds),
          });

          // Save active inventory ID
          metadataStore.put({
            key: "activeInventoryId",
            value: activeInventoryId || "",
          });

          await new Promise((resolve, reject) => {
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
          });
        } catch (e) {
          console.error("Error saving open tabs to IndexedDB:", e);
        }
      }

      // Load open tabs from IndexedDB
      async function loadOpenTabsFromIndexedDB() {
        try {
          const db = await openDB();
          const tx = db.transaction([STORE_METADATA], "readonly");
          const metadataStore = tx.objectStore(STORE_METADATA);

          const [openIdsRecord, activeIdRecord] = await Promise.all([
            new Promise((resolve, reject) => {
              const req = metadataStore.get("openInventoryIds");
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
            }),
            new Promise((resolve, reject) => {
              const req = metadataStore.get("activeInventoryId");
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
            }),
          ]);

          const openInventoryIds = openIdsRecord?.value
            ? JSON.parse(openIdsRecord.value)
            : [];
          const activeInventoryId = activeIdRecord?.value || null;

          return { openInventoryIds, activeInventoryId };
        } catch (e) {
          console.error("Error loading open tabs from IndexedDB:", e);
          return { openInventoryIds: [], activeInventoryId: null };
        }
      }

      // --- Components ---

      const Modal = ({
        isOpen,
        onClose,
        title,
        message,
        onConfirm,
        confirmText = "Confirm",
        cancelText = "Cancel",
        isCritical = false,
      }) => {
        if (!isOpen) return null;

        return (
          <div
            className={`fixed inset-0 z-50 flex items-center justify-center backdrop-blur-sm ${
              isCritical ? "bg-red-950/70" : "bg-black/60"
            }`}
            onClick={onClose}
          >
            <div
              className={`bg-slate-900 border rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl ${
                isCritical
                  ? "border-red-600/50 shadow-red-900/20"
                  : "border-slate-700"
              }`}
              onClick={(e) => e.stopPropagation()}
            >
              <h3
                className={`text-lg font-semibold mb-3 ${
                  isCritical ? "text-red-300" : "text-slate-200"
                }`}
              >
                {title}
              </h3>
              <p
                className={`mb-6 ${
                  isCritical ? "text-red-200/90" : "text-slate-400"
                }`}
              >
                {message}
              </p>
              <div className="flex justify-end gap-3">
                <button
                  onClick={onClose}
                  className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                >
                  {cancelText}
                </button>
                <button
                  onClick={onConfirm}
                  className="px-4 py-2 text-sm bg-red-600 hover:bg-red-500 text-white rounded-lg transition-colors font-semibold"
                >
                  {confirmText}
                </button>
              </div>
            </div>
          </div>
        );
      };

      const LoadingOverlay = ({ isVisible, message = "Processing..." }) => {
        if (!isVisible) return null;

        return (
          <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm">
            <div className="bg-slate-900 border border-slate-700 rounded-xl p-8 max-w-sm w-full mx-4 shadow-2xl flex flex-col items-center">
              <RefreshCw className="w-12 h-12 text-blue-500 animate-spin mb-4" />
              <p className="text-slate-200 text-lg font-medium">{message}</p>
              <p className="text-slate-400 text-sm mt-2">Please wait...</p>
            </div>
          </div>
        );
      };

      const ExportFormatModal = ({
        isOpen,
        onClose,
        onSelectFormat,
        hasSublistSelected = false,
      }) => {
        const [selectedFormat, setSelectedFormat] = useState(null);
        const [dataMetadataOptions, setDataMetadataOptions] = useState({
          images: true,
          quantity: true,
          rarity: true,
          prices: true,
        });

        useEffect(() => {
          if (isOpen) {
            setSelectedFormat(null);
            setDataMetadataOptions({
              images: true,
              quantity: true,
              rarity: true,
              prices: true,
            });
          }
        }, [isOpen]);

        if (!isOpen) return null;

        const toggleDataMetadataOption = (option) => {
          setDataMetadataOptions((prev) => ({
            ...prev,
            [option]: !prev[option],
          }));
        };

        const handleContinue = () => {
          if (!selectedFormat) return;

          if (selectedFormat === "data") {
            onSelectFormat("data", dataMetadataOptions);
          } else {
            onSelectFormat(selectedFormat);
          }
        };

        return (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm"
            onClick={onClose}
          >
            <div
              className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl"
              onClick={(e) => e.stopPropagation()}
            >
              <h3 className="text-lg font-semibold text-slate-200 mb-2">
                Export
              </h3>
              <p className="text-sm text-slate-400 mb-6">
                select a format to export to
              </p>
              <div className="space-y-2 mb-6">
                {!hasSublistSelected && (
                  <button
                    onClick={() => setSelectedFormat("data")}
                    className={`w-full text-left px-4 py-3 text-sm rounded-lg transition-colors border ${
                      selectedFormat === "data"
                        ? "bg-blue-600 text-white border-blue-500"
                        : "text-slate-300 hover:bg-slate-800 border-slate-700 hover:border-slate-600"
                    }`}
                  >
                    Data
                  </button>
                )}
                <button
                  onClick={() => setSelectedFormat("csv")}
                  className={`w-full text-left px-4 py-3 text-sm rounded-lg transition-colors border ${
                    selectedFormat === "csv"
                      ? "bg-blue-600 text-white border-blue-500"
                      : "text-slate-300 hover:bg-slate-800 border-slate-700 hover:border-slate-600"
                  }`}
                >
                  CSV
                </button>
                <button
                  onClick={() => setSelectedFormat("excel")}
                  className={`w-full text-left px-4 py-3 text-sm rounded-lg transition-colors border ${
                    selectedFormat === "excel"
                      ? "bg-blue-600 text-white border-blue-500"
                      : "text-slate-300 hover:bg-slate-800 border-slate-700 hover:border-slate-600"
                  }`}
                >
                  Excel
                </button>
                <button
                  onClick={() => setSelectedFormat("pdf")}
                  className={`w-full text-left px-4 py-3 text-sm rounded-lg transition-colors border ${
                    selectedFormat === "pdf"
                      ? "bg-blue-600 text-white border-blue-500"
                      : "text-slate-300 hover:bg-slate-800 border-slate-700 hover:border-slate-600"
                  }`}
                >
                  PDF
                </button>
              </div>

              {/* Metadata Options - always visible, enabled only when Data is selected */}
              <div
                className={`mb-6 border-t border-slate-800 pt-4 ${
                  selectedFormat !== "data" ? "opacity-50" : ""
                }`}
              >
                <p className="text-xs text-slate-500 mb-3">
                  Select data to include:
                </p>
                <div className="flex flex-wrap gap-3">
                  <label
                    className={`flex items-center gap-1.5 ${
                      selectedFormat === "data"
                        ? "cursor-pointer"
                        : "cursor-not-allowed"
                    }`}
                  >
                    <input
                      type="checkbox"
                      checked={
                        selectedFormat === "data"
                          ? dataMetadataOptions.images
                          : true
                      }
                      onChange={() => toggleDataMetadataOption("images")}
                      disabled={selectedFormat !== "data"}
                      className="w-3.5 h-3.5 text-blue-600 bg-slate-700 border-slate-600 rounded focus:ring-blue-500 disabled:cursor-not-allowed"
                    />
                    <span className="text-xs text-slate-400">Images</span>
                  </label>
                  <label
                    className={`flex items-center gap-1.5 ${
                      selectedFormat === "data"
                        ? "cursor-pointer"
                        : "cursor-not-allowed"
                    }`}
                  >
                    <input
                      type="checkbox"
                      checked={
                        selectedFormat === "data"
                          ? dataMetadataOptions.quantity
                          : true
                      }
                      onChange={() => toggleDataMetadataOption("quantity")}
                      disabled={selectedFormat !== "data"}
                      className="w-3.5 h-3.5 text-blue-600 bg-slate-700 border-slate-600 rounded focus:ring-blue-500 disabled:cursor-not-allowed"
                    />
                    <span className="text-xs text-slate-400">Quantity</span>
                  </label>
                  <label
                    className={`flex items-center gap-1.5 ${
                      selectedFormat === "data"
                        ? "cursor-pointer"
                        : "cursor-not-allowed"
                    }`}
                  >
                    <input
                      type="checkbox"
                      checked={
                        selectedFormat === "data"
                          ? dataMetadataOptions.rarity
                          : true
                      }
                      onChange={() => toggleDataMetadataOption("rarity")}
                      disabled={selectedFormat !== "data"}
                      className="w-3.5 h-3.5 text-blue-600 bg-slate-700 border-slate-600 rounded focus:ring-blue-500 disabled:cursor-not-allowed"
                    />
                    <span className="text-xs text-slate-400">Rarity</span>
                  </label>
                  <label
                    className={`flex items-center gap-1.5 ${
                      selectedFormat === "data"
                        ? "cursor-pointer"
                        : "cursor-not-allowed"
                    }`}
                  >
                    <input
                      type="checkbox"
                      checked={
                        selectedFormat === "data"
                          ? dataMetadataOptions.prices
                          : true
                      }
                      onChange={() => toggleDataMetadataOption("prices")}
                      disabled={selectedFormat !== "data"}
                      className="w-3.5 h-3.5 text-blue-600 bg-slate-700 border-slate-600 rounded focus:ring-blue-500 disabled:cursor-not-allowed"
                    />
                    <span className="text-xs text-slate-400">Prices</span>
                  </label>
                </div>
              </div>

              <div className="flex justify-end gap-3">
                <button
                  onClick={onClose}
                  className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleContinue}
                  disabled={!selectedFormat}
                  className="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-500 text-white rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Continue
                </button>
              </div>
            </div>
          </div>
        );
      };

      // Settings Menu Component
      const SettingsMenu = ({
        handleSaveToDesktop,
        onClearManager,
        activeInventoryName,
      }) => {
        const [isOpen, setIsOpen] = useState(false);
        const menuRef = useRef(null);

        useEffect(() => {
          const handleClickOutside = (event) => {
            if (menuRef.current && !menuRef.current.contains(event.target)) {
              setIsOpen(false);
            }
          };

          if (isOpen) {
            document.addEventListener("mousedown", handleClickOutside);
          }

          return () => {
            document.removeEventListener("mousedown", handleClickOutside);
          };
        }, [isOpen]);

        return (
          <div className="relative" ref={menuRef}>
            <button
              onClick={() => setIsOpen(!isOpen)}
              className="p-2 text-slate-400 hover:text-slate-200 rounded hover:bg-slate-800 transition-colors"
            >
              <Settings className="w-5 h-5" />
            </button>

            {isOpen && (
              <div className="absolute right-0 mt-2 w-48 bg-slate-800 border border-slate-700 rounded-lg shadow-xl z-50 overflow-hidden">
                <button
                  onClick={() => {
                    handleSaveToDesktop();
                    setIsOpen(false);
                  }}
                  className="w-full text-left px-4 py-2 text-sm text-slate-300 hover:bg-slate-700 transition-colors"
                >
                  Save to Desktop
                </button>
                <button
                  onClick={() => {
                    onClearManager();
                    setIsOpen(false);
                  }}
                  className="w-full text-left px-4 py-2 text-sm text-red-400 hover:bg-slate-700 transition-colors"
                >
                  Clear Manager
                </button>
              </div>
            )}
          </div>
        );
      };

      // Filter Modal
      const FilterModal = ({
        isOpen,
        onClose,
        filters,
        onFiltersChange,
        panel,
      }) => {
        const [localFilters, setLocalFilters] = useState(filters);

        useEffect(() => {
          if (isOpen) {
            setLocalFilters(filters);
          }
        }, [isOpen, filters]);

        if (!isOpen) return null;

        const handleRarityToggle = (rarity) => {
          setLocalFilters((prev) => ({
            ...prev,
            rarities: prev.rarities.includes(rarity)
              ? prev.rarities.filter((r) => r !== rarity)
              : [...prev.rarities, rarity],
          }));
        };

        const handleApply = () => {
          onFiltersChange(localFilters);
          onClose();
        };

        const handleClear = () => {
          const clearedFilters = {
            rarities: [],
            quantityMin: null,
            quantityMax: null,
            quantityMode: "all",
            priceMin: null,
            priceMax: null,
            hasPrice: null,
          };
          setLocalFilters(clearedFilters);
          onFiltersChange(clearedFilters);
        };

        const hasActiveFilters = () => {
          return (
            localFilters.rarities.length > 0 ||
            localFilters.quantityMin !== null ||
            localFilters.quantityMax !== null ||
            localFilters.quantityMode !== "all" ||
            localFilters.priceMin !== null ||
            localFilters.priceMax !== null ||
            localFilters.hasPrice !== null
          );
        };

        return (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm"
            onClick={onClose}
          >
            <div
              className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-2xl w-full mx-4 shadow-2xl max-h-[90vh] overflow-y-auto"
              onClick={(e) => e.stopPropagation()}
            >
              <div className="flex items-center justify-between mb-6">
                <h3 className="text-lg font-semibold text-slate-200">
                  Filter Items
                  {panel === "left"
                    ? " (Left Panel)"
                    : panel === "right"
                    ? " (Right Panel)"
                    : ""}
                </h3>
                <button
                  onClick={onClose}
                  className="text-slate-400 hover:text-white transition-colors"
                >
                  <X className="w-5 h-5" />
                </button>
              </div>

              {/* Rarity Filter */}
              <div className="mb-6">
                <label className="block text-sm font-medium text-slate-300 mb-3">
                  Rarity
                </label>
                <div className="flex flex-wrap gap-2">
                  {Object.entries(RARITY_MAP).map(([value, config]) => {
                    const rarityValue = parseInt(value);
                    const isSelected =
                      localFilters.rarities.includes(rarityValue);
                    return (
                      <button
                        key={value}
                        onClick={() => handleRarityToggle(rarityValue)}
                        className={`px-4 py-2 rounded-lg text-sm font-medium transition-all ${
                          isSelected
                            ? `text-blue-400 border-blue-600 bg-blue-900/20 border-2 border-current`
                            : "bg-slate-800 text-slate-400 border-2 border-slate-700 hover:border-slate-600"
                        }`}
                      >
                        {config.label}
                      </button>
                    );
                  })}
                </div>
              </div>

              {/* Quantity Filter */}
              <div className="mb-6">
                <label className="block text-sm font-medium text-slate-300 mb-3">
                  Quantity
                </label>
                <div className="space-y-3">
                  <div className="flex gap-2">
                    <button
                      onClick={() =>
                        setLocalFilters((prev) => ({
                          ...prev,
                          quantityMode: "all",
                        }))
                      }
                      className={`px-4 py-2 rounded-lg text-sm transition-colors ${
                        localFilters.quantityMode === "all"
                          ? "bg-blue-600 text-white"
                          : "bg-slate-800 text-slate-400 hover:bg-slate-700"
                      }`}
                    >
                      All
                    </button>
                    <button
                      onClick={() =>
                        setLocalFilters((prev) => ({
                          ...prev,
                          quantityMode: "inStock",
                        }))
                      }
                      className={`px-4 py-2 rounded-lg text-sm transition-colors ${
                        localFilters.quantityMode === "inStock"
                          ? "bg-blue-600 text-white"
                          : "bg-slate-800 text-slate-400 hover:bg-slate-700"
                      }`}
                    >
                      In Stock
                    </button>
                    <button
                      onClick={() =>
                        setLocalFilters((prev) => ({
                          ...prev,
                          quantityMode: "outOfStock",
                        }))
                      }
                      className={`px-4 py-2 rounded-lg text-sm transition-colors ${
                        localFilters.quantityMode === "outOfStock"
                          ? "bg-blue-600 text-white"
                          : "bg-slate-800 text-slate-400 hover:bg-slate-700"
                      }`}
                    >
                      Out of Stock
                    </button>
                  </div>
                  {localFilters.quantityMode === "all" && (
                    <div className="flex gap-3 items-center">
                      <div className="flex-1">
                        <label className="block text-xs text-slate-400 mb-1">
                          Min
                        </label>
                        <input
                          type="number"
                          min="0"
                          value={localFilters.quantityMin || ""}
                          onChange={(e) =>
                            setLocalFilters((prev) => ({
                              ...prev,
                              quantityMin:
                                e.target.value === ""
                                  ? null
                                  : parseInt(e.target.value) || 0,
                            }))
                          }
                          placeholder="Min"
                          className="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded-lg text-slate-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        />
                      </div>
                      <div className="flex-1">
                        <label className="block text-xs text-slate-400 mb-1">
                          Max
                        </label>
                        <input
                          type="number"
                          min="0"
                          value={localFilters.quantityMax || ""}
                          onChange={(e) =>
                            setLocalFilters((prev) => ({
                              ...prev,
                              quantityMax:
                                e.target.value === ""
                                  ? null
                                  : parseInt(e.target.value) || 0,
                            }))
                          }
                          placeholder="Max"
                          className="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded-lg text-slate-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        />
                      </div>
                    </div>
                  )}
                </div>
              </div>

              {/* Price Filter */}
              <div className="mb-6">
                <label className="block text-sm font-medium text-slate-300 mb-3">
                  Price
                </label>
                <div className="space-y-3">
                  <div className="flex gap-2">
                    <button
                      onClick={() =>
                        setLocalFilters((prev) => ({
                          ...prev,
                          hasPrice: null,
                        }))
                      }
                      className={`px-4 py-2 rounded-lg text-sm transition-colors ${
                        localFilters.hasPrice === null
                          ? "bg-blue-600 text-white"
                          : "bg-slate-800 text-slate-400 hover:bg-slate-700"
                      }`}
                    >
                      All
                    </button>
                    <button
                      onClick={() =>
                        setLocalFilters((prev) => ({
                          ...prev,
                          hasPrice: true,
                        }))
                      }
                      className={`px-4 py-2 rounded-lg text-sm transition-colors ${
                        localFilters.hasPrice === true
                          ? "bg-blue-600 text-white"
                          : "bg-slate-800 text-slate-400 hover:bg-slate-700"
                      }`}
                    >
                      Has Price
                    </button>
                    <button
                      onClick={() =>
                        setLocalFilters((prev) => ({
                          ...prev,
                          hasPrice: false,
                        }))
                      }
                      className={`px-4 py-2 rounded-lg text-sm transition-colors ${
                        localFilters.hasPrice === false
                          ? "bg-blue-600 text-white"
                          : "bg-slate-800 text-slate-400 hover:bg-slate-700"
                      }`}
                    >
                      No Price
                    </button>
                  </div>
                  <div className="flex gap-3 items-center">
                    <div className="flex-1">
                      <label className="block text-xs text-slate-400 mb-1">
                        Min ($)
                      </label>
                      <input
                        type="number"
                        min="0"
                        step="0.01"
                        value={localFilters.priceMin || ""}
                        onChange={(e) =>
                          setLocalFilters((prev) => ({
                            ...prev,
                            priceMin:
                              e.target.value === ""
                                ? null
                                : parseFloat(e.target.value) || 0,
                          }))
                        }
                        placeholder="Min"
                        className="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded-lg text-slate-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      />
                    </div>
                    <div className="flex-1">
                      <label className="block text-xs text-slate-400 mb-1">
                        Max ($)
                      </label>
                      <input
                        type="number"
                        min="0"
                        step="0.01"
                        value={localFilters.priceMax || ""}
                        onChange={(e) =>
                          setLocalFilters((prev) => ({
                            ...prev,
                            priceMax:
                              e.target.value === ""
                                ? null
                                : parseFloat(e.target.value) || 0,
                          }))
                        }
                        placeholder="Max"
                        className="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded-lg text-slate-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      />
                    </div>
                  </div>
                </div>
              </div>

              {/* Actions */}
              <div className="flex justify-between items-center pt-4 border-t border-slate-700">
                <button
                  onClick={handleClear}
                  disabled={!hasActiveFilters()}
                  className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Clear All
                </button>
                <div className="flex gap-3">
                  <button
                    onClick={onClose}
                    className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleApply}
                    className="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-500 text-white rounded-lg transition-colors"
                  >
                    Apply Filters
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      };

      // New Inventory Modal
      const NewInventoryModal = ({
        isOpen,
        onClose,
        onCreate,
        onUploadData,
      }) => {
        const [name, setName] = useState("");
        const [isUploading, setIsUploading] = useState(false);

        if (!isOpen) return null;

        const handleCreate = () => {
          if (name.trim()) {
            onCreate(name.trim());
            setName("");
          }
        };

        const handleUpload = () => {
          setIsUploading(true);
          onUploadData(() => setIsUploading(false));
        };

        return (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm"
            onClick={onClose}
          >
            <div
              className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl"
              onClick={(e) => e.stopPropagation()}
            >
              <h3 className="text-lg font-semibold text-slate-200 mb-4">
                New Inventory
              </h3>
              <div className="mb-4">
                <label className="block text-sm text-slate-400 mb-2">
                  Inventory Name
                </label>
                <input
                  type="text"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  placeholder="Enter inventory name"
                  className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg text-slate-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  autoFocus
                  onKeyPress={(e) => e.key === "Enter" && handleCreate()}
                />
              </div>

              <div className="flex justify-end gap-3">
                <button
                  onClick={onClose}
                  className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleCreate}
                  disabled={!name.trim()}
                  className="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-500 text-white rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Create Inventory
                </button>
              </div>
            </div>
          </div>
        );
      };

      // Open Inventory Modal
      const OpenInventoryModal = ({
        isOpen,
        onClose,
        inventories,
        openInventoryIds,
        onOpenInventory,
      }) => {
        if (!isOpen) return null;

        const closedInventories = inventories.filter(
          (inv) => !openInventoryIds.includes(inv.id)
        );
        const openInventories = inventories.filter((inv) =>
          openInventoryIds.includes(inv.id)
        );

        return (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm"
            onClick={onClose}
          >
            <div
              className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl max-h-[80vh] overflow-y-auto"
              onClick={(e) => e.stopPropagation()}
            >
              <h3 className="text-lg font-semibold text-slate-200 mb-4">
                Open Inventory
              </h3>

              {openInventories.length > 0 && (
                <div className="mb-4">
                  <p className="text-sm text-slate-400 mb-2">
                    Open Inventories
                  </p>
                  {openInventories.map((inv) => (
                    <div
                      key={inv.id}
                      className="px-4 py-2 bg-slate-800 rounded-lg mb-2 flex items-center justify-between"
                    >
                      <span className="text-slate-300">{inv.name}</span>
                      <span className="text-xs text-green-400"> Open</span>
                    </div>
                  ))}
                </div>
              )}

              {closedInventories.length > 0 ? (
                <div>
                  <p className="text-sm text-slate-400 mb-2">
                    Closed Inventories
                  </p>
                  {closedInventories.map((inv) => (
                    <div
                      key={inv.id}
                      className="px-4 py-2 bg-slate-800 rounded-lg mb-2 flex items-center justify-between"
                    >
                      <span className="text-slate-300">{inv.name}</span>
                      <button
                        onClick={() => {
                          onOpenInventory(inv.id);
                          onClose();
                        }}
                        className="px-3 py-1 text-sm bg-blue-600 hover:bg-blue-500 text-white rounded-lg transition-colors"
                      >
                        Open
                      </button>
                    </div>
                  ))}
                </div>
              ) : (
                <p className="text-sm text-slate-400">
                  All inventories are open
                </p>
              )}

              <div className="flex justify-end mt-6">
                <button
                  onClick={onClose}
                  className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                >
                  Close
                </button>
              </div>
            </div>
          </div>
        );
      };

      // New Sublist Modal
      const NewSublistModal = ({ isOpen, onClose, onCreate }) => {
        const [name, setName] = useState("");

        useEffect(() => {
          if (isOpen) {
            setName("");
          }
        }, [isOpen]);

        if (!isOpen) return null;

        const handleCreate = () => {
          if (name.trim()) {
            onCreate(name.trim());
            setName("");
          }
        };

        return (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm"
            onClick={onClose}
          >
            <div
              className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl"
              onClick={(e) => e.stopPropagation()}
            >
              <h3 className="text-lg font-semibold text-slate-200 mb-4">
                New Sublist
              </h3>
              <div className="mb-4">
                <label className="block text-sm text-slate-400 mb-2">
                  Sublist Name
                </label>
                <input
                  type="text"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  placeholder="Enter sublist name"
                  className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg text-slate-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  autoFocus
                  onKeyPress={(e) => e.key === "Enter" && handleCreate()}
                />
              </div>
              <div className="flex justify-end gap-3">
                <button
                  onClick={onClose}
                  className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleCreate}
                  disabled={!name.trim()}
                  className="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-500 text-white rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Create Sublist
                </button>
              </div>
            </div>
          </div>
        );
      };

      // Add to Sublist Modal
      const AddToSublistModal = ({
        isOpen,
        onClose,
        sublists,
        item,
        imageMap,
        onAdd,
      }) => {
        const [selectedSublistId, setSelectedSublistId] = useState("");

        useEffect(() => {
          if (isOpen && item) {
            setSelectedSublistId("");
          }
        }, [isOpen, item]);

        if (!isOpen || !item) return null;

        const imageUrl = imageMap?.get(item.image);
        const handleAdd = () => {
          if (selectedSublistId && selectedSublistId.trim() !== "") {
            onAdd(selectedSublistId, 1);
          } else {
            console.error("No sublist selected");
          }
        };

        return (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm"
            onClick={onClose}
          >
            <div
              className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl"
              onClick={(e) => e.stopPropagation()}
            >
              <h3 className="text-lg font-semibold text-slate-200 mb-4">
                Add to Sublist
              </h3>
              <div className="mb-4">
                <div className="px-4 py-3 bg-slate-800 rounded-lg mb-4 flex items-center gap-3">
                  <div className="w-16 h-16 flex-shrink-0 rounded-lg bg-slate-700/50 border border-slate-600/50 overflow-hidden relative">
                    {imageUrl ? (
                      <img
                        src={imageUrl}
                        alt={item.name}
                        className="w-full h-full object-contain"
                        loading="lazy"
                      />
                    ) : (
                      <div className="w-full h-full flex flex-col items-center justify-center text-slate-600">
                        <ImageIcon className="w-5 h-5 opacity-40" />
                      </div>
                    )}
                  </div>
                  <div className="flex-1 min-w-0">
                    <div className="text-sm font-medium text-slate-300 truncate">
                      {item.name}
                    </div>
                    <div className="text-xs text-slate-500 mt-1 truncate">
                      {item.type}
                    </div>
                  </div>
                </div>
                <label className="block text-sm text-slate-400 mb-2">
                  Select Sublist
                </label>
                <select
                  value={selectedSublistId}
                  onChange={(e) => setSelectedSublistId(e.target.value)}
                  className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg text-slate-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="">-- Select a sublist --</option>
                  {sublists.map((sublist) => (
                    <option key={sublist.id} value={sublist.id}>
                      {sublist.name}
                    </option>
                  ))}
                </select>
              </div>
              <div className="flex justify-end gap-3">
                <button
                  onClick={onClose}
                  className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleAdd}
                  disabled={!selectedSublistId}
                  className="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-500 text-white rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Add
                </button>
              </div>
            </div>
          </div>
        );
      };

      // Export Inventory Modal
      const ExportInventoryModal = ({
        isOpen,
        onClose,
        inventories,
        onExport,
        preSelectedId,
        tabInventoryId,
        sublists = [],
      }) => {
        const [selectedIds, setSelectedIds] = useState(new Set());

        useEffect(() => {
          if (isOpen && preSelectedId) {
            setSelectedIds(new Set([preSelectedId]));
          } else if (isOpen) {
            setSelectedIds(new Set());
          }
        }, [isOpen, preSelectedId]);

        if (!isOpen) return null;

        // Filter inventories to show only the tab's inventory and its sublists
        const filteredInventories = tabInventoryId
          ? inventories.filter((inv) => inv.id === tabInventoryId)
          : inventories;

        // Create list items: main inventory + sublists
        const exportableItems = [];
        if (tabInventoryId) {
          const mainInventory = inventories.find(
            (inv) => inv.id === tabInventoryId
          );
          if (mainInventory) {
            exportableItems.push({
              id: mainInventory.id,
              name: mainInventory.name,
              type: "inventory",
            });
          }
          // Add sublists
          sublists.forEach((sublist) => {
            exportableItems.push({
              id: sublist.id,
              name: sublist.name,
              type: "sublist",
            });
          });
        } else {
          // Fallback: show all inventories if no tabInventoryId
          filteredInventories.forEach((inv) => {
            exportableItems.push({
              id: inv.id,
              name: inv.name,
              type: "inventory",
            });
          });
        }

        const toggleSelection = (id) => {
          const newSet = new Set(selectedIds);
          if (newSet.has(id)) {
            newSet.delete(id);
          } else {
            newSet.add(id);
          }
          setSelectedIds(newSet);
        };

        const handleExport = () => {
          if (selectedIds.size > 0) {
            // Check if any selected items are sublists
            const selectedItems = exportableItems.filter((item) =>
              selectedIds.has(item.id)
            );
            const hasSublist = selectedItems.some(
              (item) => item.type === "sublist"
            );

            // Find the sublist item if one is selected
            const sublistItem = selectedItems.find(
              (item) => item.type === "sublist"
            );
            const sublistId = sublistItem ? sublistItem.id : null;
            const parentInventoryId =
              sublistItem && tabInventoryId ? tabInventoryId : null;

            // Pass default metadata options (all enabled) and sublist flag
            onExport(
              Array.from(selectedIds),
              {
                images: true,
                quantity: true,
                rarity: true,
                prices: true,
              },
              hasSublist,
              sublistId,
              parentInventoryId
            );
            setSelectedIds(new Set());
            onClose();
          }
        };

        return (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm"
            onClick={onClose}
          >
            <div
              className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl max-h-[80vh] overflow-y-auto"
              onClick={(e) => e.stopPropagation()}
            >
              <h3 className="text-lg font-semibold text-slate-200 mb-4">
                Export Inventory
              </h3>
              <p className="text-sm text-slate-400 mb-4">Select export items</p>

              <div className="space-y-2 mb-6">
                {exportableItems.map((item) => (
                  <label
                    key={item.id}
                    className="flex items-center gap-3 px-4 py-2 bg-slate-800 rounded-lg cursor-pointer hover:bg-slate-700 transition-colors"
                  >
                    <input
                      type="checkbox"
                      checked={selectedIds.has(item.id)}
                      onChange={() => toggleSelection(item.id)}
                      className="w-4 h-4 text-blue-600 bg-slate-700 border-slate-600 rounded focus:ring-blue-500"
                    />
                    <span className="text-slate-300 flex-1">
                      {item.name}
                      {item.type === "sublist" && (
                        <span className="text-xs text-slate-500 ml-2">
                          (Sublist)
                        </span>
                      )}
                    </span>
                  </label>
                ))}
              </div>

              <div className="flex justify-end gap-3">
                <button
                  onClick={onClose}
                  className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleExport}
                  disabled={selectedIds.size === 0}
                  className="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-500 text-white rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Export ({selectedIds.size})
                </button>
              </div>
            </div>
          </div>
        );
      };

      // Transfer Item Modal
      const TransferItemModal = ({
        isOpen,
        onClose,
        item,
        sourceInventoryId,
        inventories,
        imageMap,
        onTransfer,
      }) => {
        const [targetInventoryId, setTargetInventoryId] = useState("");
        const [quantity, setQuantity] = useState(1);
        const [maxQuantity, setMaxQuantity] = useState(0);

        useEffect(() => {
          if (isOpen && item) {
            setQuantity(1);
            setMaxQuantity(item.quantity || 0);
            setTargetInventoryId("");
          }
        }, [isOpen, item]);

        if (!isOpen || !item) return null;

        const imageUrl = imageMap?.get(item.image);
        const availableInventories = inventories.filter(
          (inv) => inv.id !== sourceInventoryId
        );

        const handleTransfer = () => {
          if (targetInventoryId && quantity > 0 && quantity <= maxQuantity) {
            onTransfer(
              sourceInventoryId,
              targetInventoryId,
              item.type,
              quantity
            );
            onClose();
          }
        };

        return (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm"
            onClick={onClose}
          >
            <div
              className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl"
              onClick={(e) => e.stopPropagation()}
            >
              <h3 className="text-lg font-semibold text-slate-200 mb-4">
                Transfer Item
              </h3>
              <div className="mb-4">
                <div className="px-4 py-3 bg-slate-800 rounded-lg mb-4 flex items-center gap-3">
                  <div className="w-16 h-16 flex-shrink-0 rounded-lg bg-slate-700/50 border border-slate-600/50 overflow-hidden relative">
                    {imageUrl ? (
                      <img
                        src={imageUrl}
                        alt={item.name}
                        className="w-full h-full object-contain"
                        loading="lazy"
                      />
                    ) : (
                      <div className="w-full h-full flex flex-col items-center justify-center text-slate-600">
                        <ImageIcon className="w-5 h-5 opacity-40" />
                      </div>
                    )}
                  </div>
                  <div className="flex-1 min-w-0">
                    <div className="text-sm font-medium text-slate-300 truncate">
                      {item.name}
                    </div>
                    <div className="text-xs text-slate-500 mt-1 truncate">
                      {item.type}
                    </div>
                    <div className="text-xs text-slate-400 mt-1">
                      Available:{" "}
                      <span className="text-slate-200">{maxQuantity}</span>
                    </div>
                  </div>
                </div>
              </div>
              <div className="mb-4">
                <label className="block text-sm text-slate-400 mb-2">
                  Transfer To
                </label>
                <select
                  value={targetInventoryId}
                  onChange={(e) => setTargetInventoryId(e.target.value)}
                  className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg text-slate-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="">Select inventory...</option>
                  {availableInventories.map((inv) => (
                    <option key={inv.id} value={inv.id}>
                      {inv.name}
                    </option>
                  ))}
                </select>
              </div>
              <div className="mb-6">
                <label className="block text-sm text-slate-400 mb-2">
                  Quantity
                </label>
                <input
                  type="number"
                  value={quantity}
                  onChange={(e) => {
                    const val = parseInt(e.target.value) || 1;
                    setQuantity(Math.min(Math.max(1, val), maxQuantity));
                  }}
                  min="1"
                  max={maxQuantity}
                  className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg text-slate-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
                <p className="text-xs text-slate-500 mt-1">
                  Max: {maxQuantity}
                </p>
              </div>
              <div className="flex justify-end gap-3">
                <button
                  onClick={onClose}
                  className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleTransfer}
                  disabled={
                    !targetInventoryId ||
                    quantity <= 0 ||
                    quantity > maxQuantity
                  }
                  className="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-500 text-white rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Transfer
                </button>
              </div>
            </div>
          </div>
        );
      };

      const ConflictsResolutionModal = ({
        isOpen,
        onClose,
        conflicts,
        imageMap,
        loadedUrlMap,
        onApply,
      }) => {
        const [resolutions, setResolutions] = useState({});

        useEffect(() => {
          if (isOpen && conflicts) {
            // Initialize resolutions with default "Keep" for all conflicts
            const initialResolutions = {};
            conflicts.forEach((conflict) => {
              const key = `${conflict.itemType}-${conflict.field}`;
              initialResolutions[key] = "keep";
            });
            setResolutions(initialResolutions);
          }
        }, [isOpen, conflicts]);

        if (!isOpen || !conflicts || conflicts.length === 0) return null;

        const handleResolutionChange = (itemType, field, action) => {
          const key = `${itemType}-${field}`;
          setResolutions((prev) => ({
            ...prev,
            [key]: action,
          }));
        };

        const handleApply = () => {
          onApply(resolutions);
          onClose();
        };

        const handleApplyAll = (action) => {
          const newResolutions = {};
          conflicts.forEach((conflict) => {
            const key = `${conflict.itemType}-${conflict.field}`;
            newResolutions[key] = action;
          });
          setResolutions(newResolutions);
        };

        // Group conflicts by item
        const conflictsByItem = {};
        conflicts.forEach((conflict) => {
          if (!conflictsByItem[conflict.itemType]) {
            conflictsByItem[conflict.itemType] = {
              item: conflict.item,
              conflicts: [],
            };
          }
          conflictsByItem[conflict.itemType].conflicts.push(conflict);
        });

        return (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm"
            onClick={onClose}
          >
            <div
              className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-4xl w-full mx-4 shadow-2xl max-h-[90vh] flex flex-col"
              onClick={(e) => e.stopPropagation()}
            >
              <h3 className="text-lg font-semibold text-slate-200 mb-4">
                Resolve Conflicts ({conflicts.length} found)
              </h3>

              <div className="mb-4 flex gap-2">
                <button
                  onClick={() => handleApplyAll("keep")}
                  className="px-3 py-1 text-xs bg-slate-800 hover:bg-slate-700 text-slate-300 rounded transition-colors"
                >
                  Keep All Existing
                </button>
                <button
                  onClick={() => handleApplyAll("replace")}
                  className="px-3 py-1 text-xs bg-slate-800 hover:bg-slate-700 text-slate-300 rounded transition-colors"
                >
                  Replace All
                </button>
              </div>

              <div className="flex-1 overflow-y-auto mb-4">
                <div className="space-y-4">
                  {Object.entries(conflictsByItem).map(
                    ([itemType, { item, conflicts: itemConflicts }]) => {
                      const imageUrl = imageMap?.get(item.image);
                      return (
                        <div
                          key={itemType}
                          className="bg-slate-800 rounded-lg p-4 border border-slate-700"
                        >
                          <div className="flex items-start gap-4 mb-3">
                            <div className="w-16 h-16 flex-shrink-0 rounded-lg bg-slate-700/50 border border-slate-600/50 overflow-hidden relative">
                              {imageUrl ? (
                                <img
                                  src={imageUrl}
                                  alt={item.name}
                                  className="w-full h-full object-contain"
                                  loading="lazy"
                                />
                              ) : (
                                <div className="w-full h-full flex flex-col items-center justify-center text-slate-600">
                                  <ImageIcon className="w-5 h-5 opacity-40" />
                                </div>
                              )}
                            </div>
                            <div className="flex-1 min-w-0">
                              <div className="text-sm font-medium text-slate-300">
                                {item.name}
                              </div>
                              <div className="text-xs text-slate-500 mt-1">
                                {item.type}
                              </div>
                            </div>
                          </div>

                          <div className="space-y-2">
                            {itemConflicts.map((conflict) => {
                              const key = `${conflict.itemType}-${conflict.field}`;
                              const resolution = resolutions[key] || "keep";
                              const fieldLabel =
                                conflict.field.charAt(0).toUpperCase() +
                                conflict.field.slice(1);

                              return (
                                <div
                                  key={key}
                                  className="bg-slate-900 rounded p-3 border border-slate-700/50"
                                >
                                  <div className="flex items-center justify-between mb-2">
                                    <span className="text-sm font-medium text-slate-300">
                                      {fieldLabel}
                                    </span>
                                    <div className="flex gap-2">
                                      {conflict.field === "quantity" ? (
                                        <>
                                          <button
                                            onClick={() =>
                                              handleResolutionChange(
                                                conflict.itemType,
                                                conflict.field,
                                                "keep"
                                              )
                                            }
                                            className={`px-2 py-1 text-xs rounded transition-colors ${
                                              resolution === "keep"
                                                ? "bg-blue-600 text-white"
                                                : "bg-slate-700 text-slate-300 hover:bg-slate-600"
                                            }`}
                                          >
                                            Keep ({conflict.currentValue})
                                          </button>
                                          <button
                                            onClick={() =>
                                              handleResolutionChange(
                                                conflict.itemType,
                                                conflict.field,
                                                "replace"
                                              )
                                            }
                                            className={`px-2 py-1 text-xs rounded transition-colors ${
                                              resolution === "replace"
                                                ? "bg-blue-600 text-white"
                                                : "bg-slate-700 text-slate-300 hover:bg-slate-600"
                                            }`}
                                          >
                                            Replace ({conflict.newValue})
                                          </button>
                                        </>
                                      ) : conflict.field === "image" ? (
                                        <>
                                          {/* Image conflict - show previews */}
                                          <div className="flex gap-4 items-center mb-2">
                                            <div className="flex-1">
                                              <div className="text-xs text-slate-400 mb-1">
                                                Current Image:
                                              </div>
                                              <div className="w-20 h-20 rounded-lg bg-slate-700/50 border border-slate-600/50 overflow-hidden">
                                                {imageMap?.get(
                                                  conflict.currentValue
                                                ) ? (
                                                  <img
                                                    src={imageMap.get(
                                                      conflict.currentValue
                                                    )}
                                                    alt="Current"
                                                    className="w-full h-full object-contain"
                                                  />
                                                ) : (
                                                  <div className="w-full h-full flex items-center justify-center">
                                                    <ImageIcon className="w-5 h-5 opacity-40 text-slate-600" />
                                                  </div>
                                                )}
                                              </div>
                                              <div className="text-xs text-slate-500 mt-1 truncate max-w-[80px]">
                                                {conflict.currentValue ||
                                                  "None"}
                                              </div>
                                            </div>
                                            <div className="text-slate-500">
                                              
                                            </div>
                                            <div className="flex-1">
                                              <div className="text-xs text-slate-400 mb-1">
                                                New Image:
                                              </div>
                                              <div className="w-20 h-20 rounded-lg bg-slate-700/50 border border-slate-600/50 overflow-hidden">
                                                {loadedUrlMap?.get(
                                                  conflict.newValue
                                                ) ||
                                                imageMap?.get(
                                                  conflict.newValue
                                                ) ? (
                                                  <img
                                                    src={
                                                      loadedUrlMap?.get(
                                                        conflict.newValue
                                                      ) ||
                                                      imageMap.get(
                                                        conflict.newValue
                                                      )
                                                    }
                                                    alt="New"
                                                    className="w-full h-full object-contain"
                                                  />
                                                ) : (
                                                  <div className="w-full h-full flex items-center justify-center">
                                                    <ImageIcon className="w-5 h-5 opacity-40 text-slate-600" />
                                                  </div>
                                                )}
                                              </div>
                                              <div className="text-xs text-slate-500 mt-1 truncate max-w-[80px]">
                                                {conflict.newValue || "None"}
                                              </div>
                                            </div>
                                          </div>
                                          <div className="flex gap-2">
                                            <button
                                              onClick={() =>
                                                handleResolutionChange(
                                                  conflict.itemType,
                                                  conflict.field,
                                                  "keep"
                                                )
                                              }
                                              className={`px-2 py-1 text-xs rounded transition-colors ${
                                                resolution === "keep"
                                                  ? "bg-blue-600 text-white"
                                                  : "bg-slate-700 text-slate-300 hover:bg-slate-600"
                                              }`}
                                            >
                                              Keep Current
                                            </button>
                                            <button
                                              onClick={() =>
                                                handleResolutionChange(
                                                  conflict.itemType,
                                                  conflict.field,
                                                  "replace"
                                                )
                                              }
                                              className={`px-2 py-1 text-xs rounded transition-colors ${
                                                resolution === "replace"
                                                  ? "bg-blue-600 text-white"
                                                  : "bg-slate-700 text-slate-300 hover:bg-slate-600"
                                              }`}
                                            >
                                              Use New
                                            </button>
                                          </div>
                                        </>
                                      ) : (
                                        <>
                                          <button
                                            onClick={() =>
                                              handleResolutionChange(
                                                conflict.itemType,
                                                conflict.field,
                                                "keep"
                                              )
                                            }
                                            className={`px-2 py-1 text-xs rounded transition-colors ${
                                              resolution === "keep"
                                                ? "bg-blue-600 text-white"
                                                : "bg-slate-700 text-slate-300 hover:bg-slate-600"
                                            }`}
                                          >
                                            Keep ({conflict.currentValue})
                                          </button>
                                          <button
                                            onClick={() =>
                                              handleResolutionChange(
                                                conflict.itemType,
                                                conflict.field,
                                                "replace"
                                              )
                                            }
                                            className={`px-2 py-1 text-xs rounded transition-colors ${
                                              resolution === "replace"
                                                ? "bg-blue-600 text-white"
                                                : "bg-slate-700 text-slate-300 hover:bg-slate-600"
                                            }`}
                                          >
                                            Replace ({conflict.newValue})
                                          </button>
                                        </>
                                      )}
                                    </div>
                                  </div>
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      );
                    }
                  )}
                </div>
              </div>

              <div className="flex justify-end gap-3 pt-4 border-t border-slate-700">
                <button
                  onClick={onClose}
                  className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleApply}
                  className="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-500 text-white rounded-lg transition-colors"
                >
                  Apply Selected
                </button>
              </div>
            </div>
          </div>
        );
      };

      const FileUploader = ({ onDataLoaded, hasExistingData }) => {
        const [loading, setLoading] = useState(false);
        const [importProgress, setImportProgress] = useState(0);
        const [error, setError] = useState(null);
        const folderInputRef = useRef(null);
        const fileInputRef = useRef(null);

        useEffect(() => {
          if (folderInputRef.current) {
            folderInputRef.current.setAttribute("webkitdirectory", "");
            folderInputRef.current.setAttribute("directory", "");
          }
        }, []);

        const handleFolderSelect = async (e) => {
          setLoading(true);
          setError(null);

          try {
            const files = Array.from(e.target.files);
            if (files.length === 0)
              throw new Error("No folder selected or folder is empty.");

            const dataFile = files.find(
              (f) =>
                f.name.toLowerCase() === "furniture_data.txt" ||
                f.name.toLowerCase().endsWith(".json")
            );
            if (!dataFile)
              throw new Error("Could not find 'furniture_data.txt'.");

            const urlMap = new Map();
            const fileMap = new Map();

            files.forEach((file) => {
              if (file.type.startsWith("image/")) {
                urlMap.set(file.name, URL.createObjectURL(file));
                fileMap.set(file.name, file);
              }
            });

            const text = await readFileAsText(dataFile);
            const { data: enrichedData, metadata } = parseAndEnrichData(text);

            // Await onDataLoaded to ensure it completes before returning
            const result = onDataLoaded(
              enrichedData,
              urlMap,
              metadata,
              fileMap
            );
            if (result && typeof result.then === "function") {
              await result;
            }
          } catch (err) {
            console.error(err);
            setError(err.message);
          } finally {
            setLoading(false);
          }
        };

        const readFileAsText = (file) => {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => resolve(event.target.result);
            reader.onerror = (error) => reject(error);
            reader.readAsText(file);
          });
        };

        const parseAndEnrichData = (rawText) => {
          let text = rawText.trim();
          if (text.endsWith(",") || text.endsWith(",]"))
            text = text.replace(/,(\s*\]?)$/, "$1");

          let json;
          try {
            json = JSON.parse(text);
          } catch (e) {
            try {
              json = JSON.parse(`[${text}]`);
            } catch (e2) {
              throw new Error(
                "Failed to parse JSON. Ensure the file contains a valid JSON array."
              );
            }
          }

          let dataArray;
          let metadata = null;

          const extractFromObject = (obj) => {
            if (
              obj &&
              typeof obj === "object" &&
              obj.data &&
              Array.isArray(obj.data)
            ) {
              return {
                data: obj.data,
                meta: {
                  timestamp: obj.timestamp,
                  Date: obj.Date,
                  username:
                    obj.username || obj.userName || obj.user_name || null,
                },
              };
            }
            return null;
          };

          let extracted = extractFromObject(json);

          if (!extracted && Array.isArray(json) && json.length === 1) {
            extracted = extractFromObject(json[0]);
          }

          if (extracted) {
            dataArray = extracted.data;
            metadata = extracted.meta;
          } else if (Array.isArray(json)) {
            dataArray = json;
          } else {
            throw new Error(
              "File content is not a valid JSON array or object with data property."
            );
          }

          const enrichedData = dataArray.map((item, idx) => ({
            type: item.type || item.id || `temp-${idx}`,
            id: item.id || `temp-${idx}`,
            ...item,
            name: item.name || "Unknown Item",
            image: item.image || "",
            quantity:
              item.count !== undefined ? item.count : item.quantity || 0,
            price: item.price !== undefined ? item.price : 0,
            rarity: item.rarity !== undefined ? item.rarity : 0,
          }));

          return { data: enrichedData, metadata };
        };

        const handleFileSelect = async (e) => {
          const file = e.target.files[0];
          if (!file) {
            e.target.value = "";
            return;
          }

          setLoading(true);
          setImportProgress(0);
          setError(null);

          try {
            if (file.name.toLowerCase().endsWith(".db")) {
              await importFromDatabase(file);
            } else {
              throw new Error("Please select a .db file.");
            }
          } catch (err) {
            console.error(err);
            setError(err.message);
          } finally {
            setLoading(false);
            setImportProgress(0);
            e.target.value = "";
          }
        };

        const importFromDatabase = async (dbFile) => {
          setImportProgress(5);
          let initSqlJs = window.initSqlJs;
          if (!initSqlJs) {
            await new Promise((resolve) => {
              let attempts = 0;
              const checkInterval = setInterval(() => {
                attempts++;
                if (window.initSqlJs) {
                  initSqlJs = window.initSqlJs;
                  clearInterval(checkInterval);
                  resolve();
                } else if (attempts > 50) {
                  clearInterval(checkInterval);
                  resolve();
                }
              }, 100);
            });
          }

          if (!initSqlJs) throw new Error("SQL.js library not loaded.");

          setImportProgress(10);
          const arrayBuffer = await dbFile.arrayBuffer();
          setImportProgress(20);
          const SQL = await initSqlJs({
            locateFile: (file) =>
              `https://cdn.jsdelivr.net/npm/sql.js@1.10.3/dist/${file}`,
          });
          const db = new SQL.Database(new Uint8Array(arrayBuffer));
          setImportProgress(30);

          // --- CHECK FOR FULL BACKUP (Multi-Inventory) ---
          // We check if the 'inventories' table exists in the file
          const tables = db.exec(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='inventories'"
          );
          setImportProgress(35);

          if (tables.length > 0) {
            // --- FULL RESTORE MODE ---

            try {
              console.log("Starting full restore...");
              setImportProgress(40);
              await clearIndexedDB(); // Wipe current state
              setImportProgress(50);
              const idb = await openDB();
              setImportProgress(55);

              // Helper to read SQL table and write to IndexedDB
              const restoreTable = async (sqlTable, idbStore, mapper) => {
                const res = db.exec(`SELECT * FROM ${sqlTable}`);
                if (res.length && res[0].values.length) {
                  const tx = idb.transaction(idbStore, "readwrite");
                  const store = tx.objectStore(idbStore);
                  const cols = res[0].columns;

                  res[0].values.forEach((row) => {
                    // Create object from row using column names
                    const obj = {};
                    cols.forEach((col, i) => (obj[col] = row[i]));
                    // Apply custom mapping if provided
                    const finalObj = mapper ? mapper(obj) : obj;
                    store.put(finalObj);
                  });
                  await new Promise((resolve) => (tx.oncomplete = resolve));
                }
              };

              // 1. Restore Inventories
              setImportProgress(60);
              await restoreTable("inventories", STORE_INVENTORIES);

              // 2. Restore Catalog
              setImportProgress(65);
              await restoreTable("catalog", STORE_ITEM_CATALOG);

              // 3. Restore Inventory Items
              setImportProgress(70);
              await restoreTable("inventory_items", STORE_INVENTORY_ITEMS);

              // 4. Restore Sublists (Parse itemTypes string back to array)
              setImportProgress(75);
              await restoreTable("sublists", STORE_SUBLISTS, (obj) => ({
                ...obj,
                itemTypes: JSON.parse(obj.itemTypes || "[]"),
              }));

              // 5. Restore Images
              setImportProgress(80);
              const imgRes = db.exec("SELECT * FROM images");
              if (imgRes.length && imgRes[0].values.length) {
                const tx = idb.transaction(STORE_IMAGES, "readwrite");
                const store = tx.objectStore(STORE_IMAGES);
                imgRes[0].values.forEach((row) => {
                  const filename = row[0];
                  const data = row[1]; // Uint8Array from SQL.js
                  const blob = new Blob([data], { type: "image/jpeg" });
                  store.put({ filename, blob });
                });
                await new Promise((resolve) => (tx.oncomplete = resolve));
                console.log("Restored images");
              }

              // 6. Restore Metadata
              setImportProgress(90);
              const metaRes = db.exec("SELECT * FROM metadata");
              if (metaRes.length) {
                const tx = idb.transaction(STORE_METADATA, "readwrite");
                metaRes[0].values.forEach((row) => {
                  tx.objectStore(STORE_METADATA).put({
                    key: row[0],
                    value: row[1],
                  });
                });
              }

              setImportProgress(100);
              db.close();

              window.location.reload(); // Reload to reflect full state change
              return;
            } catch (e) {
              console.error("Full restore failed:", e);
              alert("Restore failed: " + e.message);
              db.close();
              return;
            }
          }

          // --- LEGACY IMPORT MODE (Single Inventory) ---
          // Falls back to this if 'inventories' table is missing

          setImportProgress(40);
          const itemsResult = db.exec(
            "SELECT type, id, name, quantity, price, rarity, image, data FROM items"
          );
          if (!itemsResult || itemsResult.length === 0) {
            throw new Error("No items found in database.");
          }

          setImportProgress(50);
          const items = [];
          const rows = itemsResult[0].values;
          const columns = itemsResult[0].columns;

          for (const row of rows) {
            const item = {};
            columns.forEach((col, idx) => {
              if (col === "data" && row[idx]) {
                try {
                  const parsed = JSON.parse(row[idx]);
                  Object.assign(item, parsed);
                } catch (e) {
                  item[col] = row[idx];
                }
              } else {
                item[col] = row[idx];
              }
            });
            items.push(item);
          }

          setImportProgress(60);
          const imagesResult = db.exec("SELECT filename, data FROM images");
          const urlMap = new Map();
          const fileMap = new Map();

          if (imagesResult && imagesResult.length > 0) {
            const imageRows = imagesResult[0].values;
            const imageColumns = imagesResult[0].columns;
            const filenameIdx = imageColumns.indexOf("filename");
            const dataIdx = imageColumns.indexOf("data");

            for (const row of imageRows) {
              const filename = row[filenameIdx];
              const blobData = row[dataIdx];

              if (blobData) {
                try {
                  let dataArray;
                  if (blobData instanceof Uint8Array) {
                    dataArray = blobData;
                  } else if (Array.isArray(blobData)) {
                    dataArray = new Uint8Array(blobData);
                  } else {
                    dataArray = new Uint8Array(blobData);
                  }

                  const blob = new Blob([dataArray], { type: "image/jpeg" });
                  urlMap.set(filename, URL.createObjectURL(blob));
                  fileMap.set(filename, blob);
                } catch (err) {
                  console.warn(`Failed to load image ${filename}:`, err);
                }
              }
            }
          }

          setImportProgress(75);
          const metadataResult = db.exec(
            "SELECT value FROM metadata WHERE key = 'date'"
          );
          let metadata = null;
          if (
            metadataResult &&
            metadataResult.length > 0 &&
            metadataResult[0].values.length > 0
          ) {
            const dateValue = metadataResult[0].values[0][0];
            metadata = { Date: dateValue };
          }

          setImportProgress(85);
          db.close();

          const enrichedData = items.map((item, idx) => ({
            type: item.type || item.id || `temp-${idx}`,
            id: item.id || `temp-${idx}`,
            ...item,
            name: item.name || "Unknown Item",
            image: item.image || "",
            quantity: item.quantity || 0,
            price: item.price || 0,
            rarity: item.rarity !== undefined ? item.rarity : 0,
          }));

          setImportProgress(90);
          // Await onDataLoaded to ensure it completes before returning
          const result = onDataLoaded(enrichedData, urlMap, metadata, fileMap);
          if (result && typeof result.then === "function") {
            await result;
          }
          setImportProgress(100);
        };
        return (
          <div className="flex flex-col items-center justify-center h-full space-y-6 p-8 text-center bg-slate-950 text-slate-100 animate-in fade-in duration-700">
            <div className="bg-slate-900/50 p-10 rounded-2xl border border-slate-800 shadow-2xl max-w-4xl w-full backdrop-blur-sm">
              <h1 className="text-3xl font-bold mb-3 bg-gradient-to-r from-blue-400 to-indigo-400 bg-clip-text text-transparent">
                Import Inventory
              </h1>

              <p className="text-slate-400 mb-8 leading-relaxed">
                Choose how you want to import your inventory data.
              </p>

              {loading ? (
                <div className="flex flex-col items-center justify-center py-12 w-full">
                  <RefreshCw className="w-12 h-12 text-blue-500 animate-spin mb-4" />
                  <span className="text-slate-300 mb-4">
                    Processing Data...
                  </span>
                  <div className="w-full max-w-md">
                    <div className="w-full h-2 bg-slate-800 rounded-full overflow-hidden">
                      <div
                        className="h-full bg-blue-500 transition-all duration-300"
                        style={{ width: `${importProgress}%` }}
                      />
                    </div>
                    <p className="text-xs text-slate-500 mt-2 text-center">
                      {importProgress}%
                    </p>
                  </div>
                </div>
              ) : (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {/* Option 1: Upload New Folder */}
                  <label className="relative group flex flex-col items-center justify-center px-6 py-8 bg-slate-800 hover:bg-slate-700/80 border border-slate-700 hover:border-blue-500/50 rounded-xl cursor-pointer transition-all hover:scale-[1.02] active:scale-[0.98] shadow-lg">
                    <div className="bg-blue-500/10 p-4 rounded-full mb-4 group-hover:bg-blue-500/20 transition-colors">
                      <FolderOpen className="w-8 h-8 text-blue-400" />
                    </div>
                    <h3 className="text-lg font-semibold text-white mb-2">
                      Upload New Inventory
                    </h3>
                    <p className="text-sm text-slate-400 text-center leading-snug">
                      Select a folder containing extracted <br />{" "}
                      <code className="text-blue-300">furniture_data.txt</code>{" "}
                      and images.
                    </p>
                    <input
                      ref={folderInputRef}
                      type="file"
                      className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                      onChange={handleFolderSelect}
                      disabled={loading}
                    />
                  </label>

                  {/* Option 2: Import Existing File */}
                  <label className="relative group flex flex-col items-center justify-center px-6 py-8 bg-slate-800 hover:bg-slate-700/80 border border-slate-700 hover:border-emerald-500/50 rounded-xl cursor-pointer transition-all hover:scale-[1.02] active:scale-[0.98] shadow-lg">
                    <div className="bg-emerald-500/10 p-4 rounded-full mb-4 group-hover:bg-emerald-500/20 transition-colors">
                      <FileText className="w-8 h-8 text-emerald-400" />
                    </div>
                    <h3 className="text-lg font-semibold text-white mb-2">
                      Import Existing File
                    </h3>
                    <p className="text-sm text-slate-400 text-center leading-snug">
                      Import a standalone existing <br />{" "}
                      <code className="text-emerald-300">.db</code> file.
                    </p>
                    <input
                      ref={fileInputRef}
                      type="file"
                      accept=".db"
                      className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                      onChange={handleFileSelect}
                      disabled={loading}
                    />
                  </label>
                </div>
              )}

              {error && (
                <div className="mt-6 p-4 bg-red-950/30 border border-red-900/50 text-red-200 rounded-lg text-sm flex items-start gap-3 text-left animate-in slide-in-from-top-2">
                  <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5 text-red-400" />
                  <span>{error}</span>
                </div>
              )}
            </div>
          </div>
        );
      };

      const ItemRow = React.memo(
        ({
          item,
          index,
          style,
          imageMap,
          onUpdate,
          onReplaceImage,
          contextMenu,
          onContextMenuOpen,
          onContextMenuClose,
          onTransferItem,
          onAddToSublist,
          isSublist,
        }) => {
          const imageUrl = imageMap.get(item.image);
          const rarityStyle = RARITY_MAP[item.rarity] || RARITY_MAP[0];
          const isContextMenuOpen = contextMenu?.itemType === item.type;
          const fileInputRef = useRef(null);

          const handleContextMenu = (e) => {
            // Check if clicking directly on text divs in name area - allow browser context menu
            const target = e.target;
            const isTextDiv =
              target.tagName === "DIV" &&
              (target.classList.contains("font-medium") ||
                target.classList.contains("text-xs") ||
                target.closest(".font-medium") ||
                target.closest(".text-xs"));

            // If clicking on text divs in name area, allow browser menu for copy/paste
            if (isTextDiv) {
              return; // Don't prevent default - allow browser context menu
            }

            e.preventDefault();
            e.stopPropagation();
            // Position menu near cursor, but adjust if it would go off-screen
            const x = e.clientX;
            const y = e.clientY;
            onContextMenuOpen(item.type, { x, y });
          };

          const handleReplaceImage = () => {
            onContextMenuClose();
            fileInputRef.current?.click();
          };

          const handleFileChange = async (e) => {
            const file = e.target.files[0];
            if (!file || !file.type.startsWith("image/")) {
              alert("Please select a valid image file.");
              e.target.value = "";
              return;
            }

            if (onReplaceImage) {
              await onReplaceImage(item, file);
            }
            e.target.value = "";
          };
          console.log("@", isSublist);
          return (
            <>
              <div
                style={style}
                className="absolute w-full flex items-center border-b border-slate-800/50 hover:bg-slate-800/30 transition-colors px-4 group"
              >
                <div
                  className="w-12 text-slate-600 text-sm font-mono flex-shrink-0 self-stretch flex items-center"
                  onContextMenu={handleContextMenu}
                >
                  {index + 1}
                </div>

                <div
                  className="w-20 h-20 p-2 flex-shrink-0 self-stretch flex items-center"
                  onContextMenu={handleContextMenu}
                >
                  <div className="w-full h-full rounded-lg bg-slate-800/50 border border-slate-700/50 overflow-hidden relative">
                    {imageUrl ? (
                      <img
                        src={imageUrl}
                        alt={item.name}
                        className="w-full h-full object-contain hover:scale-110 transition-transform duration-300"
                        loading="lazy"
                      />
                    ) : (
                      <div className="w-full h-full flex flex-col items-center justify-center text-slate-600">
                        <ImageIcon className="w-5 h-5 opacity-40" />
                      </div>
                    )}
                  </div>
                </div>

                <div
                  className="flex-1 px-4 min-w-0 item-name-area self-stretch flex flex-col justify-center"
                  onContextMenu={handleContextMenu}
                >
                  <div
                    className="flex-1 px-4 min-w-0 item-name-area self-stretch flex flex-col justify-center"
                    onContextMenu={handleContextMenu}
                  >
                    {/* Added w-fit and max-w-full */}
                    <div
                      className="font-medium text-slate-200 truncate group-hover:text-blue-300 transition-colors w-fit max-w-full"
                      title={item.name}
                    >
                      {item.name}
                    </div>
                    {/* Added w-fit and max-w-full */}
                    <div
                      className="text-xs text-slate-500 font-mono truncate mt-0.5 w-fit max-w-full"
                      title={item.type || item.id}
                    >
                      {item.type || item.id}
                    </div>
                  </div>
                </div>

                {/* Quantity Column */}
                <div className="w-28 px-2">
                  <label className="text-[10px] text-slate-500 uppercase font-bold tracking-wider mb-1 block">
                    Qty
                  </label>
                  {isSublist ? (
                    <div className="w-full px-2 py-1.5 text-sm text-right text-slate-400 font-medium">
                      {item.quantity}
                    </div>
                  ) : (
                    <input
                      type="number"
                      className="w-full bg-slate-900 border border-slate-700 rounded px-2 py-1.5 text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500/50 focus:outline-none text-right text-slate-200 transition-all"
                      value={item.quantity}
                      min="0"
                      onChange={(e) =>
                        onUpdate(
                          item.actualIndex,
                          "quantity",
                          parseInt(e.target.value) || 0
                        )
                      }
                      onBlur={(e) =>
                        onUpdate(
                          item.actualIndex,
                          "quantity",
                          parseInt(e.target.value) || 0,
                          true
                        )
                      }
                    />
                  )}
                </div>

                <div className="w-32 px-2">
                  <label className="text-[10px] text-slate-500 uppercase font-bold tracking-wider mb-1 block">
                    Price
                  </label>
                  {isSublist ? (
                    <div className="w-full px-2 py-1.5 text-sm text-right text-slate-400 font-medium">
                      <span className="text-slate-600 mr-1">$</span>
                      {item.price}
                    </div>
                  ) : (
                    <div className="relative">
                      <span className="absolute left-2 top-1.5 text-slate-500 text-sm">
                        $
                      </span>
                      <input
                        type="number"
                        className="w-full bg-slate-900 border border-slate-700 rounded pl-5 pr-2 py-1.5 text-sm focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500/50 focus:outline-none text-right text-slate-200 transition-all"
                        value={item.price}
                        placeholder="0"
                        min="0"
                        onChange={(e) =>
                          onUpdate(
                            item.actualIndex,
                            "price",
                            parseFloat(e.target.value) || 0
                          )
                        }
                        onBlur={(e) =>
                          onUpdate(
                            item.actualIndex,
                            "price",
                            parseFloat(e.target.value) || 0,
                            true
                          )
                        }
                      />
                    </div>
                  )}
                </div>

                <div className="w-36 px-2">
                  <label className="text-[10px] text-slate-500 uppercase font-bold tracking-wider mb-1 block">
                    Rarity
                  </label>
                  {isSublist ? (
                    <div
                      className={`w-full border border-transparent rounded px-2 py-1.5 text-xs font-medium text-center ${
                        rarityStyle.color
                      } ${rarityStyle.bg || "bg-slate-900"}`}
                    >
                      {RARITY_MAP[item.rarity]?.label || "Common"}
                    </div>
                  ) : (
                    <select
                      className={`w-full border rounded px-2 py-1.5 text-xs font-medium focus:outline-none appearance-none cursor-pointer transition-all ${
                        rarityStyle.color
                      } ${rarityStyle.bg || "bg-slate-900"}`}
                      value={item.rarity}
                      onChange={(e) =>
                        onUpdate(
                          item.actualIndex,
                          "rarity",
                          parseInt(e.target.value),
                          true
                        )
                      }
                    >
                      {Object.entries(RARITY_MAP).map(([val, config]) => (
                        <option
                          key={val}
                          value={val}
                          className="bg-slate-800 text-slate-200"
                        >
                          {config.label}
                        </option>
                      ))}
                    </select>
                  )}
                </div>
              </div>
              {isContextMenuOpen && (
                <div
                  className="fixed z-[100] bg-slate-800 border border-slate-700 rounded-lg shadow-xl py-1 min-w-[180px] max-w-[280px] context-menu-container"
                  style={{
                    left: `${Math.min(
                      contextMenu.position.x,
                      window.innerWidth - 200
                    )}px`,
                    top: `${Math.min(
                      contextMenu.position.y,
                      window.innerHeight - 100
                    )}px`,
                  }}
                  onClick={(e) => e.stopPropagation()}
                  onContextMenu={(e) => e.preventDefault()}
                >
                  <div className="px-4 py-2 border-b border-slate-700">
                    <div
                      className="text-xs font-medium text-slate-400 truncate"
                      title={item.name}
                    >
                      {item.name}
                    </div>
                  </div>
                  {onTransferItem && (
                    <button
                      onClick={() => {
                        onContextMenuClose();
                        onTransferItem(item);
                      }}
                      className="w-full text-left px-4 py-2 text-sm text-slate-300 hover:bg-slate-700 transition-colors flex items-center gap-2"
                    >
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="16"
                        height="16"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                        <polyline points="7 10 12 15 17 10" />
                        <line x1="12" x2="12" y1="15" y2="3" />
                      </svg>
                      Transfer to...
                    </button>
                  )}
                  {onAddToSublist && (
                    <button
                      onClick={() => {
                        onContextMenuClose();
                        onAddToSublist(item);
                      }}
                      className="w-full text-left px-4 py-2 text-sm text-slate-300 hover:bg-slate-700 transition-colors flex items-center gap-2"
                    >
                      <List className="w-4 h-4" />
                      Add to sublist
                    </button>
                  )}
                  <button
                    onClick={handleReplaceImage}
                    className="w-full text-left px-4 py-2 text-sm text-slate-300 hover:bg-slate-700 transition-colors flex items-center gap-2"
                  >
                    <ImageIcon className="w-4 h-4" />
                    Replace Image
                  </button>
                </div>
              )}
              <input
                ref={fileInputRef}
                type="file"
                accept="image/*"
                className="hidden"
                onChange={handleFileChange}
              />
            </>
          );
        }
      );

      const VirtualList = ({
        items,
        imageMap,
        onUpdateItem,
        onReplaceImage,
        onTransferItem,
        onAddToSublist,
        isSublist,
      }) => {
        const containerRef = useRef(null);
        const [scrollTop, setScrollTop] = useState(0);
        const [containerHeight, setContainerHeight] = useState(0);
        const [contextMenu, setContextMenu] = useState(null);
        const savedScrollPositionRef = useRef(0);
        const previousItemsRef = useRef(items);

        useEffect(() => {
          if (!containerRef.current) return;
          const resizeObserver = new ResizeObserver((entries) => {
            for (let entry of entries) {
              setContainerHeight(entry.contentRect.height);
            }
          });
          resizeObserver.observe(containerRef.current);
          return () => resizeObserver.disconnect();
        }, []);

        useEffect(() => {
          const handleClickOutside = (e) => {
            if (contextMenu && !e.target.closest(".context-menu-container")) {
              setContextMenu(null);
            }
          };
          document.addEventListener("click", handleClickOutside);
          document.addEventListener("contextmenu", handleClickOutside);
          return () => {
            document.removeEventListener("click", handleClickOutside);
            document.removeEventListener("contextmenu", handleClickOutside);
          };
        }, [contextMenu]);

        const handleContextMenuOpen = (itemType, position) => {
          setContextMenu({ itemType, position });
        };

        const handleContextMenuClose = () => {
          setContextMenu(null);
        };

        const handleScroll = (e) => {
          const currentScrollTop = e.target.scrollTop;
          setScrollTop(currentScrollTop);
          savedScrollPositionRef.current = currentScrollTop;
        };

        // Save scroll position before items change
        useEffect(() => {
          if (containerRef.current) {
            savedScrollPositionRef.current = containerRef.current.scrollTop;
          }
          previousItemsRef.current = items;
        }, [items]);

        // Restore scroll position after items update (only if items actually changed)
        useEffect(() => {
          // Check if items actually changed (not just a re-render)
          const itemsChanged =
            previousItemsRef.current !== items &&
            (previousItemsRef.current?.length !== items?.length ||
              previousItemsRef.current?.some(
                (item, idx) => item?.type !== items?.[idx]?.type
              ));

          if (
            itemsChanged &&
            containerRef.current &&
            savedScrollPositionRef.current > 0
          ) {
            // Use double requestAnimationFrame to ensure DOM has fully updated
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                if (containerRef.current) {
                  containerRef.current.scrollTop =
                    savedScrollPositionRef.current;
                }
              });
            });
          }
        }, [items]);

        const totalHeight = items.length * ROW_HEIGHT;
        const startIndex = Math.max(
          0,
          Math.floor(scrollTop / ROW_HEIGHT) - BUFFER_ITEMS
        );
        const endIndex = Math.min(
          items.length - 1,
          Math.floor((scrollTop + containerHeight) / ROW_HEIGHT) + BUFFER_ITEMS
        );

        const visibleItems = useMemo(() => {
          const rows = [];
          for (let i = startIndex; i <= endIndex; i++) {
            const item = items[i];
            rows.push(
              <ItemRow
                // Use TYPE as key
                key={item.type || i}
                index={i}
                item={item}
                style={{ top: i * ROW_HEIGHT, height: ROW_HEIGHT }}
                imageMap={imageMap}
                onUpdate={onUpdateItem}
                onReplaceImage={onReplaceImage}
                contextMenu={contextMenu}
                onContextMenuOpen={handleContextMenuOpen}
                onContextMenuClose={handleContextMenuClose}
                onTransferItem={onTransferItem}
                onAddToSublist={onAddToSublist}
                isSublist={isSublist}
              />
            );
          }
          return rows;
        }, [
          startIndex,
          endIndex,
          items,
          imageMap,
          onUpdateItem,
          onReplaceImage,
          contextMenu,
          onAddToSublist,
          isSublist,
        ]);

        return (
          <div
            ref={containerRef}
            className="flex-1 overflow-y-auto relative bg-slate-950 scroll-smooth virtual-scroller"
            onScroll={handleScroll}
          >
            <div
              style={{
                height: totalHeight,
                position: "relative",
                width: "100%",
              }}
            >
              {items.length > 0 ? (
                visibleItems
              ) : (
                <div className="absolute inset-0 flex flex-col items-center justify-center text-slate-500 opacity-60">
                  <Search className="w-12 h-12 mb-2" />
                  <span className="text-lg">No matching items found</span>
                </div>
              )}
            </div>
          </div>
        );
      };

      const App = () => {
        // Data & State
        const [data, setData] = useState(null);
        const [imageMap, setImageMap] = useState(null);
        const [extractionDate, setExtractionDate] = useState(null);
        const [isLoadingFromDB, setIsLoadingFromDB] = useState(true);
        const [hasStoredData, setHasStoredData] = useState(false);

        // Multi-Inventory State
        const [inventories, setInventories] = useState([]); // All inventories
        const [openInventoryIds, setOpenInventoryIds] = useState([]); // IDs of open tabs
        const [activeInventoryId, setActiveInventoryId] = useState(null); // Currently active inventory
        const [inventoryItemCounts, setInventoryItemCounts] = useState(
          new Map()
        ); // Item counts per inventory
        const [username, setUsername] = useState(null); // Username from inventory_data.txt
        const [openTabMenuId, setOpenTabMenuId] = useState(null); // ID of tab with open context menu
        const [menuPosition, setMenuPosition] = useState({
          bottom: 0,
          left: 0,
        }); // Position for context menu
        const [showAddButtonMenu, setShowAddButtonMenu] = useState(false); // Whether tab bar add button menu is open
        const [addButtonMenuPosition, setAddButtonMenuPosition] = useState({
          top: 0,
          left: 0,
        }); // Position for tab bar add button context menu
        const [showSearchBarMenu, setShowSearchBarMenu] = useState(false); // Whether search bar add button menu is open
        const [searchBarMenuPosition, setSearchBarMenuPosition] = useState({
          top: 0,
          left: 0,
        }); // Position for search bar add button context menu

        // Split View State
        const [isSplitView, setIsSplitView] = useState(false);
        const [leftPanelInventoryId, setLeftPanelInventoryId] = useState(null);
        const [rightPanelInventoryId, setRightPanelInventoryId] =
          useState(null);
        const [leftPanelData, setLeftPanelData] = useState(null);
        const [rightPanelData, setRightPanelData] = useState(null);
        const [leftPanelSearchQuery, setLeftPanelSearchQuery] = useState("");
        const [rightPanelSearchQuery, setRightPanelSearchQuery] = useState("");
        const [leftPanelSublists, setLeftPanelSublists] = useState([]);
        const [rightPanelSublists, setRightPanelSublists] = useState([]);
        const [leftPanelSelectedSublistId, setLeftPanelSelectedSublistId] =
          useState(null);
        const [rightPanelSelectedSublistId, setRightPanelSelectedSublistId] =
          useState(null);

        // AI State
        const [pipeline, setPipeline] = useState(null);
        const [embeddings, setEmbeddings] = useState(null);
        const [indexingProgress, setIndexingProgress] = useState(0);
        const [isAIReady, setIsAIReady] = useState(false);

        // Search State
        const [searchQuery, setSearchQuery] = useState("");
        const [searchResults, setSearchResults] = useState(null);
        const [isSearching, setIsSearching] = useState(false);

        // Filter State
        const [showFilterModal, setShowFilterModal] = useState(false);
        const [filterModalPanel, setFilterModalPanel] = useState(null); // "single", "left", "right"
        const [filters, setFilters] = useState({
          rarities: [], // Array of selected rarity values [0, 1, 2]
          quantityMin: null,
          quantityMax: null,
          quantityMode: "all", // "all", "inStock", "outOfStock"
          priceMin: null,
          priceMax: null,
          hasPrice: null, // null, true, false
        });
        const [leftPanelFilters, setLeftPanelFilters] = useState({
          rarities: [],
          quantityMin: null,
          quantityMax: null,
          quantityMode: "all",
          priceMin: null,
          priceMax: null,
          hasPrice: null,
        });
        const [rightPanelFilters, setRightPanelFilters] = useState({
          rarities: [],
          quantityMin: null,
          quantityMax: null,
          quantityMode: "all",
          priceMin: null,
          priceMax: null,
          hasPrice: null,
        });

        // Buy Me a Coffee Modal State
        const [showBuyMeACoffeeModal, setShowBuyMeACoffeeModal] = useState(false);

        // Modal State
        const [showFirstClearModal, setShowFirstClearModal] = useState(false);
        const [showSecondClearModal, setShowSecondClearModal] = useState(false);
        const [showExportFormatModal, setShowExportFormatModal] =
          useState(false);
        const [showUpdateConfirmModal, setShowUpdateConfirmModal] =
          useState(false);
        const [pendingUpdateData, setPendingUpdateData] = useState(null);
        const [showConflictsModal, setShowConflictsModal] = useState(false);
        const [conflictsData, setConflictsData] = useState(null);
        const [showSaveToDesktopModal, setShowSaveToDesktopModal] =
          useState(false);
        const [isExporting, setIsExporting] = useState(false);
        const [showNewInventoryModal, setShowNewInventoryModal] =
          useState(false);
        const [showOpenInventoryModal, setShowOpenInventoryModal] =
          useState(false);
        const [showExportInventoryModal, setShowExportInventoryModal] =
          useState(false);
        const [pendingExportInventoryId, setPendingExportInventoryId] =
          useState(null);
        const [pendingExportTabInventoryId, setPendingExportTabInventoryId] =
          useState(null);
        const [hasSublistSelected, setHasSublistSelected] = useState(false);
        const [pendingExportSublistId, setPendingExportSublistId] =
          useState(null);
        const [
          pendingExportParentInventoryId,
          setPendingExportParentInventoryId,
        ] = useState(null);
        const [exportMetadataOptions, setExportMetadataOptions] = useState({
          images: true,
          quantity: true,
          rarity: true,
          prices: true,
        });
        const [showSettingsMenu, setShowSettingsMenu] = useState(false);
        const [showTransferModal, setShowTransferModal] = useState(false);
        const [transferItem, setTransferItem] = useState(null);

        // Sublist State
        const [sublists, setSublists] = useState([]); // All sublists for current inventory
        const [selectedSublistId, setSelectedSublistId] = useState(null); // null = Main List
        const [showNewSublistModal, setShowNewSublistModal] = useState(false);
        const [showAddToSublistModal, setShowAddToSublistModal] =
          useState(false);
        const [itemToAddToSublist, setItemToAddToSublist] = useState(null);

        // File input ref for update inventory
        const updateInventoryInputRef = useRef(null);
        // Directory input ref for importing data
        const importDataInputRef = useRef(null);

        // 0. Load from IndexedDB on mount - Multi-inventory system
        useEffect(() => {
          const loadData = async () => {
            try {
              // Load username from localStorage
              const savedUsername = localStorage.getItem("inventory_username");
              if (savedUsername) {
                setUsername(savedUsername);
              }

              // Load all inventories
              const loadedInventories = await loadInventories();
              setInventories(loadedInventories);

              if (loadedInventories.length > 0) {
                // Load saved open tabs
                const {
                  openInventoryIds: savedOpenIds,
                  activeInventoryId: savedActiveId,
                } = await loadOpenTabsFromIndexedDB();

                // Validate saved tabs exist in loaded inventories
                const validOpenIds = savedOpenIds.filter((id) =>
                  loadedInventories.some((inv) => inv.id === id)
                );
                const validActiveId =
                  savedActiveId &&
                  loadedInventories.some((inv) => inv.id === savedActiveId)
                    ? savedActiveId
                    : null;

                // Use saved tabs if valid, otherwise fallback to first inventory
                let targetInventoryId;
                let targetOpenIds;

                if (validOpenIds.length > 0) {
                  targetOpenIds = validOpenIds;
                  targetInventoryId = validActiveId || validOpenIds[0];
                } else {
                  // Fallback to first inventory
                  const firstInventory = loadedInventories[0];
                  targetOpenIds = [firstInventory.id];
                  targetInventoryId = firstInventory.id;
                }

                // Set active and open tabs
                setActiveInventoryId(targetInventoryId);
                setOpenInventoryIds(targetOpenIds);

                // Load items for active inventory
                const items = await loadInventoryItems(targetInventoryId);
                if (items && items.length > 0) {
                  const indexedData = items.map((d, i) => ({
                    ...d,
                    actualIndex: i,
                  }));
                  setData(indexedData);
                  setHasStoredData(true);
                } else {
                  setData([]);
                  setHasStoredData(false);
                }

                // Load sublists for active inventory
                const loadedSublists = await loadSublists(targetInventoryId);
                setSublists(loadedSublists);
                setSelectedSublistId(null);

                // Load images (shared)
                const loadedImageMap = await getImagesFromIndexedDB();
                const imageMap = new Map();
                for (const [filename, blob] of loadedImageMap.entries()) {
                  imageMap.set(filename, URL.createObjectURL(blob));
                }
                setImageMap(imageMap);

                // Load embeddings (shared)
                const embeddingsMap = await loadEmbeddingsFromIndexedDB();
                if (embeddingsMap && embeddingsMap.size > 0 && items) {
                  const embeddingsArray = items.map(
                    (item) => embeddingsMap.get(item.type) || null
                  );
                  if (embeddingsArray.some((e) => e !== null)) {
                    setEmbeddings(embeddingsArray);
                  }
                }
              } else {
                setHasStoredData(false);
                setData([]);
              }
            } catch (e) {
              console.error("Error loading from IndexedDB:", e);
              setHasStoredData(false);
              setData([]);
            } finally {
              setIsLoadingFromDB(false);
            }
          };
          loadData();
        }, []);

        // Load item counts for all inventories
        useEffect(() => {
          if (inventories.length === 0) return;

          const loadCounts = async () => {
            const countsMap = new Map();
            for (const inv of inventories) {
              const count = await getInventoryItemCount(inv.id);
              countsMap.set(inv.id, count);
            }
            setInventoryItemCounts(countsMap);
          };

          loadCounts();
        }, [inventories, data]); // Recalculate when inventories or data changes

        // Save open tabs to IndexedDB whenever they change
        useEffect(() => {
          // Skip saving during initial load
          if (isLoadingFromDB) return;

          // Only save if we have inventories loaded
          if (
            inventories.length > 0 &&
            (openInventoryIds.length > 0 || activeInventoryId)
          ) {
            saveOpenTabsToIndexedDB(openInventoryIds, activeInventoryId);
          }
        }, [
          openInventoryIds,
          activeInventoryId,
          inventories.length,
          isLoadingFromDB,
        ]);

        // 1. Initialize Transformers Pipeline
        useEffect(() => {
          const initAI = async () => {
            if (!window.pipeline) return;

            try {
              const pipe = await window.pipeline(
                "feature-extraction",
                "Xenova/all-MiniLM-L6-v2",
                {
                  quantized: true,
                }
              );
              setPipeline(() => pipe);
              setIsAIReady(true);
            } catch (e) {
              console.error("AI Model Init Failed:", e);
            }
          };

          const checkInterval = setInterval(() => {
            if (window.pipeline) {
              clearInterval(checkInterval);
              initAI();
            }
          }, 100);

          return () => clearInterval(checkInterval);
        }, []);

        // 2. Index Data when Loaded - Only generate missing embeddings
        useEffect(() => {
          if (!data || !pipeline) return;

          const generateEmbeddings = async () => {
            // Load existing embeddings from DB
            const existingEmbeddingsMap = await loadEmbeddingsFromIndexedDB();

            // Determine which items need embeddings
            const itemsNeedingEmbeddings = [];
            const itemsNeedingRegeneration = [];
            const vectors = [];

            // Check each item
            for (let i = 0; i < data.length; i++) {
              const item = data[i];
              // Use TYPE to look up embedding
              const existingEmbedding = existingEmbeddingsMap.get(item.type);

              if (!existingEmbedding) {
                // Missing embedding - need to generate
                itemsNeedingEmbeddings.push({ index: i, item });
                vectors.push(null); // placeholder
              } else {
                // Check if name changed (need to regenerate)
                const existingItem = data.find((d) => d.type === item.type);
                // We'll check by comparing with stored item name if we have it
                // For now, assume if embedding exists and item exists, it's valid
                vectors.push(existingEmbedding);
              }
            }

            // Also check for name changes by loading existing items from DB
            const db = await openDB();
            const tx = db.transaction([STORE_ITEMS], "readonly");
            const itemsStore = tx.objectStore(STORE_ITEMS);
            const existingItems = await new Promise((resolve, reject) => {
              const req = itemsStore.getAll();
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
            });

            // Use TYPE for map key
            const existingItemsMap = new Map(
              existingItems.map((item) => [item.type, item])
            );

            // Re-check for name changes
            for (let i = 0; i < data.length; i++) {
              const item = data[i];
              const existingItem = existingItemsMap.get(item.type);
              const existingEmbedding = existingEmbeddingsMap.get(item.type);

              if (
                existingItem &&
                existingEmbedding &&
                existingItem.name !== item.name
              ) {
                // Name changed - need to regenerate
                itemsNeedingRegeneration.push({ index: i, item });
                vectors[i] = null; // mark for regeneration
              }
            }

            const totalNeedingGeneration =
              itemsNeedingEmbeddings.length + itemsNeedingRegeneration.length;

            if (totalNeedingGeneration === 0) {
              // All embeddings exist and are up to date
              setEmbeddings(vectors);
              setIndexingProgress(100);
              return;
            }

            setIndexingProgress(0);

            // Generate embeddings for items that need them
            const itemsToProcess = [
              ...itemsNeedingEmbeddings,
              ...itemsNeedingRegeneration,
            ];
            const embeddingsToSave = new Map();

            const CHUNK_SIZE = 10;
            for (let i = 0; i < itemsToProcess.length; i += CHUNK_SIZE) {
              const chunk = itemsToProcess.slice(i, i + CHUNK_SIZE);
              const promises = chunk.map(async ({ index, item }) => {
                const output = await pipeline(`Furniture item: ${item.name}`, {
                  pooling: "mean",
                  normalize: true,
                });
                // Return item.type as identifier
                return {
                  index,
                  itemType: item.type,
                  vector: Array.from(output.data),
                };
              });

              const results = await Promise.all(promises);
              for (const { index, itemType, vector } of results) {
                vectors[index] = vector;
                embeddingsToSave.set(itemType, vector);
              }

              setIndexingProgress(
                Math.round(((i + CHUNK_SIZE) / itemsToProcess.length) * 100)
              );

              // Save incrementally
              if (embeddingsToSave.size >= CHUNK_SIZE) {
                await saveEmbeddingsToIndexedDB(embeddingsToSave);
                embeddingsToSave.clear();
              }

              await new Promise((r) => setTimeout(r, 0));
            }

            // Save any remaining embeddings
            if (embeddingsToSave.size > 0) {
              await saveEmbeddingsToIndexedDB(embeddingsToSave);
            }

            setEmbeddings(vectors);
            setIndexingProgress(100);
          };

          generateEmbeddings();
        }, [data, pipeline]);

        // 3. Search Logic
        useEffect(() => {
          if (!searchQuery.trim()) {
            setSearchResults(null);
            return;
          }

          if (!embeddings || !pipeline) {
            const lowerQuery = searchQuery.toLowerCase();
            const filtered = data.filter(
              (item) =>
                item.name.toLowerCase().includes(lowerQuery) ||
                (item.type && item.type.toLowerCase().includes(lowerQuery))
            );
            setSearchResults(filtered);
            return;
          }

          const runSearch = async () => {
            setIsSearching(true);

            const queryOutput = await pipeline(
              `Furniture item: ${searchQuery}`,
              { pooling: "mean", normalize: true }
            );
            const queryVector = queryOutput.data;

            const lowerQuery = searchQuery.toLowerCase();

            const scoredItems = data.map((item, index) => {
              let score = cosineSimilarity(queryVector, embeddings[index]);

              if (item.name.toLowerCase().includes(lowerQuery)) {
                score += 1.0;
              }

              return { ...item, score, actualIndex: index };
            });

            scoredItems.sort((a, b) => b.score - a.score);
            const filtered = scoredItems.filter((item) => item.score > 0.25);

            setSearchResults(filtered);
            setIsSearching(false);
          };

          const timeoutId = setTimeout(runSearch, 300);
          return () => clearTimeout(timeoutId);
        }, [searchQuery, embeddings, pipeline, data]);

        // Close context menu when clicking outside
        useEffect(() => {
          const handleClickOutside = (event) => {
            // Don't close if clicking on the menu button or the menu itself
            if (
              openTabMenuId !== null &&
              !event.target.closest(".tab-menu-button") &&
              !event.target.closest(".tab-context-menu")
            ) {
              setOpenTabMenuId(null);
            }
            if (
              showAddButtonMenu &&
              !event.target.closest(".add-button-menu") &&
              !event.target.closest(".add-button-menu-button")
            ) {
              setShowAddButtonMenu(false);
            }
            if (
              showSearchBarMenu &&
              !event.target.closest(".add-button-menu") &&
              !event.target.closest(".add-button-menu-button")
            ) {
              setShowSearchBarMenu(false);
            }
          };
          if (
            openTabMenuId !== null ||
            showAddButtonMenu ||
            showSearchBarMenu
          ) {
            // Use setTimeout to avoid immediate closure when opening
            setTimeout(() => {
              document.addEventListener("click", handleClickOutside);
            }, 0);
            return () => {
              document.removeEventListener("click", handleClickOutside);
            };
          }
        }, [openTabMenuId, showAddButtonMenu, showSearchBarMenu]);

        // Show Buy Me a Coffee modal once per day when inventory is loaded
        useEffect(() => {
          // Only show if inventory is fully loaded
          if (
            !isLoadingFromDB &&
            hasStoredData &&
            inventories.length > 0 &&
            data &&
            data.length > 0
          ) {
            // Check if modal was dismissed today
            const lastDismissedDate = localStorage.getItem(
              "buyMeACoffeeModalDismissedDate"
            );
            const today = new Date().toDateString();

            // Show modal if it hasn't been dismissed today
            if (lastDismissedDate !== today) {
              // Small delay to ensure UI is ready
              const timer = setTimeout(() => {
                setShowBuyMeACoffeeModal(true);
              }, 1000);
              return () => clearTimeout(timer);
            }
          }
        }, [
          isLoadingFromDB,
          hasStoredData,
          inventories.length,
          data,
        ]);

        // Handlers
        const handleDataLoaded = async (
          loadedData,
          loadedUrlMap,
          metadata,
          loadedFileMap
        ) => {
          try {
            // If no active inventory, create one or use existing
            let targetInventoryId = activeInventoryId;
            let isFirstTime = false;

            if (!targetInventoryId) {
              // Check if any inventories exist
              const allInventories = await loadInventories();
              if (allInventories.length > 0) {
                // Use first inventory
                targetInventoryId = allInventories[0].id;
                setActiveInventoryId(targetInventoryId);
                if (!openInventoryIds.includes(targetInventoryId)) {
                  setOpenInventoryIds([targetInventoryId]);
                }
              } else {
                // Create new inventory - this is first time loading
                isFirstTime = true;
                const newInventory = await createInventory("All items");
                targetInventoryId = newInventory.id;
                const updatedInventories = await loadInventories();
                setInventories(updatedInventories);
                setActiveInventoryId(targetInventoryId);
                setOpenInventoryIds([targetInventoryId]);
              }
            }

            // Save username if this is first time loading and username exists in metadata
            if (isFirstTime && metadata && metadata.username) {
              localStorage.setItem("inventory_username", metadata.username);
              setUsername(metadata.username);
            }

            // Load existing items for current inventory
            const existingItems = await loadInventoryItems(targetInventoryId);

            // Load existing images
            const existingImageBlobs = await getImagesFromIndexedDB();
            const existingImageMap = new Map();
            for (const [filename, blob] of existingImageBlobs.entries()) {
              existingImageMap.set(filename, URL.createObjectURL(blob));
            }

            // Create maps for efficient lookup using TYPE
            const existingItemsMap = new Map(
              existingItems.map((item) => [item.type, item])
            );
            const existingImageFilenames = new Set(existingImageBlobs.keys());

            // Build merged data: existing items + new items
            const mergedItems = [];
            const processedItemTypes = new Set(); // Track which items we've already processed
            const newImageFileMap = new Map();
            const itemsNeedingEmbeddings = [];

            // Process new items
            for (const newItem of loadedData) {
              // Ensure we have a valid TYPE
              if (!newItem.type) {
                console.warn("Skipping item without Type:", newItem);
                continue;
              }

              const existingItem = existingItemsMap.get(newItem.type);

              if (existingItem) {
                // Item exists - check if name changed (need to regenerate embedding)
                if (existingItem.name !== newItem.name) {
                  itemsNeedingEmbeddings.push(newItem);
                }
                // Merge: preserve existing item's data, update with new data (especially quantity)
                const mergedItem = {
                  ...existingItem,
                  ...newItem,
                  type: existingItem.type, // Explicitly preserve existing TYPE
                  price:
                    existingItem.price !== undefined
                      ? existingItem.price
                      : newItem.price || 0,
                  rarity:
                    existingItem.rarity !== undefined
                      ? existingItem.rarity
                      : newItem.rarity || 0,
                  image: existingItem.image || newItem.image || "",
                };
                mergedItems.push(mergedItem);
                processedItemTypes.add(existingItem.type);
              } else {
                // New item - add it
                mergedItems.push(newItem);
                itemsNeedingEmbeddings.push(newItem);
                processedItemTypes.add(newItem.type);

                // Check if this item's image is new (match by item.image property = filename)
                if (
                  newItem.image &&
                  !existingImageFilenames.has(newItem.image)
                ) {
                  // Find the image file that matches this item's image property
                  const imageFile = loadedFileMap.get(newItem.image);
                  if (imageFile) {
                    newImageFileMap.set(newItem.image, imageFile);
                  }
                }
              }
            }

            // Also keep existing items that weren't in the new upload
            for (const existingItem of existingItems) {
              if (!processedItemTypes.has(existingItem.type)) {
                mergedItems.push(existingItem);
              }
            }

            // Add new images that don't match existing items (by item.image property)
            for (const [filename, file] of loadedFileMap.entries()) {
              if (!existingImageFilenames.has(filename)) {
                // Check if any new item uses this image (by matching item.image to filename)
                const itemUsingImage = loadedData.find(
                  (item) => item.image === filename
                );
                if (
                  itemUsingImage &&
                  !existingItemsMap.has(itemUsingImage.type)
                ) {
                  newImageFileMap.set(filename, file);
                }
              }
            }

            // Index the merged data
            const indexedData = mergedItems.map((d, i) => ({
              ...d,
              actualIndex: i,
            }));

            // Build merged image map
            const mergedImageMap = new Map(existingImageMap);
            for (const [filename, url] of loadedUrlMap.entries()) {
              if (!mergedImageMap.has(filename)) {
                mergedImageMap.set(filename, url);
              }
            }
            // Also add new images from fileMap
            for (const [filename, file] of newImageFileMap.entries()) {
              if (!mergedImageMap.has(filename)) {
                mergedImageMap.set(filename, URL.createObjectURL(file));
              }
            }

            // Revoke old blob URLs if needed
            if (imageMap) {
              imageMap.forEach((url) => {
                if (
                  url.startsWith("blob:") &&
                  !Array.from(mergedImageMap.values()).includes(url)
                ) {
                  URL.revokeObjectURL(url);
                }
              });
            }

            setData(indexedData);
            setImageMap(mergedImageMap);
            setHasStoredData(true);

            // Clear embeddings to trigger regeneration for new/changed items
            setEmbeddings(null);

            if (metadata && metadata.Date) {
              setExtractionDate(metadata.Date);
            } else {
              setExtractionDate(null);
            }

            // STEP 1: Save only new images
            if (newImageFileMap.size > 0) {
              await saveImagesToIndexedDB(newImageFileMap, existingImageMap);
            }

            // STEP 2: Save merged data to current inventory
            await saveItemsToInventory(targetInventoryId, indexedData);

            // Reload items to get updated data
            const updatedItems = await loadInventoryItems(targetInventoryId);
            if (updatedItems && updatedItems.length > 0) {
              const indexedDataUpdated = updatedItems.map((d, i) => ({
                ...d,
                actualIndex: i,
              }));
              setData(indexedDataUpdated);
            }

            console.log(
              `Merged ${mergedItems.length} items (${itemsNeedingEmbeddings.length} new/changed). Saved ${newImageFileMap.size} new images.`
            );
          } catch (e) {
            console.error("Error saving to IndexedDB:", e);
            alert(
              `Error saving to storage: ${e.message}\n\nYour data is loaded but may not persist after closing the browser.`
            );
          }
        };

        const saveItemToDB = async (item, field, inventoryId) => {
          if (!inventoryId) {
            console.error("No inventory ID available for saving item");
            return;
          }

          try {
            const db = await openDB();

            // Fields that go to STORE_INVENTORY_ITEMS (per-inventory data)
            const inventoryFields = ["quantity", "price"];
            // Fields that go to STORE_ITEM_CATALOG (shared data)
            const catalogFields = ["rarity", "name", "image"];

            // Save to inventory items store if quantity or price changed
            if (field && inventoryFields.includes(field)) {
              const invTx = db.transaction(
                [STORE_INVENTORY_ITEMS],
                "readwrite"
              );
              const invStore = invTx.objectStore(STORE_INVENTORY_ITEMS);
              const invIndex = invStore.index("inventoryId");

              // Find existing item by inventoryId and type
              const existingItems = await new Promise((resolve, reject) => {
                const req = invIndex.getAll(inventoryId);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
              });

              const existingItem = existingItems.find(
                (i) => i.type === item.type
              );
              const inventoryItem = {
                inventoryId: inventoryId,
                type: item.type,
                quantity: item.quantity !== undefined ? item.quantity : 0,
                price: item.price !== undefined ? item.price : 0,
              };

              if (existingItem) {
                // Get the primary key for the existing item
                const existingKeys = await new Promise((resolve, reject) => {
                  const req = invIndex.getAllKeys(inventoryId);
                  req.onsuccess = () => resolve(req.result);
                  req.onerror = () => reject(req.error);
                });
                const existingKey =
                  existingKeys[existingItems.indexOf(existingItem)];
                invStore.put(inventoryItem, existingKey);
              } else {
                invStore.add(inventoryItem);
              }

              await new Promise((resolve, reject) => {
                invTx.oncomplete = () => resolve();
                invTx.onerror = () => reject(invTx.error);
              });
            }

            // Save to catalog store if rarity, name, or image changed
            if (field && catalogFields.includes(field)) {
              const catalogTx = db.transaction(
                [STORE_ITEM_CATALOG],
                "readwrite"
              );
              const catalogStore = catalogTx.objectStore(STORE_ITEM_CATALOG);
              catalogStore.put({
                type: item.type,
                name: item.name || "Unknown Item",
                image: item.image || "",
                rarity: item.rarity !== undefined ? item.rarity : 0,
              });
              await new Promise((resolve, reject) => {
                catalogTx.oncomplete = () => resolve();
                catalogTx.onerror = () => reject(catalogTx.error);
              });
            }

            // If no specific field, save all fields (for backwards compatibility)
            if (!field) {
              // Save to inventory items
              const invTx = db.transaction(
                [STORE_INVENTORY_ITEMS],
                "readwrite"
              );
              const invStore = invTx.objectStore(STORE_INVENTORY_ITEMS);
              const invIndex = invStore.index("inventoryId");

              const existingItems = await new Promise((resolve, reject) => {
                const req = invIndex.getAll(inventoryId);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
              });

              const existingItem = existingItems.find(
                (i) => i.type === item.type
              );
              const inventoryItem = {
                inventoryId: inventoryId,
                type: item.type,
                quantity: item.quantity !== undefined ? item.quantity : 0,
                price: item.price !== undefined ? item.price : 0,
              };

              if (existingItem) {
                const existingKeys = await new Promise((resolve, reject) => {
                  const req = invIndex.getAllKeys(inventoryId);
                  req.onsuccess = () => resolve(req.result);
                  req.onerror = () => reject(req.error);
                });
                const existingKey =
                  existingKeys[existingItems.indexOf(existingItem)];
                invStore.put(inventoryItem, existingKey);
              } else {
                invStore.add(inventoryItem);
              }

              await new Promise((resolve, reject) => {
                invTx.oncomplete = () => resolve();
                invTx.onerror = () => reject(invTx.error);
              });

              // Save to catalog
              const catalogTx = db.transaction(
                [STORE_ITEM_CATALOG],
                "readwrite"
              );
              const catalogStore = catalogTx.objectStore(STORE_ITEM_CATALOG);
              catalogStore.put({
                type: item.type,
                name: item.name || "Unknown Item",
                image: item.image || "",
                rarity: item.rarity !== undefined ? item.rarity : 0,
              });
              await new Promise((resolve, reject) => {
                catalogTx.oncomplete = () => resolve();
                catalogTx.onerror = () => reject(catalogTx.error);
              });
            }
          } catch (e) {
            console.error("Error saving item:", e);
          }
        };

        const handleReplaceImage = useCallback(
          async (item, newImageFile) => {
            if (!item || !newImageFile) {
              console.error("Invalid item or image file");
              return;
            }

            try {
              // Use the new image file's name as the filename
              // This ensures the item's image field reflects the actual image file name
              const filename = newImageFile.name;
              const oldFilename = item.image;
              const oldImageUrl = imageMap?.get(oldFilename);

              // Create new blob URL
              const newImageUrl = URL.createObjectURL(newImageFile);

              // Update imageMap state first so UI updates immediately
              setImageMap((prevMap) => {
                const newMap = new Map(prevMap);
                // Remove old image from map if it exists and is different
                if (oldFilename && oldFilename !== filename) {
                  if (oldImageUrl && oldImageUrl.startsWith("blob:")) {
                    URL.revokeObjectURL(oldImageUrl);
                  }
                  newMap.delete(oldFilename);
                }
                // Add new image
                newMap.set(filename, newImageUrl);
                return newMap;
              });

              // Always update the item's image field to the new filename
              setData((prevData) => {
                const newData = [...prevData];
                // Find item by type (primary key) or actualIndex
                const itemIndex = newData.findIndex(
                  (d) =>
                    (item.type && d.type === item.type) ||
                    (item.actualIndex !== undefined &&
                      d.actualIndex === item.actualIndex)
                );
                if (itemIndex !== -1) {
                  newData[itemIndex] = {
                    ...newData[itemIndex],
                    image: filename,
                  };
                  // Save updated item to IndexedDB with new image filename
                  saveItemToDB(newData[itemIndex], "image", activeInventoryId);
                }
                return newData;
              });

              // Save to IndexedDB
              const imageFileMap = new Map();
              imageFileMap.set(filename, newImageFile);
              await saveImagesToIndexedDB(imageFileMap);

              console.log(`Replaced image for ${item.name} (${filename})`);
            } catch (e) {
              console.error("Error replacing image:", e);
              alert(`Error replacing image: ${e.message}`);
            }
          },
          [imageMap]
        );

        const handleUpdateItem = useCallback(
          (actualIndex, field, value, saveImmediately = false) => {
            setData((prevData) => {
              const newData = [...prevData];
              const oldItem = newData[actualIndex];
              newData[actualIndex] = {
                ...newData[actualIndex],
                [field]: value,
              };

              // If name changed, regenerate embedding
              if (field === "name" && oldItem.name !== value && pipeline) {
                (async () => {
                  try {
                    const output = await pipeline(`Furniture item: ${value}`, {
                      pooling: "mean",
                      normalize: true,
                    });
                    const newVector = Array.from(output.data);

                    // Update embeddings array
                    setEmbeddings((prevEmbeddings) => {
                      if (!prevEmbeddings) return prevEmbeddings;
                      const updated = [...prevEmbeddings];
                      updated[actualIndex] = newVector;
                      return updated;
                    });

                    // Save to IndexedDB (Using TYPE as key)
                    const embeddingsToSave = new Map();
                    embeddingsToSave.set(newData[actualIndex].type, newVector);
                    await saveEmbeddingsToIndexedDB(embeddingsToSave);
                  } catch (e) {
                    console.error(
                      "Error regenerating embedding for name change:",
                      e
                    );
                  }
                })();
              }

              // Efficient Save: Only update the single changed item
              // DO NOT re-save images here.
              const updatedItem = newData[actualIndex];

              if (saveImmediately) {
                // Save immediately on blur
                saveItemToDB(updatedItem, field, activeInventoryId);
                // Clear any pending debounced save for this item
                if (window._saveTimeouts && window._saveTimeouts[actualIndex]) {
                  clearTimeout(window._saveTimeouts[actualIndex]);
                  delete window._saveTimeouts[actualIndex];
                }
              } else {
                // For text inputs (name), use debounced save
                // For number inputs (quantity, price) and selects (rarity), only save on blur
                const textFields = ["name"];
                if (textFields.includes(field)) {
                  // Debounced save after 10 seconds of no typing for text fields
                  if (!window._saveTimeouts) {
                    window._saveTimeouts = {};
                  }
                  if (window._saveTimeouts[actualIndex]) {
                    clearTimeout(window._saveTimeouts[actualIndex]);
                  }
                  window._saveTimeouts[actualIndex] = setTimeout(async () => {
                    await saveItemToDB(updatedItem, field, activeInventoryId);
                    delete window._saveTimeouts[actualIndex];
                  }, 10000); // 10 seconds
                }
                // For quantity, price, rarity - don't save on onChange, only on blur
              }

              return newData;
            });
          },
          [extractionDate, pipeline, activeInventoryId]
        );

        const handleExport = async () => {
          if (!data) return;

          try {
            // Get current date in the same format as extraction date (matching extractor format)
            const now = new Date();
            const currentDate = now.toLocaleString("en-US", {
              weekday: "long",
              year: "numeric",
              month: "long",
              day: "numeric",
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
              timeZoneName: "short",
            });
            const currentTimestamp = now.getTime();

            // Prepare export data in the format expected by import
            const exportData = data.map(
              ({ actualIndex, score, ...item }) => item
            );
            const exportObject = {
              data: exportData,
              timestamp: currentTimestamp,
              Date: currentDate,
            };

            // Get images from IndexedDB
            const imageBlobs = await getImagesFromIndexedDB();

            // Create ZIP file
            const zip = new JSZip();

            // Add data file (named exactly as import expects)
            zip.file(
              "furniture_data.txt",
              JSON.stringify(exportObject, null, 2)
            );

            // Add all images
            for (const [filename, blob] of imageBlobs.entries()) {
              zip.file(filename, blob);
            }

            // Generate ZIP and download
            const zipBlob = await zip.generateAsync({ type: "blob" });
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement("a");
            a.href = url;
            // Format date as YYYY-MM-DD for filename
            const dateStr = now.toISOString().split("T")[0];
            a.download = `my_vmk_furniture_${dateStr}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log(
              `Exported ${exportData.length} items and ${imageBlobs.size} images to ZIP file.`
            );
          } catch (e) {
            console.error("Error exporting data:", e);
            alert(`Error exporting data: ${e.message}`);
          }
        };

        const handleUpdateInventory = () => {
          // Show confirmation modal first
          setShowUpdateConfirmModal(true);
        };

        const handleUpdateInventoryConfirm = () => {
          // Close modal and trigger file input
          setShowUpdateConfirmModal(false);
          if (updateInventoryInputRef.current) {
            updateInventoryInputRef.current.click();
          }
        };

        const handleUpdateInventoryFileSelect = async (e) => {
          const files = Array.from(e.target.files);
          if (files.length === 0) {
            e.target.value = "";
            return;
          }

          try {
            const dataFile = files.find(
              (f) =>
                f.name.toLowerCase() === "furniture_data.txt" ||
                f.name.toLowerCase().endsWith(".json")
            );
            if (!dataFile) {
              alert("Could not find 'furniture_data.txt'.");
              e.target.value = "";
              return;
            }

            const urlMap = new Map();
            const fileMap = new Map();

            files.forEach((file) => {
              if (file.type.startsWith("image/")) {
                urlMap.set(file.name, URL.createObjectURL(file));
                fileMap.set(file.name, file);
              }
            });

            const text = await readFileAsText(dataFile);
            const { data: enrichedData, metadata } = parseAndEnrichData(text);

            // Process update directly (confirmation was already shown)
            await handleUpdateInventoryData(
              enrichedData,
              urlMap,
              metadata,
              fileMap
            );
            e.target.value = ""; // Reset input
          } catch (err) {
            console.error(err);
            alert(`Error reading file: ${err.message}`);
            e.target.value = "";
          }
        };

        const handleUpdateInventoryData = async (
          loadedData,
          loadedUrlMap,
          metadata,
          loadedFileMap
        ) => {
          try {
            // Load existing items from current inventory
            if (!activeInventoryId) {
              alert(
                "No active inventory selected. Please select an inventory first."
              );
              return;
            }

            const existingItems = await loadInventoryItems(activeInventoryId);

            // Get existing image map (use state if available, otherwise load from IndexedDB)
            let existingImageMap = imageMap;
            if (!existingImageMap) {
              const imageBlobs = await getImagesFromIndexedDB();
              existingImageMap = new Map();
              for (const [filename, blob] of imageBlobs.entries()) {
                existingImageMap.set(filename, URL.createObjectURL(blob));
              }
            }

            // Load catalog to check for global metadata conflicts (rarity, image)
            const db = await openDB();
            const catalogTx = db.transaction([STORE_ITEM_CATALOG], "readonly");
            const catalogStore = catalogTx.objectStore(STORE_ITEM_CATALOG);
            const catalogItems = await new Promise((resolve, reject) => {
              const req = catalogStore.getAll();
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
            });
            const catalogMap = new Map(
              catalogItems.map((item) => [item.type, item])
            );

            // Create maps for efficient lookup using TYPE
            const existingItemsMap = new Map(
              existingItems.map((item) => [item.type, item])
            );
            const existingImageFilenames = new Set(existingImageMap.keys());

            // Detect conflicts
            const conflicts = [];
            for (const newItem of loadedData) {
              const existingItem = existingItemsMap.get(newItem.type);
              const catalogItem = catalogMap.get(newItem.type);

              // Check inventory-specific conflicts (quantity, price) - only if item exists in inventory
              if (existingItem) {
                // Only check quantity if it exists in newItem (ignore if missing)
                if (newItem.hasOwnProperty("quantity") && newItem.quantity) {
                  const newQuantity = Number(newItem.quantity) || 0;
                  const existingQuantity = Number(existingItem.quantity) || 0;
                  if (newQuantity !== existingQuantity) {
                    conflicts.push({
                      itemType: newItem.type,
                      item: existingItem,
                      field: "quantity",
                      currentValue: existingQuantity,
                      newValue: newQuantity,
                    });
                  }
                }

                // Only check price if it exists in newItem (ignore if missing)
                if (newItem.hasOwnProperty("price") && newItem.price) {
                  const newPrice = Number(newItem.price) || 0;
                  const existingPrice = Number(existingItem.price) || 0;
                  if (newPrice !== existingPrice) {
                    conflicts.push({
                      itemType: newItem.type,
                      item: existingItem,
                      field: "price",
                      currentValue: existingPrice,
                      newValue: newPrice,
                    });
                  }
                }

                // Check global metadata conflicts (rarity, image) - use existingItem which already has catalog data merged
                // Only check rarity if it exists in newItem (ignore if missing)
                if (
                  newItem.hasOwnProperty("rarity") &&
                  newItem.rarity !== undefined &&
                  newItem.rarity !== null
                ) {
                  const newRarity = Number(newItem.rarity) || 0;
                  const existingRarity = Number(existingItem.rarity) || 0;
                  if (newRarity !== existingRarity) {
                    conflicts.push({
                      itemType: newItem.type,
                      item: existingItem,
                      field: "rarity",
                      currentValue: existingRarity,
                      newValue: newRarity,
                      isGlobalMetadata: true, // Flag to indicate this is global metadata
                    });
                  }
                }

                // Only check image if it exists in newItem (ignore if missing)
                if (newItem.hasOwnProperty("image") && newItem.image) {
                  // Normalize image values - handle empty string
                  const newImage = String(newItem.image).trim();
                  const existingImage = existingItem.image
                    ? String(existingItem.image).trim()
                    : "";

                  // Detect image conflict if:
                  // 1. Both have images and they're different
                  // 2. Existing has image, new doesn't (would remove image)
                  // 3. Existing doesn't have image, new has one (would add image)
                  if (
                    newImage !== existingImage &&
                    (newImage || existingImage)
                  ) {
                    conflicts.push({
                      itemType: newItem.type,
                      item: existingItem,
                      field: "image",
                      currentValue: existingImage || "None",
                      newValue: newImage || "None",
                      isGlobalMetadata: true, // Flag to indicate this is global metadata
                    });
                  }
                }
              } else if (catalogItem) {
                // Item doesn't exist in inventory but exists in catalog
                // Check global metadata conflicts against catalog
                // Only check rarity if it exists in newItem (ignore if missing)
                if (
                  newItem.hasOwnProperty("rarity") &&
                  newItem.rarity !== undefined &&
                  newItem.rarity !== null
                ) {
                  const newRarity = Number(newItem.rarity) || 0;
                  const catalogRarity = Number(catalogItem.rarity) || 0;
                  if (newRarity !== catalogRarity) {
                    conflicts.push({
                      itemType: newItem.type,
                      item: catalogItem, // Use catalog item for global metadata conflicts
                      field: "rarity",
                      currentValue: catalogRarity,
                      newValue: newRarity,
                      isGlobalMetadata: true, // Flag to indicate this is global metadata
                    });
                  }
                }

                // Only check image if it exists in newItem (ignore if missing)
                if (newItem.hasOwnProperty("image") && newItem.image) {
                  // Normalize image values - handle empty string
                  const newImage = String(newItem.image).trim();
                  const catalogImage = catalogItem.image
                    ? String(catalogItem.image).trim()
                    : "";

                  // Detect image conflict if catalog has an image and it's different from new
                  if (
                    catalogImage &&
                    catalogImage !== "" &&
                    newImage !== catalogImage
                  ) {
                    conflicts.push({
                      itemType: newItem.type,
                      item: catalogItem, // Use catalog item for global metadata conflicts
                      field: "image",
                      currentValue: catalogImage || "None",
                      newValue: newImage || "None",
                      isGlobalMetadata: true, // Flag to indicate this is global metadata
                    });
                  }
                }
              }
              // If item doesn't exist in inventory or catalog, no conflicts (will be added as new)
            }

            // If conflicts exist, show modal
            if (conflicts.length > 0) {
              // Merge image maps for display in modal
              const mergedImageMapForModal = new Map(existingImageMap);
              for (const [filename, url] of loadedUrlMap.entries()) {
                if (!mergedImageMapForModal.has(filename)) {
                  mergedImageMapForModal.set(filename, url);
                }
              }

              setConflictsData({
                conflicts,
                loadedData,
                loadedUrlMap,
                metadata,
                loadedFileMap,
                existingItems,
                existingImageMap,
                mergedImageMap: mergedImageMapForModal,
              });
              setShowConflictsModal(true);
              return;
            }

            // No conflicts, proceed with update
            await applyUpdateWithResolutions(
              loadedData,
              loadedUrlMap,
              metadata,
              loadedFileMap,
              existingItems,
              existingImageMap,
              {}
            );
          } catch (e) {
            console.error("Error updating inventory:", e);
            alert(`Error updating inventory: ${e.message}`);
          }
        };

        const applyUpdateWithResolutions = async (
          loadedData,
          loadedUrlMap,
          metadata,
          loadedFileMap,
          existingItems,
          existingImageMap,
          resolutions = {}
        ) => {
          try {
            // Load catalog to handle global metadata resolutions for items not in inventory
            const db = await openDB();
            const catalogTx = db.transaction([STORE_ITEM_CATALOG], "readonly");
            const catalogStore = catalogTx.objectStore(STORE_ITEM_CATALOG);
            const catalogItems = await new Promise((resolve, reject) => {
              const req = catalogStore.getAll();
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
            });
            const catalogMap = new Map(
              catalogItems.map((item) => [item.type, item])
            );

            // Create maps for efficient lookup using TYPE
            const existingItemsMap = new Map(
              existingItems.map((item) => [item.type, item])
            );
            const existingImageFilenames = new Set(existingImageMap.keys());

            // Build updated data
            const updatedItems = [];
            const newImageFileMap = new Map();
            const itemsNeedingEmbeddings = [];

            // Process loaded items
            for (const newItem of loadedData) {
              // Use TYPE for lookup
              const existingItem = existingItemsMap.get(newItem.type);

              if (existingItem) {
                // Item exists - apply user resolutions
                const quantityKey = `${newItem.type}-quantity`;
                const priceKey = `${newItem.type}-price`;
                const rarityKey = `${newItem.type}-rarity`;
                const imageKey = `${newItem.type}-image`;

                let finalQuantity = existingItem.quantity || 0;
                if (resolutions[quantityKey] === "replace") {
                  finalQuantity = newItem.quantity || 0;
                } else if (resolutions[quantityKey] === "add") {
                  finalQuantity =
                    (existingItem.quantity || 0) + (newItem.quantity || 0);
                }
                // else "keep" - use existing

                let finalPrice = existingItem.price || 0;
                if (resolutions[priceKey] === "replace") {
                  finalPrice = newItem.price || 0;
                }
                // else "keep" - use existing

                let finalRarity = existingItem.rarity || 0;
                if (resolutions[rarityKey] === "replace") {
                  finalRarity = newItem.rarity || 0;
                }
                // else "keep" - use existing

                let finalImage = existingItem.image || "";
                if (resolutions[imageKey] === "replace") {
                  finalImage = newItem.image || "";
                  // Always add new image to file map if it exists (even if filename matches existing)
                  // This ensures we save the new image file, overwriting any existing one
                  if (newItem.image && loadedFileMap.has(newItem.image)) {
                    newImageFileMap.set(
                      newItem.image,
                      loadedFileMap.get(newItem.image)
                    );
                  }
                } else {
                  // Keep existing image - but make sure it's in the finalImage
                  finalImage = existingItem.image || "";
                }

                updatedItems.push({
                  ...existingItem,
                  quantity: finalQuantity,
                  price: finalPrice,
                  rarity: finalRarity,
                  image: finalImage,
                });
                // Don't add to itemsNeedingEmbeddings since we're not changing name
              } else {
                // Item doesn't exist in inventory - check if it exists in catalog and has resolutions
                const catalogItem = catalogMap.get(newItem.type);
                const rarityKey = `${newItem.type}-rarity`;
                const imageKey = `${newItem.type}-image`;

                let finalRarity =
                  newItem.rarity !== undefined ? newItem.rarity : 0;
                let finalImage = newItem.image || "";

                // Apply resolutions if item exists in catalog (global metadata conflicts)
                if (catalogItem) {
                  if (resolutions[rarityKey] === "keep") {
                    finalRarity =
                      catalogItem.rarity !== undefined ? catalogItem.rarity : 0;
                  } else if (resolutions[rarityKey] === "replace") {
                    finalRarity =
                      newItem.rarity !== undefined ? newItem.rarity : 0;
                  }
                  // If no resolution, use new value (default behavior)

                  if (resolutions[imageKey] === "keep") {
                    finalImage = catalogItem.image || "";
                  } else if (resolutions[imageKey] === "replace") {
                    finalImage = newItem.image || "";
                    // Add new image to file map if replacing
                    if (newItem.image && loadedFileMap.has(newItem.image)) {
                      newImageFileMap.set(
                        newItem.image,
                        loadedFileMap.get(newItem.image)
                      );
                    }
                  }
                  // If no resolution, use new value (default behavior)
                }

                // Create item with resolved values
                const resolvedItem = {
                  ...newItem,
                  rarity: finalRarity,
                  image: finalImage,
                };
                updatedItems.push(resolvedItem);
                itemsNeedingEmbeddings.push(resolvedItem);

                // Add image for new item (if not already added above)
                if (
                  finalImage &&
                  !existingImageFilenames.has(finalImage) &&
                  loadedFileMap.has(finalImage)
                ) {
                  const imageFile = loadedFileMap.get(finalImage);
                  if (imageFile) {
                    newImageFileMap.set(finalImage, imageFile);
                  }
                }
              }
            }

            // Keep existing items that weren't in the update
            for (const existingItem of existingItems) {
              // Check using TYPE
              if (!loadedData.find((item) => item.type === existingItem.type)) {
                updatedItems.push(existingItem);
              }
            }

            // Add new images that don't match existing items
            for (const [filename, file] of loadedFileMap.entries()) {
              if (!existingImageFilenames.has(filename)) {
                const itemUsingImage = loadedData.find(
                  (item) => item.image === filename
                );
                if (
                  itemUsingImage &&
                  !existingItemsMap.has(itemUsingImage.type)
                ) {
                  newImageFileMap.set(filename, file);
                }
              }
            }

            // Index the updated data
            const indexedData = updatedItems.map((d, i) => ({
              ...d,
              actualIndex: i,
            }));

            // Build merged image map
            const mergedImageMap = new Map(existingImageMap);

            // Track which images are being replaced (from resolutions)
            const replacedImageFilenames = new Set();
            for (const newItem of loadedData) {
              const existingItem = existingItemsMap.get(newItem.type);
              if (existingItem) {
                const imageKey = `${newItem.type}-image`;
                if (resolutions[imageKey] === "replace" && newItem.image) {
                  replacedImageFilenames.add(newItem.image);
                }
              }
            }

            // Update image map with new images from loadedUrlMap
            // Always update if this image is being replaced or if it doesn't exist yet
            for (const [filename, url] of loadedUrlMap.entries()) {
              if (
                replacedImageFilenames.has(filename) ||
                !mergedImageMap.has(filename)
              ) {
                // Revoke old URL if it exists and is different
                const oldUrl = mergedImageMap.get(filename);
                if (oldUrl && oldUrl !== url && oldUrl.startsWith("blob:")) {
                  URL.revokeObjectURL(oldUrl);
                }
                mergedImageMap.set(filename, url);
              }
            }

            // Add any new image files that weren't in loadedUrlMap
            for (const [filename, file] of newImageFileMap.entries()) {
              if (
                replacedImageFilenames.has(filename) ||
                !mergedImageMap.has(filename)
              ) {
                // If replacing, revoke old URL first
                const oldUrl = mergedImageMap.get(filename);
                if (oldUrl && oldUrl.startsWith("blob:")) {
                  URL.revokeObjectURL(oldUrl);
                }
                mergedImageMap.set(filename, URL.createObjectURL(file));
              }
            }

            // Revoke old blob URLs if needed
            if (imageMap) {
              imageMap.forEach((url) => {
                if (
                  url.startsWith("blob:") &&
                  !Array.from(mergedImageMap.values()).includes(url)
                ) {
                  URL.revokeObjectURL(url);
                }
              });
            }

            setData(indexedData);
            setImageMap(mergedImageMap);
            setHasStoredData(true);

            // Clear embeddings to trigger regeneration for new items only
            setEmbeddings(null);

            // Don't update extraction date for updates

            // STEP 1: Save only new images (for new items)
            if (newImageFileMap.size > 0) {
              await saveImagesToIndexedDB(newImageFileMap, existingImageMap);
            }

            // STEP 2: Save updated data to current inventory
            if (activeInventoryId) {
              await saveItemsToInventory(activeInventoryId, indexedData);
              // Reload items
              const updatedItemsReloaded = await loadInventoryItems(
                activeInventoryId
              );
              if (updatedItemsReloaded && updatedItemsReloaded.length > 0) {
                const indexedDataUpdated = updatedItemsReloaded.map((d, i) => ({
                  ...d,
                  actualIndex: i,
                }));
                setData(indexedDataUpdated);
              }
            }

            console.log(
              `Updated inventory: ${updatedItems.length} items (${itemsNeedingEmbeddings.length} new). Saved ${newImageFileMap.size} new images.`
            );
          } catch (e) {
            console.error("Error updating inventory:", e);
            alert(`Error updating inventory: ${e.message}`);
          }
        };

        const handleApplyConflictsResolutions = async (resolutions) => {
          if (!conflictsData) return;

          const {
            loadedData,
            loadedUrlMap,
            metadata,
            loadedFileMap,
            existingItems,
            existingImageMap,
          } = conflictsData;

          await applyUpdateWithResolutions(
            loadedData,
            loadedUrlMap,
            metadata,
            loadedFileMap,
            existingItems,
            existingImageMap,
            resolutions
          );

          // Clear conflicts data
          setConflictsData(null);
        };

        const readFileAsText = (file) => {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => resolve(event.target.result);
            reader.onerror = (error) => reject(error);
            reader.readAsText(file);
          });
        };

        const parseAndEnrichData = (rawText) => {
          let text = rawText.trim();
          if (text.endsWith(",") || text.endsWith(",]"))
            text = text.replace(/,(\s*\]?)$/, "$1");

          let json;
          try {
            json = JSON.parse(text);
          } catch (e) {
            try {
              json = JSON.parse(`[${text}]`);
            } catch (e2) {
              throw new Error(
                "Failed to parse JSON. Ensure the file contains a valid JSON array."
              );
            }
          }

          let dataArray;
          let metadata = null;

          const extractFromObject = (obj) => {
            if (
              obj &&
              typeof obj === "object" &&
              obj.data &&
              Array.isArray(obj.data)
            ) {
              return {
                data: obj.data,
                meta: {
                  timestamp: obj.timestamp,
                  Date: obj.Date,
                  username:
                    obj.username || obj.userName || obj.user_name || null,
                },
              };
            }
            return null;
          };

          let extracted = extractFromObject(json);

          if (!extracted && Array.isArray(json) && json.length === 1) {
            extracted = extractFromObject(json[0]);
          }

          if (extracted) {
            dataArray = extracted.data;
            metadata = extracted.meta;
          } else if (Array.isArray(json)) {
            dataArray = json;
          } else {
            throw new Error(
              "File content is not a valid JSON array or object with data property."
            );
          }

          const enrichedData = dataArray.map((item, idx) => ({
            // CRITICAL: Type is now primary ID
            type: item.type || item.id || `temp-${idx}`,
            id: item.id || `temp-${idx}`,
            ...item,
            name: item.name || "Unknown Item",
            image: item.image || "",
            quantity:
              item.count !== undefined ? item.count : item.quantity || 0,
            price: item.price !== undefined ? item.price : 0,
            rarity: item.rarity !== undefined ? item.rarity : 0,
          }));

          return { data: enrichedData, metadata };
        };

        const handleClear = () => {
          setShowFirstClearModal(true);
        };

        const handleFirstClearConfirm = () => {
          setShowFirstClearModal(false);
          setShowSecondClearModal(true);
        };

        const handleSecondClearConfirm = async () => {
          setShowSecondClearModal(false);
          if (imageMap) imageMap.forEach((url) => URL.revokeObjectURL(url));
          setData(null);
          setImageMap(null);
          setExtractionDate(null);
          setHasStoredData(false);
          setEmbeddings(null);
          setIndexingProgress(0);
          setSearchQuery("");
          setInventories([]);
          setActiveInventoryId(null);
          setOpenInventoryIds([]);
          setSublists([]);
          await clearIndexedDB();
        };

        const handleSaveToDesktop = () => {
          if (!data) return;
          setShowSaveToDesktopModal(true);
        };

        const handleSaveToDesktopConfirm = async () => {
          setShowSaveToDesktopModal(false);
          setIsExporting(true);

          try {
            // 1. Initialize SQL.js
            let initSqlJs = window.initSqlJs;
            if (!initSqlJs) {
              await new Promise((resolve) => {
                let attempts = 0;
                const checkInterval = setInterval(() => {
                  attempts++;
                  if (window.initSqlJs) {
                    initSqlJs = window.initSqlJs;
                    clearInterval(checkInterval);
                    resolve();
                  } else if (attempts > 50) {
                    clearInterval(checkInterval);
                    resolve();
                  }
                }, 100);
              });
            }

            if (!initSqlJs) throw new Error("SQL.js library not loaded.");

            const SQL = await initSqlJs({
              locateFile: (file) =>
                `https://cdn.jsdelivr.net/npm/sql.js@1.10.3/dist/${file}`,
            });
            const db = new SQL.Database();

            // 2. Create Tables (Both Legacy "items" and New Structure)
            db.run(
              `CREATE TABLE IF NOT EXISTS metadata (key TEXT PRIMARY KEY, value TEXT);`
            );

            // Legacy table for backward compatibility / single view tools
            db.run(
              `CREATE TABLE IF NOT EXISTS items (type TEXT PRIMARY KEY, id TEXT, name TEXT, quantity INTEGER, price REAL, rarity INTEGER, image TEXT, data TEXT);`
            );
            db.run(
              `CREATE TABLE IF NOT EXISTS images (filename TEXT PRIMARY KEY, data BLOB);`
            );

            // NEW TABLES for Full State Backup
            db.run(
              `CREATE TABLE IF NOT EXISTS inventories (id TEXT PRIMARY KEY, name TEXT, createdAt INTEGER, updatedAt INTEGER);`
            );
            db.run(
              `CREATE TABLE IF NOT EXISTS inventory_items (inventoryId TEXT, type TEXT, quantity INTEGER, price REAL);`
            );
            db.run(
              `CREATE TABLE IF NOT EXISTS sublists (id TEXT PRIMARY KEY, inventoryId TEXT, name TEXT, itemTypes TEXT, createdAt INTEGER, updatedAt INTEGER);`
            );
            db.run(
              `CREATE TABLE IF NOT EXISTS catalog (type TEXT PRIMARY KEY, name TEXT, image TEXT, rarity INTEGER);`
            );

            // 3. Save Metadata
            const now = new Date();
            db.run(
              `INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)`,
              ["date", now.toLocaleString()]
            );
            db.run(
              `INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)`,
              ["version", "5.0"]
            );

            // 4. Fetch ALL Data from IndexedDB
            const idb = await openDB();

            const [catItems, invItems, invs, subs, imgs] = await Promise.all([
              new Promise(
                (r) =>
                  (idb
                    .transaction(STORE_ITEM_CATALOG, "readonly")
                    .objectStore(STORE_ITEM_CATALOG)
                    .getAll().onsuccess = (e) => r(e.target.result))
              ),
              new Promise(
                (r) =>
                  (idb
                    .transaction(STORE_INVENTORY_ITEMS, "readonly")
                    .objectStore(STORE_INVENTORY_ITEMS)
                    .getAll().onsuccess = (e) => r(e.target.result))
              ),
              new Promise(
                (r) =>
                  (idb
                    .transaction(STORE_INVENTORIES, "readonly")
                    .objectStore(STORE_INVENTORIES)
                    .getAll().onsuccess = (e) => r(e.target.result))
              ),
              new Promise(
                (r) =>
                  (idb
                    .transaction(STORE_SUBLISTS, "readonly")
                    .objectStore(STORE_SUBLISTS)
                    .getAll().onsuccess = (e) => r(e.target.result))
              ),
              getImagesFromIndexedDB(),
            ]);

            // 5. Save Data to SQLite

            // Inventories
            const stmtInv = db.prepare(
              "INSERT INTO inventories VALUES (?, ?, ?, ?)"
            );
            invs.forEach((i) =>
              stmtInv.run([i.id, i.name, i.createdAt, i.updatedAt])
            );
            stmtInv.free();

            // Inventory Items
            const stmtInvItems = db.prepare(
              "INSERT INTO inventory_items VALUES (?, ?, ?, ?)"
            );
            invItems.forEach((i) =>
              stmtInvItems.run([i.inventoryId, i.type, i.quantity, i.price])
            );
            stmtInvItems.free();

            // Catalog
            const stmtCat = db.prepare(
              "INSERT INTO catalog VALUES (?, ?, ?, ?)"
            );
            catItems.forEach((c) =>
              stmtCat.run([c.type, c.name, c.image, c.rarity])
            );
            stmtCat.free();

            // Sublists
            const stmtSub = db.prepare(
              "INSERT INTO sublists VALUES (?, ?, ?, ?, ?, ?)"
            );
            subs.forEach((s) =>
              stmtSub.run([
                s.id,
                s.inventoryId,
                s.name,
                JSON.stringify(s.itemTypes),
                s.createdAt,
                s.updatedAt,
              ])
            );
            stmtSub.free();

            // Legacy "items" table (Aggregated) for compatibility
            const catalogMap = new Map(catItems.map((i) => [i.type, i]));
            const aggregationMap = new Map();
            invItems.forEach((invItem) => {
              const type = invItem.type;
              const cat = catalogMap.get(type) || {};
              if (!aggregationMap.has(type)) {
                aggregationMap.set(type, {
                  type: type,
                  id: type,
                  name: cat.name || "Unknown",
                  image: cat.image || "",
                  rarity: cat.rarity || 0,
                  price: invItem.price || 0,
                  quantity: 0,
                });
              }
              aggregationMap.get(type).quantity += invItem.quantity || 0;
            });
            const stmtItems = db.prepare(
              "INSERT INTO items VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
            );
            for (const item of aggregationMap.values()) {
              stmtItems.run([
                item.type,
                item.type,
                item.name,
                item.quantity,
                item.price,
                item.rarity,
                item.image,
                JSON.stringify(item),
              ]);
            }
            stmtItems.free();

            // Images
            const stmtImg = db.prepare("INSERT INTO images VALUES (?, ?)");
            for (const [filename, blob] of imgs.entries()) {
              const u8 = new Uint8Array(await blob.arrayBuffer());
              stmtImg.run([filename, u8]);
            }
            stmtImg.free();

            // 6. Export
            const dbData = db.export();
            const dbBlob = new Blob([dbData], {
              type: "application/x-sqlite3",
            });
            const url = URL.createObjectURL(dbBlob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `inventory_backup_${
              now.toISOString().split("T")[0]
            }.db`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            db.close();
          } catch (e) {
            console.error(e);
            alert("Export failed: " + e.message);
          } finally {
            setIsExporting(false);
          }
        };
        const handleExportFor = () => {
          setHasSublistSelected(false);
          setPendingExportSublistId(null);
          setPendingExportParentInventoryId(null);
          setShowExportFormatModal(true);
        };

        // Inventory Handlers
        const handleNewInventory = () => {
          setShowNewInventoryModal(true);
        };

        const handleCreateInventory = async (name) => {
          try {
            const newInventory = await createInventory(name);
            const updatedInventories = await loadInventories();
            setInventories(updatedInventories);
            setActiveInventoryId(newInventory.id);
            setOpenInventoryIds((prev) => [...prev, newInventory.id]);
            setData([]);
            setShowNewInventoryModal(false);
          } catch (e) {
            console.error("Error creating inventory:", e);
            alert("Failed to create inventory: " + e.message);
          }
        };

        const handleCreateInventoryWithData = async (name, uploadCallback) => {
          // This will be called from NewInventoryModal when user clicks Upload Data
          // We'll need to handle the file upload and then create inventory
          setShowNewInventoryModal(false);
          // Trigger file upload, then create inventory with data
          // For now, create empty inventory and let user upload via + button
          await handleCreateInventory(name);
          uploadCallback();
        };

        const handleOpenInventory = () => {
          setShowOpenInventoryModal(true);
        };

        const handleOpenInventoryTab = async (inventoryId) => {
          if (!openInventoryIds.includes(inventoryId)) {
            setOpenInventoryIds((prev) => [...prev, inventoryId]);
          }
          setActiveInventoryId(inventoryId);

          // Load items for this inventory
          const items = await loadInventoryItems(inventoryId);
          if (items && items.length > 0) {
            const indexedData = items.map((d, i) => ({ ...d, actualIndex: i }));
            setData(indexedData);
            setHasStoredData(true);
          } else {
            setData([]);
            setHasStoredData(false);
          }

          // Load sublists for this inventory
          const loadedSublists = await loadSublists(inventoryId);
          setSublists(loadedSublists);
          setSelectedSublistId(null); // Reset to Main List
        };

        const handleTabClick = async (inventoryId) => {
          setActiveInventoryId(inventoryId);
          const items = await loadInventoryItems(inventoryId);
          if (items && items.length > 0) {
            const indexedData = items.map((d, i) => ({ ...d, actualIndex: i }));
            setData(indexedData);
            setHasStoredData(true);
          } else {
            setData([]);
            setHasStoredData(false);
          }

          // Load sublists for this inventory
          const loadedSublists = await loadSublists(inventoryId);
          setSublists(loadedSublists);
          setSelectedSublistId(null); // Reset to Main List
        };

        const handleTabClose = (inventoryId) => {
          if (openInventoryIds.length <= 1) {
            alert("Cannot close the last open inventory");
            return;
          }
          setOpenInventoryIds((prev) =>
            prev.filter((id) => id !== inventoryId)
          );
          if (activeInventoryId === inventoryId) {
            // Switch to another open inventory
            const remainingIds = openInventoryIds.filter(
              (id) => id !== inventoryId
            );
            if (remainingIds.length > 0) {
              handleTabClick(remainingIds[0]);
            }
          }
        };

        const handleCreateSublist = async (name, type) => {
          if (!activeInventoryId || !name.trim()) return;

          try {
            const newSublist = {
              inventoryId: activeInventoryId,
              name: name.trim(),
              itemTypes: [],
            };

            const savedSublist = await saveSublist(newSublist);
            alert(`Sublist "${savedSublist.name}" created successfully!`);
            const updatedSublists = await loadSublists(activeInventoryId);
            setSublists(updatedSublists);
            setShowNewSublistModal(false);
          } catch (e) {
            console.error("Error creating sublist:", e);
            alert("Failed to create sublist");
          }
        };

        const handleAddItemToSublist = async (sublistId, quantity = 1) => {
          if (!itemToAddToSublist || !sublistId) {
            console.error("Missing item or sublist ID", {
              itemToAddToSublist,
              sublistId,
            });
            return;
          }

          try {
            // Add item to sublist in database
            const updatedSublist = await addItemToSublist(
              sublistId,
              itemToAddToSublist.type,
              quantity
            );

            if (!updatedSublist) {
              throw new Error("Failed to update sublist");
            }

            const inventoryId = updatedSublist.inventoryId;

            // Reload sublists for the main view if it matches
            if (activeInventoryId === inventoryId) {
              const updatedSublists = await loadSublists(activeInventoryId);
              setSublists(updatedSublists);
            }

            // Reload sublists for left panel if it matches
            if (leftPanelInventoryId === inventoryId) {
              const updatedLeftSublists = await loadSublists(inventoryId);
              setLeftPanelSublists(updatedLeftSublists);
            }

            // Reload sublists for right panel if it matches
            if (rightPanelInventoryId === inventoryId) {
              const updatedRightSublists = await loadSublists(inventoryId);
              setRightPanelSublists(updatedRightSublists);
            }

            setShowAddToSublistModal(false);
            setItemToAddToSublist(null);
          } catch (e) {
            console.error("Error adding item to sublist:", e);
            alert(
              "Failed to add item to sublist: " + (e.message || "Unknown error")
            );
          }
        };

        const handleAddToSublistClick = (item) => {
          // Collect all sublists from main view and both panels
          const allSublists = [
            ...sublists,
            ...(isSplitView ? leftPanelSublists : []),
            ...(isSplitView ? rightPanelSublists : []),
          ];

          // Remove duplicates by id
          const uniqueSublists = Array.from(
            new Map(allSublists.map((s) => [s.id, s])).values()
          );

          if (uniqueSublists.length === 0) {
            alert(
              "No sublists available. Create a sublist first from the tab context menu."
            );
            return;
          }
          setItemToAddToSublist(item);
          setShowAddToSublistModal(true);
        };

        const handleClearManager = () => {
          setShowFirstClearModal(true);
        };

        const handleExportInventory = () => {
          // Clear any pending tab inventory ID so modal shows all inventories
          setPendingExportTabInventoryId(null);
          setPendingExportInventoryId(null);
          setShowExportInventoryModal(true);
        };

        const handleExportSpecificInventory = async (inventoryId) => {
          // Export a specific inventory by opening the export modal with it pre-selected
          // Load sublists for this specific inventory
          const inventorySublists = await loadSublists(inventoryId);
          setSublists(inventorySublists);

          setShowExportInventoryModal(true);
          // Store the inventory ID to pre-select it in the modal
          setPendingExportInventoryId(inventoryId);
          // Store the tab inventory ID to filter the modal
          setPendingExportTabInventoryId(inventoryId);
        };

        const handleExportInventories = async (
          inventoryIds,
          metadataOptions,
          hasSublist = false,
          sublistId = null,
          parentInventoryId = null
        ) => {
          // Store metadata options for use in export format handler
          setExportMetadataOptions(
            metadataOptions || {
              images: true,
              quantity: true,
              rarity: true,
              prices: true,
            }
          );
          // If exporting a sublist, don't set pendingExportInventoryId (we'll use parentInventoryId)
          // Otherwise, store selected inventory IDs for export
          if (!hasSublist) {
            setPendingExportInventoryId(inventoryIds[0] || null);
          } else {
            setPendingExportInventoryId(null);
          }
          // Store whether a sublist is selected
          setHasSublistSelected(hasSublist);
          // Store sublist information if exporting a sublist
          setPendingExportSublistId(sublistId);
          setPendingExportParentInventoryId(parentInventoryId);
          // Close export inventory modal and show format selection
          setShowExportInventoryModal(false);
          setShowExportFormatModal(true);
        };

        const handleUploadToCurrentInventory = () => {
          // Trigger file upload for current inventory
          if (updateInventoryInputRef.current) {
            updateInventoryInputRef.current.click();
          }
        };

        const handleImportData = () => {
          // Trigger directory input for importing data
          if (importDataInputRef.current) {
            importDataInputRef.current.click();
          }
        };

        const handleImportFileSelect = async (e) => {
          const files = Array.from(e.target.files);
          if (files.length === 0) {
            e.target.value = "";
            return;
          }

          try {
            // Look for inventory_data.txt in the folder
            const dataFile = files.find(
              (f) => f.name.toLowerCase() === "inventory_data.txt"
            );
            
            if (!dataFile) {
              throw new Error("Could not find 'inventory_data.txt' in the selected folder.");
            }

            // Check if there's also a .db file (for full restore)
            const dbFile = files.find((f) => f.name.toLowerCase().endsWith(".db"));
            
            if (dbFile) {
              // Import from database file
              let initSqlJs = window.initSqlJs;
              if (!initSqlJs) {
                await new Promise((resolve) => {
                  let attempts = 0;
                  const checkInterval = setInterval(() => {
                    attempts++;
                    if (window.initSqlJs) {
                      initSqlJs = window.initSqlJs;
                      clearInterval(checkInterval);
                      resolve();
                    } else if (attempts > 50) {
                      clearInterval(checkInterval);
                      resolve();
                    }
                  }, 100);
                });
              }

              if (!initSqlJs) throw new Error("SQL.js library not loaded.");

              const arrayBuffer = await dbFile.arrayBuffer();
              const SQL = await initSqlJs({
                locateFile: (file) =>
                  `https://cdn.jsdelivr.net/npm/sql.js@1.10.3/dist/${file}`,
              });
              const db = new SQL.Database(new Uint8Array(arrayBuffer));

              // Check for full backup
              const tables = db.exec(
                "SELECT name FROM sqlite_master WHERE type='table' AND name='inventories'"
              );

              if (tables.length > 0) {
                // Full restore mode
                try {
                  console.log("Starting full restore...");
                  await clearIndexedDB();
                  const idb = await openDB();

                  const restoreTable = async (sqlTable, idbStore, mapper) => {
                    const res = db.exec(`SELECT * FROM ${sqlTable}`);
                    if (res.length && res[0].values.length) {
                      const tx = idb.transaction(idbStore, "readwrite");
                      const store = tx.objectStore(idbStore);
                      const cols = res[0].columns;

                      res[0].values.forEach((row) => {
                        const obj = {};
                        cols.forEach((col, i) => (obj[col] = row[i]));
                        const finalObj = mapper ? mapper(obj) : obj;
                        store.put(finalObj);
                      });
                      await new Promise((resolve) => (tx.oncomplete = resolve));
                    }
                  };

                  await restoreTable("inventories", STORE_INVENTORIES);
                  await restoreTable("catalog", STORE_ITEM_CATALOG);
                  await restoreTable("inventory_items", STORE_INVENTORY_ITEMS);
                  await restoreTable("sublists", STORE_SUBLISTS, (obj) => ({
                    ...obj,
                    itemTypes: JSON.parse(obj.itemTypes || "[]"),
                  }));

                  const imgRes = db.exec("SELECT * FROM images");
                  if (imgRes.length && imgRes[0].values.length) {
                    const tx = idb.transaction(STORE_IMAGES, "readwrite");
                    const store = tx.objectStore(STORE_IMAGES);
                    imgRes[0].values.forEach((row) => {
                      const filename = row[0];
                      const data = row[1];
                      const blob = new Blob([data], { type: "image/jpeg" });
                      store.put({ filename, blob });
                    });
                    await new Promise((resolve) => (tx.oncomplete = resolve));
                  }

                  const metaRes = db.exec("SELECT * FROM metadata");
                  if (metaRes.length) {
                    const tx = idb.transaction(STORE_METADATA, "readwrite");
                    metaRes[0].values.forEach((row) => {
                      tx.objectStore(STORE_METADATA).put({
                        key: row[0],
                        value: row[1],
                      });
                    });
                  }

                  db.close();
                  window.location.reload();
                  return;
                } catch (e) {
                  console.error("Full restore failed:", e);
                  alert("Restore failed: " + e.message);
                  db.close();
                  return;
                }
              }

              // Legacy import mode
              const itemsResult = db.exec(
                "SELECT type, id, name, quantity, price, rarity, image, data FROM items"
              );
              if (!itemsResult || itemsResult.length === 0) {
                throw new Error("No items found in database.");
              }

              const items = [];
              const rows = itemsResult[0].values;
              const columns = itemsResult[0].columns;

              for (const row of rows) {
                const item = {};
                columns.forEach((col, idx) => {
                  if (col === "data" && row[idx]) {
                    try {
                      const parsed = JSON.parse(row[idx]);
                      Object.assign(item, parsed);
                    } catch (e) {
                      item[col] = row[idx];
                    }
                  } else {
                    item[col] = row[idx];
                  }
                });
                items.push(item);
              }

              const imagesResult = db.exec("SELECT filename, data FROM images");
              const urlMap = new Map();
              const fileMap = new Map();

              if (imagesResult && imagesResult.length > 0) {
                const imageRows = imagesResult[0].values;
                const imageColumns = imagesResult[0].columns;
                const filenameIdx = imageColumns.indexOf("filename");
                const dataIdx = imageColumns.indexOf("data");

                for (const row of imageRows) {
                  const filename = row[filenameIdx];
                  const blobData = row[dataIdx];

                  if (blobData) {
                    try {
                      let dataArray;
                      if (blobData instanceof Uint8Array) {
                        dataArray = blobData;
                      } else if (Array.isArray(blobData)) {
                        dataArray = new Uint8Array(blobData);
                      } else {
                        dataArray = new Uint8Array(blobData);
                      }

                      const blob = new Blob([dataArray], {
                        type: "image/jpeg",
                      });
                      urlMap.set(filename, URL.createObjectURL(blob));
                      fileMap.set(filename, blob);
                    } catch (err) {
                      console.warn(`Failed to load image ${filename}:`, err);
                    }
                  }
                }
              }

              const metadataResult = db.exec(
                "SELECT value FROM metadata WHERE key = 'date'"
              );
              let metadata = null;
              if (
                metadataResult &&
                metadataResult.length > 0 &&
                metadataResult[0].values.length > 0
              ) {
                const dateValue = metadataResult[0].values[0][0];
                metadata = { Date: dateValue };
              }

              db.close();

              const enrichedData = items.map((item, idx) => ({
                type: item.type || item.id || `temp-${idx}`,
                id: item.id || `temp-${idx}`,
                ...item,
                name: item.name || "Unknown Item",
                image: item.image || "",
                quantity: item.quantity || 0,
                price: item.price || 0,
                rarity: item.rarity !== undefined ? item.rarity : 0,
              }));

              // Check if we should use conflict resolution (if there's an existing inventory with items)
              let targetInventoryId = activeInventoryId;
              if (!targetInventoryId && inventories.length > 0) {
                targetInventoryId = inventories[0].id;
              }

              if (targetInventoryId) {
                const existingItems = await loadInventoryItems(
                  targetInventoryId
                );
                if (existingItems && existingItems.length > 0) {
                  // Use update handler which checks for conflicts
                  if (!activeInventoryId) {
                    setActiveInventoryId(targetInventoryId);
                    if (!openInventoryIds.includes(targetInventoryId)) {
                      setOpenInventoryIds([targetInventoryId]);
                    }
                  }
                  await handleUpdateInventoryData(
                    enrichedData,
                    urlMap,
                    metadata,
                    fileMap
                  );
                } else {
                  // Empty inventory, use handleDataLoaded
                  await handleDataLoaded(
                    enrichedData,
                    urlMap,
                    metadata,
                    fileMap
                  );
                }
              } else {
                // No inventory exists, use handleDataLoaded
                await handleDataLoaded(enrichedData, urlMap, metadata, fileMap);
              }
            } else {
              // Import from .txt file (inventory_data.txt)
              const text = await readFileAsText(dataFile);
              const { data: enrichedData, metadata } = parseAndEnrichData(text);

              // Load images from the folder
              const urlMap = new Map();
              const fileMap = new Map();
              
              files.forEach((file) => {
                if (file.type.startsWith("image/")) {
                  urlMap.set(file.name, URL.createObjectURL(file));
                  fileMap.set(file.name, file);
                }
              });

              // Check if we should use conflict resolution (if there's an existing inventory with items)
              let targetInventoryId = activeInventoryId;
              if (!targetInventoryId && inventories.length > 0) {
                targetInventoryId = inventories[0].id;
              }

              if (targetInventoryId) {
                const existingItems = await loadInventoryItems(
                  targetInventoryId
                );
                if (existingItems && existingItems.length > 0) {
                  // Use update handler which checks for conflicts
                  if (!activeInventoryId) {
                    setActiveInventoryId(targetInventoryId);
                    if (!openInventoryIds.includes(targetInventoryId)) {
                      setOpenInventoryIds([targetInventoryId]);
                    }
                  }
                  await handleUpdateInventoryData(
                    enrichedData,
                    urlMap,
                    metadata,
                    fileMap
                  );
                } else {
                  // Empty inventory, use handleDataLoaded
                  await handleDataLoaded(
                    enrichedData,
                    urlMap,
                    metadata,
                    fileMap
                  );
                }
              } else {
                // No inventory exists, use handleDataLoaded
                await handleDataLoaded(enrichedData, urlMap, metadata, fileMap);
              }
            }
          } catch (err) {
            console.error(err);
            alert("Import failed: " + err.message);
          } finally {
            e.target.value = "";
          }
        };

        // Split View Handlers
        const handleToggleSplitView = async () => {
          if (!isSplitView) {
            // Entering split view
            const leftId =
              activeInventoryId ||
              (inventories.length > 0 ? inventories[0].id : null);

            // CHANGE THIS LINE: Set rightId to match leftId
            const rightId = leftId;

            setLeftPanelInventoryId(leftId);
            setRightPanelInventoryId(rightId);

            // Load data for both panels
            if (leftId) {
              const leftItems = await loadInventoryItems(leftId);
              setLeftPanelData(
                leftItems.map((d, i) => ({ ...d, actualIndex: i }))
              );
              // Load sublists for left panel
              const leftSublists = await loadSublists(leftId);
              setLeftPanelSublists(leftSublists);
              setLeftPanelSelectedSublistId(null);
            }
            if (rightId) {
              const rightItems = await loadInventoryItems(rightId);
              setRightPanelData(
                rightItems.map((d, i) => ({ ...d, actualIndex: i }))
              );
              // Load sublists for right panel
              const rightSublists = await loadSublists(rightId);
              setRightPanelSublists(rightSublists);
              setRightPanelSelectedSublistId(null);
            }
          } else {
            // Exiting split view - restore to active inventory
            if (activeInventoryId) {
              const items = await loadInventoryItems(activeInventoryId);
              setData(items.map((d, i) => ({ ...d, actualIndex: i })));
            }
          }
          setIsSplitView(!isSplitView);
        };

        const handleLeftPanelInventoryChange = async (inventoryId) => {
          setLeftPanelInventoryId(inventoryId);
          const items = await loadInventoryItems(inventoryId);
          setLeftPanelData(items.map((d, i) => ({ ...d, actualIndex: i })));
          // Load sublists for left panel
          const leftSublists = await loadSublists(inventoryId);
          setLeftPanelSublists(leftSublists);
          setLeftPanelSelectedSublistId(null);
        };

        const handleRightPanelInventoryChange = async (inventoryId) => {
          setRightPanelInventoryId(inventoryId);
          const items = await loadInventoryItems(inventoryId);
          setRightPanelData(items.map((d, i) => ({ ...d, actualIndex: i })));
          // Load sublists for right panel
          const rightSublists = await loadSublists(inventoryId);
          setRightPanelSublists(rightSublists);
          setRightPanelSelectedSublistId(null);
        };

        const handleTransferItem = (item) => {
          setTransferItem(item);
          setShowTransferModal(true);
        };

        const handleTransfer = async (
          sourceInventoryId,
          targetInventoryId,
          itemType,
          quantity
        ) => {
          try {
            await transferItems(
              sourceInventoryId,
              targetInventoryId,
              itemType,
              quantity
            );

            // Reload items for main view if it matches source or target
            if (
              activeInventoryId === sourceInventoryId ||
              activeInventoryId === targetInventoryId
            ) {
              const items = await loadInventoryItems(activeInventoryId);
              if (items && items.length > 0) {
                const indexedData = items.map((d, i) => ({
                  ...d,
                  actualIndex: i,
                }));
                setData(indexedData);
              } else {
                setData([]);
              }
            }

            // Reload items for split view panels if they match source or target
            if (isSplitView) {
              if (
                leftPanelInventoryId === sourceInventoryId ||
                leftPanelInventoryId === targetInventoryId
              ) {
                const leftItems = await loadInventoryItems(
                  leftPanelInventoryId
                );
                setLeftPanelData(
                  leftItems.map((d, i) => ({ ...d, actualIndex: i }))
                );
              }
              if (
                rightPanelInventoryId === sourceInventoryId ||
                rightPanelInventoryId === targetInventoryId
              ) {
                const rightItems = await loadInventoryItems(
                  rightPanelInventoryId
                );
                setRightPanelData(
                  rightItems.map((d, i) => ({ ...d, actualIndex: i }))
                );
              }
            }

            alert(
              `Transferred ${quantity} ${
                transferItem?.name || "item(s)"
              } successfully!`
            );
          } catch (e) {
            console.error("Error transferring items:", e);
            const errorMessage =
              e && e.message ? e.message : "Unknown error occurred";
            alert("Failed to transfer items: " + errorMessage);
          }
        };

        const handleExportFormat = async (
          format,
          dataMetadataOptions = null
        ) => {
          setShowExportFormatModal(false);

          setIsExporting(true);
          const now = new Date();
          const dateStr = now.toISOString().split("T")[0];

          try {
            // Determine which data to export
            let exportData = data;
            let inventoryIdToExport = null;

            // If exporting a sublist, filter items by sublist's itemTypes
            if (pendingExportSublistId && pendingExportParentInventoryId) {
              // Load the parent inventory's items
              inventoryIdToExport = pendingExportParentInventoryId;
              const allItems = await loadInventoryItems(
                pendingExportParentInventoryId
              );

              // Load the sublist to get its itemTypes
              const db = await openDB();
              const tx = db.transaction([STORE_SUBLISTS], "readonly");
              const sublistsStore = tx.objectStore(STORE_SUBLISTS);
              const sublist = await new Promise((resolve, reject) => {
                const req = sublistsStore.get(pendingExportSublistId);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
              });

              if (
                sublist &&
                sublist.itemTypes &&
                sublist.itemTypes.length > 0
              ) {
                // Filter items to only include those in the sublist
                exportData = allItems.filter(
                  (item) => item.type && sublist.itemTypes.includes(item.type)
                );
              } else {
                // Empty sublist
                exportData = [];
              }
            } else if (pendingExportInventoryId) {
              // If exporting from inventory modal, load that inventory's data
              inventoryIdToExport = pendingExportInventoryId;
              exportData = await loadInventoryItems(pendingExportInventoryId);
            } else if (!exportData) {
              // Fallback to current inventory if available
              if (activeInventoryId) {
                inventoryIdToExport = activeInventoryId;
                exportData = await loadInventoryItems(activeInventoryId);
              } else {
                alert("No data to export");
                setIsExporting(false);
                return;
              }
            }

            // Get images from IndexedDB for exports
            const imageBlobs = await getImagesFromIndexedDB();

            // Use dataMetadataOptions if provided (for "data" format), otherwise use exportMetadataOptions
            const metadataOpts = dataMetadataOptions || exportMetadataOptions;

            switch (format) {
              case "csv":
                await exportToCSV(
                  exportData,
                  dateStr,
                  imageBlobs,
                  metadataOpts
                );
                break;
              case "excel":
                await exportToExcel(
                  exportData,
                  dateStr,
                  imageBlobs,
                  metadataOpts
                );
                break;
              case "pdf":
                await exportToPDF(
                  exportData,
                  dateStr,
                  imageBlobs,
                  metadataOpts
                );
                break;
              case "data":
                await exportToData(exportData, imageBlobs, metadataOpts);
                break;
            }
          } catch (e) {
            console.error(`Error exporting to ${format}:`, e);
            alert(`Error exporting to ${format}: ${e.message}`);
          } finally {
            setIsExporting(false);
            // Reset sublist export state
            setPendingExportSublistId(null);
            setPendingExportParentInventoryId(null);
          }
        };

        const exportToCSV = (
          data,
          dateStr,
          imageBlobs,
          metadataOptions = {
            images: true,
            quantity: true,
            rarity: true,
            prices: true,
          }
        ) => {
          // Prepare CSV headers based on metadata options
          const headers = ["Type", "Name"];
          if (metadataOptions.quantity) headers.push("Quantity");
          if (metadataOptions.prices) headers.push("Price");
          if (metadataOptions.rarity) headers.push("Rarity");

          const rows = data.map((item) => {
            const row = [item.type || item.id || "", item.name || ""];
            if (metadataOptions.quantity) row.push(item.quantity || 0);
            if (metadataOptions.prices) row.push(item.price || 0);
            if (metadataOptions.rarity)
              row.push(RARITY_MAP[item.rarity]?.label || "Common");
            return row;
          });

          // Combine headers and rows
          const csvContent = [
            headers.join(","),
            ...rows.map((row) =>
              row
                .map((cell) => {
                  // Escape commas and quotes in cell values
                  const cellStr = String(cell);
                  if (
                    cellStr.includes(",") ||
                    cellStr.includes('"') ||
                    cellStr.includes("\n")
                  ) {
                    return `"${cellStr.replace(/"/g, '""')}"`;
                  }
                  return cellStr;
                })
                .join(",")
            ),
          ].join("\n");

          // Create blob and download plain CSV file
          const blob = new Blob([csvContent], {
            type: "text/csv;charset=utf-8;",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `my_vmk_furniture_${dateStr}.csv`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        };

        const exportToExcel = async (
          data,
          dateStr,
          imageBlobs,
          metadataOptions = {
            images: true,
            quantity: true,
            rarity: true,
            prices: true,
          }
        ) => {
          // Use ExcelJS for image support
          const ExcelJS = window.ExcelJS;
          const workbook = new ExcelJS.Workbook();
          const worksheet = workbook.addWorksheet("Inventory");

          // Build column headers based on metadata options
          // Type column will be added at the end as hidden
          const columns = [];
          let imageColIndex = -1;

          if (metadataOptions.images) {
            columns.push({ header: "Image", key: "image", width: 15 });
            imageColIndex = 0;
          }
          columns.push({ header: "Name", key: "name", width: 30 });
          if (metadataOptions.quantity) {
            columns.push({ header: "Quantity", key: "quantity", width: 10 });
          }
          if (metadataOptions.prices) {
            columns.push({ header: "Price", key: "price", width: 12 });
          }
          if (metadataOptions.rarity) {
            columns.push({ header: "Rarity", key: "rarity", width: 15 });
          }
          // Add Type column at the end as hidden (for metadata, not visible)
          columns.push({ header: "Type", key: "type", width: 20 });

          // Set column headers
          worksheet.columns = columns;

          // Style header row
          const headerRow = worksheet.getRow(1);
          headerRow.font = { bold: true };
          headerRow.fill = {
            type: "pattern",
            pattern: "solid",
            fgColor: { argb: "FFE0E0E0" },
          };
          headerRow.alignment = { vertical: "middle", horizontal: "center" };

          // Set column alignments and hide Type column
          let currentCol = 0;
          if (metadataOptions.images) {
            worksheet.getColumn(currentCol + 1).alignment = {
              vertical: "middle",
              horizontal: "center",
            }; // Image
            currentCol++;
          }
          worksheet.getColumn(currentCol + 1).alignment = {
            vertical: "middle",
            horizontal: "left",
          }; // Name
          currentCol++;
          if (metadataOptions.quantity) {
            worksheet.getColumn(currentCol + 1).alignment = {
              vertical: "middle",
              horizontal: "center",
            }; // Quantity
            currentCol++;
          }
          if (metadataOptions.prices) {
            worksheet.getColumn(currentCol + 1).alignment = {
              vertical: "middle",
              horizontal: "right",
            }; // Price
            currentCol++;
          }
          if (metadataOptions.rarity) {
            worksheet.getColumn(currentCol + 1).alignment = {
              vertical: "middle",
              horizontal: "center",
            }; // Rarity
            currentCol++;
          }
          // Type column is at the end - hide it
          const typeColIndex = currentCol + 1;
          worksheet.getColumn(typeColIndex).alignment = {
            vertical: "middle",
            horizontal: "left",
          };
          worksheet.getColumn(typeColIndex).hidden = true; // Hide Type column

          // Add data rows with images
          for (let i = 0; i < data.length; i++) {
            const item = data[i];
            // Build rowData in the same order as columns (Type always at the end)
            const rowData = {};
            if (metadataOptions.images) {
              rowData.image = ""; // Placeholder for image column
            }
            rowData.name = item.name || "";
            if (metadataOptions.quantity) rowData.quantity = item.quantity || 0;
            if (metadataOptions.prices) rowData.price = item.price || 0;
            if (metadataOptions.rarity)
              rowData.rarity = RARITY_MAP[item.rarity]?.label || "Common";
            // Type always included at the end (hidden)
            rowData.type = item.type || item.id || "";

            const row = worksheet.addRow(rowData);

            // Set row height for images
            if (metadataOptions.images) {
              row.height = 60;
            }

            // Set alignment for each cell
            let cellIndex = 1;
            if (metadataOptions.images) {
              row.getCell(cellIndex).alignment = {
                vertical: "middle",
                horizontal: "center",
              }; // Image
              cellIndex++;
            }
            row.getCell(cellIndex).alignment = {
              vertical: "middle",
              horizontal: "left",
            }; // Name
            cellIndex++;
            if (metadataOptions.quantity) {
              row.getCell(cellIndex).alignment = {
                vertical: "middle",
                horizontal: "center",
              }; // Quantity
              cellIndex++;
            }
            if (metadataOptions.prices) {
              row.getCell(cellIndex).alignment = {
                vertical: "middle",
                horizontal: "right",
              }; // Price
              cellIndex++;
            }
            if (metadataOptions.rarity) {
              row.getCell(cellIndex).alignment = {
                vertical: "middle",
                horizontal: "center",
              }; // Rarity
              cellIndex++;
            }
            // Type column is at the end (hidden) - alignment already set at column level

            // Add image if available and images are enabled
            if (
              metadataOptions.images &&
              item.image &&
              imageBlobs.has(item.image)
            ) {
              try {
                const imageBlob = imageBlobs.get(item.image);

                // Convert blob to array buffer
                const arrayBuffer = await imageBlob.arrayBuffer();

                // Determine image extension
                let extension = "jpeg";
                if (imageBlob.type === "image/png") {
                  extension = "png";
                } else if (imageBlob.type === "image/gif") {
                  extension = "gif";
                }

                // Add image to the image column
                const imageId = workbook.addImage({
                  buffer: arrayBuffer,
                  extension: extension,
                });

                // Position image in the cell
                // Center the image in the cell
                const imageSize = 50;
                const cellWidth =
                  worksheet.getColumn(imageColIndex + 1).width || 15;
                const cellHeight = row.height || 60;

                // Calculate offset to center image (in Excel units: 1 col = ~64px, 1 row = ~20px)
                const colWidthPixels = cellWidth * 7; // Approx width in pixels
                const xOffsetPixels = (colWidthPixels - imageSize) / 2; // Pixels of whitespace on left
                const colOffset = xOffsetPixels / colWidthPixels; // Ratio (0.0 to 1.0)

                const rowOffset = (cellHeight - imageSize) / 2 / 20;
                worksheet.addImage(imageId, {
                  tl: {
                    col: imageColIndex + colOffset,
                    row: i + 1 + rowOffset,
                  },
                  ext: { width: imageSize, height: imageSize },
                });
              } catch (e) {
                console.warn("Error adding image to Excel:", e);
                // If image fails, just leave the cell empty
              }
            }
          }

          // Generate buffer and download
          const buffer = await workbook.xlsx.writeBuffer();
          const blob = new Blob([buffer], {
            type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `my_vmk_furniture_${dateStr}.xlsx`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        };

        const exportToPDF = async (
          data,
          dateStr,
          imageBlobs,
          metadataOptions = {
            images: true,
            quantity: true,
            rarity: true,
            prices: true,
          }
        ) => {
          const { jsPDF } = window.jspdf;
          const doc = new jsPDF();

          // Set up PDF
          const pageWidth = doc.internal.pageSize.getWidth();
          const pageHeight = doc.internal.pageSize.getHeight();
          const margin = 15;
          const startY = 20;
          let currentY = startY;
          const imageSize = 25; // Size for thumbnail images
          const rowHeight = Math.max(
            8,
            metadataOptions.images ? imageSize + 4 : 8
          ); // Adjust row height for images
          const maxY = pageHeight - margin;

          // Title
          doc.setFontSize(16);
          doc.text("VMK Furniture Inventory", margin, currentY);
          currentY += 10;

          // Date
          doc.setFontSize(10);
          doc.setTextColor(100, 100, 100);
          doc.text(`Exported: ${dateStr}`, margin, currentY);
          currentY += 8;

          // Build headers and column widths based on metadata options
          const headers = [];
          const colWidths = [];
          let imageColWidth = 0;

          if (metadataOptions.images) {
            headers.push("Image");
            colWidths.push(30);
            imageColWidth = 30;
          }
          headers.push("Type");
          colWidths.push(25);
          headers.push("Name");
          colWidths.push(60);
          if (metadataOptions.quantity) {
            headers.push("Qty");
            colWidths.push(15);
          }
          if (metadataOptions.prices) {
            headers.push("Price");
            colWidths.push(20);
          }
          if (metadataOptions.rarity) {
            headers.push("Rarity");
            colWidths.push(25);
          }

          // Table headers
          doc.setFontSize(10);
          doc.setTextColor(0, 0, 0);
          doc.setFont(undefined, "bold");
          let xPos = margin;

          headers.forEach((header, idx) => {
            doc.text(header, xPos, currentY);
            xPos += colWidths[idx];
          });

          currentY += rowHeight;
          doc.setDrawColor(200, 200, 200);
          doc.line(margin, currentY, pageWidth - margin, currentY);
          currentY += 3;

          // Table rows with images
          doc.setFont(undefined, "normal");
          doc.setFontSize(8);

          for (let index = 0; index < data.length; index++) {
            const item = data[index];

            // Check if we need a new page
            if (currentY + rowHeight > maxY) {
              doc.addPage();
              currentY = startY;
            }

            xPos = margin;

            // Add image if available and images are enabled
            if (
              metadataOptions.images &&
              item.image &&
              imageBlobs.has(item.image)
            ) {
              try {
                const imageBlob = imageBlobs.get(item.image);
                const imageUrl = URL.createObjectURL(imageBlob);

                // Convert blob to base64 for PDF
                const reader = new FileReader();
                await new Promise((resolve, reject) => {
                  reader.onload = () => {
                    try {
                      const base64 = reader.result;
                      // Add image to PDF
                      doc.addImage(
                        base64,
                        "JPEG",
                        xPos,
                        currentY - imageSize + 2,
                        imageSize - 4,
                        imageSize - 4
                      );
                      URL.revokeObjectURL(imageUrl);
                      resolve();
                    } catch (e) {
                      console.warn("Error adding image to PDF:", e);
                      URL.revokeObjectURL(imageUrl);
                      resolve(); // Continue without image
                    }
                  };
                  reader.onerror = () => {
                    URL.revokeObjectURL(imageUrl);
                    resolve(); // Continue without image
                  };
                  reader.readAsDataURL(imageBlob);
                });
                xPos += imageColWidth; // Move past image column
              } catch (e) {
                console.warn("Error processing image for PDF:", e);
                if (metadataOptions.images) {
                  xPos += imageColWidth; // Move past image column even if image failed
                }
              }
            }

            // Build row data based on metadata options
            const rowData = [];
            let colWidthIndex = metadataOptions.images ? 1 : 0; // Start after image column if present

            rowData.push((item.type || item.id || "").substring(0, 15));
            rowData.push((item.name || "").substring(0, 25));
            colWidthIndex += 2; // Type and Name are always present

            if (metadataOptions.quantity) {
              rowData.push(String(item.quantity || 0));
            }
            if (metadataOptions.prices) {
              rowData.push(`$${item.price || 0}`);
            }
            if (metadataOptions.rarity) {
              rowData.push(
                (RARITY_MAP[item.rarity]?.label || "Common").substring(0, 12)
              );
            }

            rowData.forEach((cell, idx) => {
              doc.text(cell, xPos, currentY);
              xPos += colWidths[colWidthIndex + idx];
            });

            currentY += rowHeight;
          }

          // Save PDF
          doc.save(`my_vmk_furniture_${dateStr}.pdf`);
        };

        const exportToData = async (
          data,
          imageBlobs,
          metadataOptions = {
            images: true,
            quantity: true,
            rarity: true,
            prices: true,
          }
        ) => {
          try {
            const now = new Date();
            const currentDate = now.toLocaleString("en-US", {
              weekday: "long",
              year: "numeric",
              month: "long",
              day: "numeric",
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
              timeZoneName: "short",
            });
            const currentTimestamp = now.getTime();

            // Format data according to specification
            const exportData = data.map((item) => {
              const dataItem = {
                id: item.id || item.type || "",
                type: item.type || "",
                name: item.name || "Unknown Item",
              };

              // Only add image if images option is selected AND item has image
              if (metadataOptions.images && item.image) {
                dataItem.image = item.image;
              }

              // Only add count if quantity option is selected AND item has quantity
              if (
                metadataOptions.quantity &&
                item.quantity !== undefined &&
                item.quantity !== null
              ) {
                dataItem.count = item.quantity;
              }

              // Only add rarity if rarity option is selected AND item has rarity
              if (
                metadataOptions.rarity &&
                item.rarity !== undefined &&
                item.rarity !== null
              ) {
                dataItem.rarity = item.rarity;
              }

              // Only add price if prices option is selected AND item has price
              if (
                metadataOptions.prices &&
                item.price !== undefined &&
                item.price !== null
              ) {
                dataItem.price = item.price;
              }

              return dataItem;
            });

            // Create export object
            const exportObject = {
              timestamp: currentTimestamp,
              Date: currentDate,
              data: exportData,
            };

            // Create ZIP file
            const zip = new JSZip();

            // Add data file
            zip.file(
              "furniture_data.txt",
              JSON.stringify(exportObject, null, 2)
            );

            // Add images if images option is selected
            if (metadataOptions.images) {
              // Get set of image filenames that are actually used in the export
              const usedImageFilenames = new Set(
                exportData
                  .map((item) => item.image)
                  .filter((img) => img && img.trim() !== "")
              );

              // Add only the images that are used
              for (const [filename, blob] of imageBlobs.entries()) {
                if (usedImageFilenames.has(filename)) {
                  zip.file(filename, blob);
                }
              }
            }

            // Generate ZIP and download
            const zipBlob = await zip.generateAsync({ type: "blob" });
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement("a");
            a.href = url;
            const dateStr = now.toISOString().split("T")[0];
            a.download = `inventory_data_${dateStr}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log(
              `Exported ${exportData.length} items to inventory_data.txt with ${
                metadataOptions.images ? imageBlobs.size : 0
              } images.`
            );
          } catch (e) {
            console.error("Error exporting data:", e);
            throw e;
          }
        };

        // Filter items based on selected sublist and filters
        const displayItems = useMemo(() => {
          const baseItems = searchResults || data || [];

          // First filter by sublist if selected
          let filteredItems = baseItems;
          if (selectedSublistId) {
            const selectedSublist = sublists.find(
              (s) => s.id === selectedSublistId
            );
            if (
              selectedSublist &&
              selectedSublist.itemTypes &&
              selectedSublist.itemTypes.length > 0
            ) {
              filteredItems = filteredItems.filter(
                (item) =>
                  item.type && selectedSublist.itemTypes.includes(item.type)
              );
            } else {
              return [];
            }
          }

          // Apply filters
          return filteredItems.filter((item) => {
            // Rarity filter
            if (filters.rarities.length > 0) {
              if (!filters.rarities.includes(item.rarity)) {
                return false;
              }
            }

            // Quantity filter
            const quantity = item.quantity || 0;
            if (filters.quantityMode === "inStock") {
              if (quantity <= 0) return false;
            } else if (filters.quantityMode === "outOfStock") {
              if (quantity > 0) return false;
            } else if (filters.quantityMode === "all") {
              if (
                filters.quantityMin !== null &&
                quantity < filters.quantityMin
              ) {
                return false;
              }
              if (
                filters.quantityMax !== null &&
                quantity > filters.quantityMax
              ) {
                return false;
              }
            }

            // Price filter
            const price = item.price || 0;
            if (filters.hasPrice === true) {
              if (price <= 0) return false;
            } else if (filters.hasPrice === false) {
              if (price > 0) return false;
            }
            if (filters.priceMin !== null && price < filters.priceMin) {
              return false;
            }
            if (filters.priceMax !== null && price > filters.priceMax) {
              return false;
            }

            return true;
          });
        }, [searchResults, data, selectedSublistId, sublists, filters]);

        // Filter left panel items based on selected sublist and filters
        const leftPanelDisplayItems = useMemo(() => {
          if (!leftPanelData) return [];

          let filtered = leftPanelData;

          // Filter by search query
          if (leftPanelSearchQuery) {
            filtered = filtered.filter(
              (item) =>
                item.name
                  .toLowerCase()
                  .includes(leftPanelSearchQuery.toLowerCase()) ||
                (item.type &&
                  item.type
                    .toLowerCase()
                    .includes(leftPanelSearchQuery.toLowerCase()))
            );
          }

          // Filter by selected sublist
          if (leftPanelSelectedSublistId) {
            const selectedSublist = leftPanelSublists.find(
              (s) => s.id === leftPanelSelectedSublistId
            );
            if (
              selectedSublist &&
              selectedSublist.itemTypes &&
              selectedSublist.itemTypes.length > 0
            ) {
              filtered = filtered.filter(
                (item) =>
                  item.type && selectedSublist.itemTypes.includes(item.type)
              );
            } else {
              filtered = [];
            }
          }

          // Apply filters
          return filtered.filter((item) => {
            // Rarity filter
            if (leftPanelFilters.rarities.length > 0) {
              if (!leftPanelFilters.rarities.includes(item.rarity)) {
                return false;
              }
            }

            // Quantity filter
            const quantity = item.quantity || 0;
            if (leftPanelFilters.quantityMode === "inStock") {
              if (quantity <= 0) return false;
            } else if (leftPanelFilters.quantityMode === "outOfStock") {
              if (quantity > 0) return false;
            } else if (leftPanelFilters.quantityMode === "all") {
              if (
                leftPanelFilters.quantityMin !== null &&
                quantity < leftPanelFilters.quantityMin
              ) {
                return false;
              }
              if (
                leftPanelFilters.quantityMax !== null &&
                quantity > leftPanelFilters.quantityMax
              ) {
                return false;
              }
            }

            // Price filter
            const price = item.price || 0;
            if (leftPanelFilters.hasPrice === true) {
              if (price <= 0) return false;
            } else if (leftPanelFilters.hasPrice === false) {
              if (price > 0) return false;
            }
            if (
              leftPanelFilters.priceMin !== null &&
              price < leftPanelFilters.priceMin
            ) {
              return false;
            }
            if (
              leftPanelFilters.priceMax !== null &&
              price > leftPanelFilters.priceMax
            ) {
              return false;
            }

            return true;
          });
        }, [
          leftPanelData,
          leftPanelSearchQuery,
          leftPanelSelectedSublistId,
          leftPanelSublists,
          leftPanelFilters,
        ]);

        // Filter right panel items based on selected sublist and filters
        const rightPanelDisplayItems = useMemo(() => {
          if (!rightPanelData) return [];

          let filtered = rightPanelData;

          // Filter by search query
          if (rightPanelSearchQuery) {
            filtered = filtered.filter(
              (item) =>
                item.name
                  .toLowerCase()
                  .includes(rightPanelSearchQuery.toLowerCase()) ||
                (item.type &&
                  item.type
                    .toLowerCase()
                    .includes(rightPanelSearchQuery.toLowerCase()))
            );
          }

          // Filter by selected sublist
          if (rightPanelSelectedSublistId) {
            const selectedSublist = rightPanelSublists.find(
              (s) => s.id === rightPanelSelectedSublistId
            );
            if (
              selectedSublist &&
              selectedSublist.itemTypes &&
              selectedSublist.itemTypes.length > 0
            ) {
              filtered = filtered.filter(
                (item) =>
                  item.type && selectedSublist.itemTypes.includes(item.type)
              );
            } else {
              filtered = [];
            }
          }

          // Apply filters
          return filtered.filter((item) => {
            // Rarity filter
            if (rightPanelFilters.rarities.length > 0) {
              if (!rightPanelFilters.rarities.includes(item.rarity)) {
                return false;
              }
            }

            // Quantity filter
            const quantity = item.quantity || 0;
            if (rightPanelFilters.quantityMode === "inStock") {
              if (quantity <= 0) return false;
            } else if (rightPanelFilters.quantityMode === "outOfStock") {
              if (quantity > 0) return false;
            } else if (rightPanelFilters.quantityMode === "all") {
              if (
                rightPanelFilters.quantityMin !== null &&
                quantity < rightPanelFilters.quantityMin
              ) {
                return false;
              }
              if (
                rightPanelFilters.quantityMax !== null &&
                quantity > rightPanelFilters.quantityMax
              ) {
                return false;
              }
            }

            // Price filter
            const price = item.price || 0;
            if (rightPanelFilters.hasPrice === true) {
              if (price <= 0) return false;
            } else if (rightPanelFilters.hasPrice === false) {
              if (price > 0) return false;
            }
            if (
              rightPanelFilters.priceMin !== null &&
              price < rightPanelFilters.priceMin
            ) {
              return false;
            }
            if (
              rightPanelFilters.priceMax !== null &&
              price > rightPanelFilters.priceMax
            ) {
              return false;
            }

            return true;
          });
        }, [
          rightPanelData,
          rightPanelSearchQuery,
          rightPanelSelectedSublistId,
          rightPanelSublists,
          rightPanelFilters,
        ]);

        const activeInventory = inventories.find(
          (inv) => inv.id === activeInventoryId
        );

        return (
          <div className="flex flex-col h-screen w-full bg-slate-950 text-slate-100 font-sans overflow-hidden">
            {/* Top Bar */}
            <div className="bg-slate-900 border-b border-slate-800 px-6 py-4 flex items-center justify-between shadow-xl z-10 shrink-0 gap-4">
              <div className="flex items-center space-x-3 shrink-0">
                <img
                  src="./logo.png"
                  alt="Logo"
                  className="w-16 h-12 rounded-lg shadow-lg shadow-blue-900/20 object-contain bg-slate-800 border border-slate-700"
                  onError={(e) => {
                    e.target.style.display = "none";
                    e.target.nextSibling.style.display = "flex";
                  }}
                />
                <div className="hidden bg-blue-600 p-2 rounded-lg shadow-lg shadow-blue-900/20 items-center justify-center">
                  <Package className="text-white w-5 h-5" />
                </div>

                <div className="hidden md:block">
                  <h1 className="text-lg font-bold tracking-tight text-white">
                    Inventory Manager
                  </h1>
                  {username && (
                    <p className="text-xs text-slate-400 mt-0.5">{username}</p>
                  )}
                </div>
              </div>
              {/*only show buttons if inventory is open*/}
              {inventories.length > 0 && data && (
                <div className="flex items-center gap-4">
                  <div className="flex items-center gap-2">
                    <button
                      className={`p-2 rounded hover:bg-slate-800 transition ${
                        isSplitView
                          ? "text-blue-400 bg-slate-800"
                          : "text-slate-400"
                      }`}
                      onClick={() => {
                        handleToggleSplitView();
                        if (!rightPanelInventoryId && inventories.length > 1) {
                          const otherInventory = inventories.find(
                            (i) => i.id === activeInventoryId
                          );
                          if (otherInventory) {
                            handleRightPanelInventoryChange(otherInventory.id);
                          }
                        }
                      }}
                      title={
                        isSplitView ? "Close Split View" : "Open Split View"
                      }
                    >
                      <Split className="w-5 h-5" />
                    </button>

                    <SettingsMenu
                      handleSaveToDesktop={handleSaveToDesktop}
                      onClearManager={handleClearManager}
                      activeInventoryName={activeInventory?.name}
                    />
                  </div>
                </div>
              )}
            </div>

            {/* Tab Bar / Split Headers */}
            {inventories.length > 0 && (
              <div className="h-12 bg-slate-950 border-b border-slate-800 flex items-center shrink-0">
                {!isSplitView ? (
                  <div className="flex items-end px-2 gap-1 overflow-x-auto w-full h-full pb-0.5">
                    {openInventoryIds.map((tabId) => {
                      const inv = inventories.find((i) => i.id === tabId);
                      if (!inv) return null;
                      const itemCount = inventoryItemCounts.get(tabId) || 0;
                      return (
                        <div
                          key={tabId}
                          onClick={() => handleTabClick(tabId)}
                          className={`group relative px-4 py-2 min-w-[120px] max-w-[200px] text-sm cursor-pointer rounded-t-lg select-none flex items-center justify-between ${
                            activeInventoryId === tabId
                              ? "bg-slate-900 text-white border-t border-x border-slate-800"
                              : "bg-slate-900/30 text-slate-500 hover:bg-slate-900/50"
                          }`}
                        >
                          <span className="truncate mr-2">
                            {inv.name} ({itemCount.toLocaleString()})
                          </span>
                          <div className="relative">
                            <button
                              data-tab-menu-id={tabId}
                              onClick={(e) => {
                                e.stopPropagation();
                                const isOpening = openTabMenuId !== tabId;

                                if (isOpening) {
                                  // Calculate position synchronously before opening
                                  const rect =
                                    e.currentTarget.getBoundingClientRect();
                                  const menuWidth = 160; // min-w-[160px]
                                  const menuHeight = 80; // approximate height
                                  const spacing = 8; // spacing from button

                                  // Position below button, aligned to left
                                  // bottom is distance from bottom of viewport
                                  let bottom =
                                    window.innerHeight - rect.bottom - spacing;
                                  let left = rect.left;

                                  // Adjust if menu would go off bottom of screen (flip above)
                                  if (bottom < menuHeight) {
                                    bottom =
                                      window.innerHeight - rect.top + spacing;
                                  }

                                  // Adjust if menu would go off right edge
                                  if (left + menuWidth > window.innerWidth) {
                                    left = window.innerWidth - menuWidth - 8; // 8px padding from edge
                                  }

                                  // Ensure minimum padding from edges
                                  if (left < 8) left = 8;
                                  if (bottom < 8) bottom = 8;

                                  setMenuPosition({ bottom, left });
                                }

                                setOpenTabMenuId(isOpening ? tabId : null);
                              }}
                              className="tab-menu-button opacity-60 hover:opacity-100 hover:bg-slate-700 rounded p-0.5 transition-opacity"
                            >
                              <MoreVertical className="w-3 h-3" />
                            </button>
                            {openTabMenuId === tabId && (
                              <div
                                className="tab-context-menu fixed z-[9999] bg-slate-800 border border-slate-700 rounded-lg shadow-xl min-w-[160px] overflow-hidden"
                                style={{
                                  bottom: `${menuPosition.top}px`,
                                  left: `${menuPosition.left}px`,
                                }}
                                onClick={(e) => e.stopPropagation()}
                              >
                                <button
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handleExportSpecificInventory(tabId);
                                    setOpenTabMenuId(null);
                                  }}
                                  className="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700 flex items-center gap-2"
                                >
                                  <FileText className="w-4 h-4" />
                                  Export
                                </button>
                                <button
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    if (activeInventoryId === tabId) {
                                      setShowNewSublistModal(true);
                                    }
                                    setOpenTabMenuId(null);
                                  }}
                                  className="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700 flex items-center gap-2"
                                >
                                  <Plus className="w-4 h-4" />
                                  New sublist
                                </button>
                                <button
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handleTabClose(tabId);
                                    setOpenTabMenuId(null);
                                  }}
                                  className="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700 flex items-center gap-2"
                                >
                                  <X className="w-4 h-4" />
                                  Close inventory
                                </button>
                              </div>
                            )}
                          </div>
                        </div>
                      );
                    })}
                    <div className="relative">
                      <button
                        className="ml-2 px-3 py-2 text-base font-semibold text-slate-500 hover:text-blue-400 rounded-lg hover:bg-slate-800 transition-colors add-button-menu-button"
                        onClick={(e) => {
                          e.stopPropagation();
                          const rect = e.currentTarget.getBoundingClientRect();
                          const spacing = 4;
                          const menuHeight = 100; // Approximate menu height
                          const menuWidth = 180;

                          let top = rect.bottom + spacing;
                          let left = rect.left;

                          // Adjust if menu would go off bottom of screen (flip above)
                          if (top + menuHeight > window.innerHeight) {
                            top = rect.top - menuHeight - spacing;
                          }

                          // Adjust if menu would go off right edge
                          if (left + menuWidth > window.innerWidth) {
                            left = window.innerWidth - menuWidth - 8;
                          }

                          // Ensure minimum padding from edges
                          if (left < 8) left = 8;
                          if (top < 8) top = 8;

                          setAddButtonMenuPosition({ top, left });
                          setShowAddButtonMenu(true);
                        }}
                      >
                        +
                      </button>
                      {showAddButtonMenu && (
                        <div
                          className="add-button-menu fixed z-[9999] bg-slate-800 border border-slate-700 rounded-lg shadow-xl min-w-[180px] overflow-hidden"
                          style={{
                            top: `${addButtonMenuPosition.top}px`,
                            left: `${addButtonMenuPosition.left}px`,
                          }}
                          onClick={(e) => e.stopPropagation()}
                        >
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              setShowAddButtonMenu(false);
                              handleOpenInventory();
                            }}
                            className="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700 flex items-center gap-2"
                          >
                            <FolderOpen className="w-4 h-4" />
                            Open Inventory
                          </button>
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              setShowAddButtonMenu(false);
                              handleNewInventory();
                            }}
                            className="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700 flex items-center gap-2"
                          >
                            <Plus className="w-4 h-4" />
                            New Inventory
                          </button>
                        </div>
                      )}
                    </div>
                  </div>
                ) : (
                  <div className="w-full h-full flex">
                    <div className="w-1/2 flex items-center px-4 gap-3 border-r border-slate-800">
                      <div className="p-1.5 bg-blue-900/20 rounded-lg text-blue-400">
                        <Package className="w-4 h-4" />
                      </div>
                      <div className="relative flex-1">
                        <select
                          className="w-full bg-transparent font-bold text-sm uppercase tracking-wide text-slate-200 outline-none cursor-pointer appearance-none"
                          value={leftPanelInventoryId || ""}
                          onChange={(e) =>
                            handleLeftPanelInventoryChange(e.target.value)
                          }
                        >
                          {inventories.map((inv) => {
                            const itemCount =
                              inventoryItemCounts.get(inv.id) || 0;
                            return (
                              <option
                                key={inv.id}
                                value={inv.id}
                                className="bg-slate-900 text-slate-300 capitalize"
                              >
                                {inv.name} ({itemCount.toLocaleString()})
                              </option>
                            );
                          })}
                        </select>
                        <ChevronDown className="absolute right-0 top-1/2 -translate-y-1/2 w-4 h-4 text-slate-500 pointer-events-none" />
                      </div>
                    </div>
                    <div className="w-1/2 flex items-center px-4 gap-3">
                      <div className="p-1.5 bg-purple-900/20 rounded-lg text-purple-400">
                        <Package className="w-4 h-4" />
                      </div>
                      <div className="relative flex-1">
                        <select
                          className="w-full bg-transparent font-bold text-sm uppercase tracking-wide text-slate-200 outline-none cursor-pointer appearance-none"
                          value={rightPanelInventoryId || ""}
                          onChange={(e) =>
                            handleRightPanelInventoryChange(e.target.value)
                          }
                        >
                          {inventories.map((inv) => {
                            const itemCount =
                              inventoryItemCounts.get(inv.id) || 0;
                            return (
                              <option
                                key={inv.id}
                                value={inv.id}
                                className="bg-slate-900 text-slate-300 capitalize"
                              >
                                {inv.name} ({itemCount.toLocaleString()})
                              </option>
                            );
                          })}
                        </select>
                        <ChevronDown className="absolute right-0 top-1/2 -translate-y-1/2 w-4 h-4 text-slate-500 pointer-events-none" />
                      </div>
                    </div>
                  </div>
                )}
              </div>
            )}

            {!isSplitView ? (
              <>
                {/* Search Bar */}
                {activeInventoryId && inventories.length > 0 && (
                  <div className="bg-slate-900 border-b border-slate-800 px-6 py-3 flex items-center gap-4 shrink-0">
                    <div className="flex-1 relative group">
                      <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                        <Search
                          className={`w-4 h-4 ${
                            isSearching
                              ? "text-blue-400 animate-pulse"
                              : "text-slate-500"
                          }`}
                        />
                      </div>
                      <input
                        type="text"
                        className="block w-full pl-10 pr-10 py-2 border border-slate-700 rounded-xl leading-5 bg-slate-800 text-slate-300 placeholder-slate-500 focus:outline-none focus:bg-slate-900 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-all sm:text-sm"
                        placeholder={
                          embeddings
                            ? "Search (e.g. 'Office chair' finds 'Stool')"
                            : "Searching by text..."
                        }
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                      />
                      {searchQuery && (
                        <button
                          className="absolute inset-y-0 right-0 pr-3 flex items-center text-slate-500 hover:text-white"
                          onClick={() => setSearchQuery("")}
                        >
                          <X className="w-4 h-4" />
                        </button>
                      )}

                      {indexingProgress < 100 && indexingProgress > 0 && (
                        <div className="absolute -bottom-3 left-0 w-full h-1 bg-slate-800 rounded-full overflow-hidden">
                          <div
                            className="h-full bg-blue-500 transition-all duration-300"
                            style={{ width: `${indexingProgress}%` }}
                          />
                        </div>
                      )}
                    </div>
                    <button
                      onClick={() => {
                        setFilterModalPanel("single");
                        setShowFilterModal(true);
                      }}
                      className={`px-4 py-2 text-sm rounded-lg transition-colors flex items-center gap-2 ${
                        filters.rarities.length > 0 ||
                        filters.quantityMin !== null ||
                        filters.quantityMax !== null ||
                        filters.quantityMode !== "all" ||
                        filters.priceMin !== null ||
                        filters.priceMax !== null ||
                        filters.hasPrice !== null
                          ? "bg-blue-600 text-white hover:bg-blue-500"
                          : "text-slate-300 hover:text-white hover:bg-slate-800"
                      }`}
                      title="Filter items"
                    >
                      <Filter className="w-4 h-4" />
                      {filters.rarities.length > 0 ||
                      filters.quantityMin !== null ||
                      filters.quantityMax !== null ||
                      filters.quantityMode !== "all" ||
                      filters.priceMin !== null ||
                      filters.priceMax !== null ||
                      filters.hasPrice !== null ? (
                        <span className="text-xs bg-blue-700 px-1.5 py-0.5 rounded">
                          Active
                        </span>
                      ) : null}
                    </button>
                    <div className="relative">
                      <button
                        className="px-4 py-2 text-sm text-slate-300 hover:text-white hover:bg-slate-800 rounded-lg transition-colors flex items-center gap-2 add-button-menu-button"
                        onClick={(e) => {
                          e.stopPropagation();
                          const rect = e.currentTarget.getBoundingClientRect();
                          const spacing = 4;
                          const menuHeight = 50;
                          const menuWidth = 180;

                          let top = rect.bottom + spacing;
                          let left = rect.left;

                          if (top + menuHeight > window.innerHeight) {
                            top = rect.top - menuHeight - spacing;
                          }

                          if (left + menuWidth > window.innerWidth) {
                            left = window.innerWidth - menuWidth - 8;
                          }

                          if (left < 8) left = 8;
                          if (top < 8) top = 8;

                          setSearchBarMenuPosition({ top, left });
                          setShowSearchBarMenu(true);
                        }}
                        title="Import data"
                      >
                        <span className="text-lg">+</span>
                      </button>
                      {showSearchBarMenu && (
                        <div
                          className="add-button-menu fixed z-[9999] bg-slate-800 border border-slate-700 rounded-lg shadow-xl min-w-[180px] overflow-hidden"
                          style={{
                            top: `${searchBarMenuPosition.top}px`,
                            left: `${searchBarMenuPosition.left}px`,
                          }}
                          onClick={(e) => e.stopPropagation()}
                        >
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              setShowSearchBarMenu(false);
                              handleImportData();
                            }}
                            className="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700 flex items-center gap-2"
                          >
                            <FileText className="w-4 h-4" />
                            Import data
                          </button>
                        </div>
                      )}
                    </div>
                  </div>
                )}

                {/* Sublist Selector */}
                {activeInventoryId && inventories.length > 0 && (
                  <div className="px-3 py-1 bg-slate-900 border-b border-slate-800 flex items-center shrink-0">
                    <span className="text-[10px] text-slate-500 uppercase font-bold mr-2">
                      View:
                    </span>
                    <select
                      value={selectedSublistId || ""}
                      onChange={(e) =>
                        setSelectedSublistId(e.target.value || null)
                      }
                      className="bg-transparent text-xs text-slate-300 outline-none hover:text-white cursor-pointer"
                    >
                      <option value="">Main List</option>
                      {sublists.map((sublist) => (
                        <option key={sublist.id} value={sublist.id}>
                          {sublist.name}
                        </option>
                      ))}
                    </select>
                  </div>
                )}

                <div className="flex-1 overflow-hidden relative flex flex-col">
                  {isLoadingFromDB ? (
                    <div className="flex flex-col items-center justify-center h-full space-y-4 text-slate-400">
                      <RefreshCw className="w-8 h-8 animate-spin" />
                      <span>Loading saved data...</span>
                    </div>
                  ) : inventories.length === 0 || !data ? (
                    <FileUploader
                      onDataLoaded={handleDataLoaded}
                      hasExistingData={hasStoredData || inventories.length > 0}
                    />
                  ) : (
                    <>
                      <div className="flex items-center bg-slate-900/80 backdrop-blur border-b border-slate-800 px-4 py-3 text-xs font-bold text-slate-500 uppercase tracking-wider shrink-0 select-none">
                        <div className="w-12">#</div>
                        <div className="w-20 text-center">Preview</div>
                        <div className="flex-1 px-4">
                          Item Details{" "}
                          {searchQuery && `(Found ${displayItems.length})`}
                        </div>
                        <div className="w-28 px-2">Stock</div>
                        <div className="w-32 px-2">Price</div>
                        <div className="w-36 px-2">Rarity</div>
                      </div>
                      <VirtualList
                        items={displayItems}
                        imageMap={imageMap}
                        onUpdateItem={handleUpdateItem}
                        onReplaceImage={handleReplaceImage}
                        onTransferItem={handleTransferItem}
                        onAddToSublist={handleAddToSublistClick}
                        isSublist={!!selectedSublistId}
                      />
                    </>
                  )}
                </div>
              </>
            ) : (
              /* Split View */
              <>
                {/* Split View Panels */}
                <div className="flex-1 flex overflow-hidden">
                  {/* Left Panel */}
                  <div className="flex-1 flex flex-col border-r border-slate-800">
                    {/* Left Search Bar */}
                    {leftPanelInventoryId && (
                      <div className="bg-slate-900 border-b border-slate-800 px-4 py-2 flex items-center gap-2 shrink-0">
                        <div className="flex-1 relative">
                          <div className="absolute inset-y-0 left-0 pl-2 flex items-center pointer-events-none">
                            <Search className="w-4 h-4 text-slate-500" />
                          </div>
                          <input
                            type="text"
                            className="w-full pl-8 pr-8 py-1.5 border border-slate-700 rounded-lg bg-slate-800 text-slate-300 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="Search..."
                            value={leftPanelSearchQuery}
                            onChange={(e) =>
                              setLeftPanelSearchQuery(e.target.value)
                            }
                          />
                          {leftPanelSearchQuery && (
                            <button
                              className="absolute inset-y-0 right-0 pr-2 flex items-center text-slate-500 hover:text-white"
                              onClick={() => setLeftPanelSearchQuery("")}
                            >
                              <X className="w-4 h-4" />
                            </button>
                          )}
                        </div>
                        <button
                          onClick={() => {
                            setFilterModalPanel("left");
                            setShowFilterModal(true);
                          }}
                          className={`px-3 py-1.5 text-sm rounded-lg transition-colors flex items-center gap-1.5 ${
                            leftPanelFilters.rarities.length > 0 ||
                            leftPanelFilters.quantityMin !== null ||
                            leftPanelFilters.quantityMax !== null ||
                            leftPanelFilters.quantityMode !== "all" ||
                            leftPanelFilters.priceMin !== null ||
                            leftPanelFilters.priceMax !== null ||
                            leftPanelFilters.hasPrice !== null
                              ? "bg-blue-600 text-white hover:bg-blue-500"
                              : "text-slate-300 hover:text-white hover:bg-slate-800"
                          }`}
                          title="Filter items"
                        >
                          <Filter className="w-4 h-4" />
                          {leftPanelFilters.rarities.length > 0 ||
                          leftPanelFilters.quantityMin !== null ||
                          leftPanelFilters.quantityMax !== null ||
                          leftPanelFilters.quantityMode !== "all" ||
                          leftPanelFilters.priceMin !== null ||
                          leftPanelFilters.priceMax !== null ||
                          leftPanelFilters.hasPrice !== null ? (
                            <span className="text-xs bg-blue-700 px-1 py-0.5 rounded">
                              Active
                            </span>
                          ) : null}
                        </button>
                        <button
                          onClick={() => {
                            /* TODO: Upload to left panel */
                          }}
                          className="px-3 py-1.5 text-sm text-slate-300 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                          title="Upload items"
                        >
                          +
                        </button>
                      </div>
                    )}
                    {/* Left Sublist Selector */}
                    {leftPanelInventoryId && (
                      <div className="px-3 py-1 bg-slate-900 border-b border-slate-800 flex items-center shrink-0">
                        <span className="text-[10px] text-slate-500 uppercase font-bold mr-2">
                          View:
                        </span>
                        <select
                          value={leftPanelSelectedSublistId || ""}
                          onChange={(e) =>
                            setLeftPanelSelectedSublistId(
                              e.target.value || null
                            )
                          }
                          className="bg-transparent text-xs text-slate-300 outline-none hover:text-white cursor-pointer"
                        >
                          <option value="">Main List</option>
                          {leftPanelSublists.map((sublist) => (
                            <option key={sublist.id} value={sublist.id}>
                              {sublist.name}
                            </option>
                          ))}
                        </select>
                      </div>
                    )}
                    {/* Left Item List */}
                    <div className="flex-1 overflow-y-auto relative flex flex-col">
                      {leftPanelData && leftPanelData.length > 0 ? (
                        <>
                          <div className="flex items-center bg-slate-900/80 backdrop-blur border-b border-slate-800 px-4 py-3 text-xs font-bold text-slate-500 uppercase tracking-wider shrink-0 select-none sticky top-0 z-10">
                            <div className="w-12">#</div>
                            <div className="w-20 text-center">Preview</div>
                            <div className="flex-1 px-4">Item Details</div>
                            <div className="w-28 px-2">Stock</div>
                          </div>
                          <VirtualList
                            items={leftPanelDisplayItems}
                            imageMap={imageMap}
                            onUpdateItem={() => {}}
                            onReplaceImage={() => {}}
                            onTransferItem={(item) => {
                              setTransferItem({
                                ...item,
                                inventoryId: leftPanelInventoryId,
                              });
                              setShowTransferModal(true);
                            }}
                            onAddToSublist={handleAddToSublistClick}
                            isSublist={!!leftPanelSelectedSublistId}
                          />
                        </>
                      ) : (
                        <div className="flex items-center justify-center h-full text-slate-500 text-sm">
                          No items
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Right Panel */}
                  <div className="flex-1 flex flex-col">
                    {/* Right Search Bar */}
                    {rightPanelInventoryId && (
                      <div className="bg-slate-900 border-b border-slate-800 px-4 py-2 flex items-center gap-2 shrink-0">
                        <div className="flex-1 relative">
                          <div className="absolute inset-y-0 left-0 pl-2 flex items-center pointer-events-none">
                            <Search className="w-4 h-4 text-slate-500" />
                          </div>
                          <input
                            type="text"
                            className="w-full pl-8 pr-8 py-1.5 border border-slate-700 rounded-lg bg-slate-800 text-slate-300 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="Search..."
                            value={rightPanelSearchQuery}
                            onChange={(e) =>
                              setRightPanelSearchQuery(e.target.value)
                            }
                          />
                          {rightPanelSearchQuery && (
                            <button
                              className="absolute inset-y-0 right-0 pr-2 flex items-center text-slate-500 hover:text-white"
                              onClick={() => setRightPanelSearchQuery("")}
                            >
                              <X className="w-4 h-4" />
                            </button>
                          )}
                        </div>
                        <button
                          onClick={() => {
                            setFilterModalPanel("right");
                            setShowFilterModal(true);
                          }}
                          className={`px-3 py-1.5 text-sm rounded-lg transition-colors flex items-center gap-1.5 ${
                            rightPanelFilters.rarities.length > 0 ||
                            rightPanelFilters.quantityMin !== null ||
                            rightPanelFilters.quantityMax !== null ||
                            rightPanelFilters.quantityMode !== "all" ||
                            rightPanelFilters.priceMin !== null ||
                            rightPanelFilters.priceMax !== null ||
                            rightPanelFilters.hasPrice !== null
                              ? "bg-blue-600 text-white hover:bg-blue-500"
                              : "text-slate-300 hover:text-white hover:bg-slate-800"
                          }`}
                          title="Filter items"
                        >
                          <Filter className="w-4 h-4" />
                          {rightPanelFilters.rarities.length > 0 ||
                          rightPanelFilters.quantityMin !== null ||
                          rightPanelFilters.quantityMax !== null ||
                          rightPanelFilters.quantityMode !== "all" ||
                          rightPanelFilters.priceMin !== null ||
                          rightPanelFilters.priceMax !== null ||
                          rightPanelFilters.hasPrice !== null ? (
                            <span className="text-xs bg-blue-700 px-1 py-0.5 rounded">
                              Active
                            </span>
                          ) : null}
                        </button>
                        <button
                          onClick={() => {
                            /* TODO: Upload to right panel */
                          }}
                          className="px-3 py-1.5 text-sm text-slate-300 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                          title="Upload items"
                        >
                          +
                        </button>
                      </div>
                    )}
                    {/* Right Sublist Selector */}
                    {rightPanelInventoryId && (
                      <div className="px-3 py-1 bg-slate-900 border-b border-slate-800 flex items-center shrink-0">
                        <span className="text-[10px] text-slate-500 uppercase font-bold mr-2">
                          View:
                        </span>
                        <select
                          value={rightPanelSelectedSublistId || ""}
                          onChange={(e) =>
                            setRightPanelSelectedSublistId(
                              e.target.value || null
                            )
                          }
                          className="bg-transparent text-xs text-slate-300 outline-none hover:text-white cursor-pointer"
                        >
                          <option value="">Main List</option>
                          {rightPanelSublists.map((sublist) => (
                            <option key={sublist.id} value={sublist.id}>
                              {sublist.name}
                            </option>
                          ))}
                        </select>
                      </div>
                    )}
                    {/* Right Item List */}
                    <div className="flex-1 overflow-y-auto relative flex flex-col min-h-0">
                      {rightPanelData && rightPanelData.length > 0 ? (
                        <>
                          <div className="flex items-center bg-slate-900/80 backdrop-blur border-b border-slate-800 px-4 py-3 text-xs font-bold text-slate-500 uppercase tracking-wider shrink-0 select-none sticky top-0 z-10">
                            <div className="w-12">#</div>
                            <div className="w-20 text-center">Preview</div>
                            <div className="flex-1 px-4">Item Details</div>
                            <div className="w-28 px-2">Stock</div>
                          </div>
                          <VirtualList
                            items={rightPanelDisplayItems}
                            imageMap={imageMap}
                            onUpdateItem={() => {}}
                            onReplaceImage={() => {}}
                            onTransferItem={(item) => {
                              setTransferItem({
                                ...item,
                                inventoryId: rightPanelInventoryId,
                              });
                              setShowTransferModal(true);
                            }}
                            onAddToSublist={handleAddToSublistClick}
                            isSublist={!!rightPanelSelectedSublistId}
                          />
                        </>
                      ) : (
                        <div className="flex items-center justify-center h-full text-slate-500 text-sm">
                          No items
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </>
            )}

            <Modal
              isOpen={showFirstClearModal}
              onClose={() => setShowFirstClearModal(false)}
              title="Clear Manager?"
              message="This will clear your inventory manager. Make sure you have already saved a copy to your Desktop."
              onConfirm={handleFirstClearConfirm}
              confirmText="Next"
              cancelText="Cancel"
              isCritical={true}
            />

            <Modal
              isOpen={showSecondClearModal}
              onClose={() => setShowSecondClearModal(false)}
              title="Confirm"
              message="Are you sure you want to clear your inventory manager? This cannot be undone!"
              onConfirm={handleSecondClearConfirm}
              confirmText="Confirm"
              cancelText="Cancel"
              isCritical={true}
            />

            <ExportFormatModal
              isOpen={showExportFormatModal}
              onClose={() => setShowExportFormatModal(false)}
              onSelectFormat={handleExportFormat}
              hasSublistSelected={hasSublistSelected}
            />

            <Modal
              isOpen={showUpdateConfirmModal}
              onClose={() => {
                setShowUpdateConfirmModal(false);
                setPendingUpdateData(null);
              }}
              title="Upload new extraction"
              message="This will update quantities for existing items and/or add any new or missing items."
              onConfirm={handleUpdateInventoryConfirm}
              confirmText="Confirm"
              cancelText="Cancel"
            />

            <Modal
              isOpen={showSaveToDesktopModal}
              onClose={() => setShowSaveToDesktopModal(false)}
              title="Save to Desktop"
              message="this will save a local copy of the Inventory Manager to your desktop, continue?"
              onConfirm={handleSaveToDesktopConfirm}
              confirmText="Save"
              cancelText="Cancel"
            />

            {/* Hidden file input for update inventory */}
            <input
              ref={updateInventoryInputRef}
              type="file"
              style={{ display: "none" }}
              webkitdirectory=""
              directory=""
              onChange={handleUpdateInventoryFileSelect}
            />

            {/* Hidden directory input for importing data */}
            <input
              ref={importDataInputRef}
              type="file"
              webkitdirectory=""
              directory=""
              style={{ display: "none" }}
              onChange={handleImportFileSelect}
            />

            {/* Modals */}
            <NewInventoryModal
              isOpen={showNewInventoryModal}
              onClose={() => setShowNewInventoryModal(false)}
              onCreate={handleCreateInventory}
              onUploadData={handleCreateInventoryWithData}
            />

            <OpenInventoryModal
              isOpen={showOpenInventoryModal}
              onClose={() => setShowOpenInventoryModal(false)}
              inventories={inventories}
              openInventoryIds={openInventoryIds}
              onOpenInventory={handleOpenInventoryTab}
            />

            <ExportInventoryModal
              isOpen={showExportInventoryModal}
              onClose={() => {
                setShowExportInventoryModal(false);
                setPendingExportInventoryId(null);
                setPendingExportTabInventoryId(null);
              }}
              preSelectedId={pendingExportInventoryId}
              tabInventoryId={pendingExportTabInventoryId}
              inventories={inventories}
              sublists={sublists}
              onExport={handleExportInventories}
            />

            <TransferItemModal
              isOpen={showTransferModal}
              onClose={() => {
                setShowTransferModal(false);
                setTransferItem(null);
              }}
              item={transferItem}
              sourceInventoryId={transferItem?.inventoryId || activeInventoryId}
              inventories={inventories}
              imageMap={imageMap}
              onTransfer={handleTransfer}
            />

            <FilterModal
              isOpen={showFilterModal}
              onClose={() => {
                setShowFilterModal(false);
                setFilterModalPanel(null);
              }}
              filters={
                filterModalPanel === "left"
                  ? leftPanelFilters
                  : filterModalPanel === "right"
                  ? rightPanelFilters
                  : filters
              }
              onFiltersChange={
                filterModalPanel === "left"
                  ? setLeftPanelFilters
                  : filterModalPanel === "right"
                  ? setRightPanelFilters
                  : setFilters
              }
              panel={filterModalPanel}
            />

            <NewSublistModal
              isOpen={showNewSublistModal}
              onClose={() => setShowNewSublistModal(false)}
              onCreate={handleCreateSublist}
            />

            <AddToSublistModal
              isOpen={showAddToSublistModal}
              onClose={() => {
                setShowAddToSublistModal(false);
                setItemToAddToSublist(null);
              }}
              sublists={[
                ...sublists,
                ...(isSplitView ? leftPanelSublists : []),
                ...(isSplitView ? rightPanelSublists : []),
              ].filter(
                (s, index, self) =>
                  index === self.findIndex((t) => t.id === s.id)
              )}
              item={itemToAddToSublist}
              imageMap={imageMap}
              onAdd={handleAddItemToSublist}
            />

            <ConflictsResolutionModal
              isOpen={showConflictsModal}
              onClose={() => {
                setShowConflictsModal(false);
                setConflictsData(null);
              }}
              conflicts={conflictsData?.conflicts || []}
              imageMap={conflictsData?.mergedImageMap || imageMap}
              loadedUrlMap={conflictsData?.loadedUrlMap}
              onApply={handleApplyConflictsResolutions}
            />

            {/* Buy Me a Coffee Modal */}
            {showBuyMeACoffeeModal && (
              <div
                className="fixed inset-0 z-[100] flex items-center justify-center bg-white/30"
                onClick={(e) => {
                  // Close when clicking backdrop
                  if (e.target === e.currentTarget) {
                    const today = new Date().toDateString();
                    localStorage.setItem(
                      "buyMeACoffeeModalDismissedDate",
                      today
                    );
                    setShowBuyMeACoffeeModal(false);
                  }
                }}
              >
                <div
                  className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl relative"
                  onClick={(e) => e.stopPropagation()}
                >
                  {/* Close Button */}
                  <button
                    onClick={() => {
                      const today = new Date().toDateString();
                      localStorage.setItem(
                        "buyMeACoffeeModalDismissedDate",
                        today
                      );
                      setShowBuyMeACoffeeModal(false);
                    }}
                    className="absolute top-4 right-4 p-2 text-slate-400 hover:text-slate-200 rounded hover:bg-slate-800 transition-colors"
                    aria-label="Close"
                  >
                    <X className="w-5 h-5" />
                  </button>

                  {/* Content */}
                  <div className="text-center mb-6">
                    <h2 className="text-2xl text-white mb-2">
                      Support my craft
                    </h2>
                    <p className="text-slate-300 text-sm">
                      If you find this tool helpful, consider supporting me
                      with a coffee (:
                    </p>
                  </div>

                  {/* Buy Me a Coffee Widget */}
                  <div className="flex justify-center">
                    <a
                      href="https://www.buymeacoffee.com/bertogz"
                      target="_blank"
                      rel="noopener noreferrer"
                      className="inline-block transition-transform hover:scale-105"
                    >
                      <img
                        src="https://img.buymeacoffee.com/button-api/?text=Buy me a coffee&emoji=&slug=bertogz&button_colour=FFDD00&font_colour=000000&font_family=Cookie&outline_colour=000000&coffee_colour=ffffff"
                        alt="Buy Me a Coffee"
                        className="max-w-full h-auto"
                      />
                    </a>
                  </div>
                  
                  <p className="text-center text-slate-400 text-xs mt-4">
                    Fuel for the next project
                  </p>
                </div>
              </div>
            )}

            <LoadingOverlay isVisible={isExporting} message="Exporting..." />
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
