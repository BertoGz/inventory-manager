<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory Manager + AI</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for in-browser JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- JSZip for ZIP export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- SheetJS for Excel export (fallback) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- ExcelJS for Excel export with image support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>

    <!-- jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- sql.js for SQLite database creation -->
    <script src="https://cdn.jsdelivr.net/npm/sql.js@1.10.3/dist/sql-wasm.js"></script>

    <!-- Transformers.js (AI Model) -->
    <script type="module">
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.0';
        
        // Skip local model checks since we are in a browser without a file system
        env.allowLocalModels = false;
        
        // Attach to window so our React app can use it
        window.pipeline = pipeline;
        window.transformersLoaded = true;
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #0f172a;
        }

        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 5px;
            border: 2px solid #0f172a;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #475569;
        }

        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* Optimization for large lists */
        /* .virtual-scroller - content-visibility: auto; removed to prevent empty view issues */

        /* Animations */
        @keyframes pulse-subtle {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .animate-pulse-subtle {
            animation: pulse-subtle 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>

<body class="bg-slate-950 text-slate-100 overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- Icons ---
        const IconBase = ({ children, className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const FolderOpen = (props) => (
            <IconBase {...props}><path d="m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-3.25 7a2 2 0 0 1-1.94 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2" /></IconBase>
        );
        const Package = (props) => (
            <IconBase {...props}><path d="m7.5 4.27 9 5.15" /><path d="M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z" /><path d="m3.3 7 8.7 5 8.7-5" /><path d="M12 22v-9" /></IconBase>
        );
        const Save = (props) => (
            <IconBase {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" /><polyline points="17 21 17 13 7 13 7 21" /><polyline points="7 3 7 8 15 8" /></IconBase>
        );
        const AlertCircle = (props) => (
            <IconBase {...props}><circle cx="12" cy="12" r="10" /><line x1="12" x2="12" y1="8" y2="12" /><line x1="12" x2="12.01" y1="16" y2="16" /></IconBase>
        );
        const ImageIcon = (props) => (
            <IconBase {...props}><rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><circle cx="9" cy="9" r="2" /><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" /></IconBase>
        );
        const RefreshCw = (props) => (
            <IconBase {...props}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" /><path d="M21 3v5h-5" /><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" /><path d="M8 16H3v5" /></IconBase>
        );
        const Search = (props) => (
            <IconBase {...props}><circle cx="11" cy="11" r="8" /><path d="m21 21-4.3-4.3" /></IconBase>
        );
        const Brain = (props) => (
            <IconBase {...props}><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z" /><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z" /></IconBase>
        );
        const X = (props) => (
            <IconBase {...props}><path d="M18 6 6 18" /><path d="m6 6 12 12" /></IconBase>
        );
        const ChevronDown = (props) => (
            <IconBase {...props}><path d="m6 9 6 6 6-6" /></IconBase>
        );

        // --- Constants & Helpers ---

        const ROW_HEIGHT = 80; 
        const BUFFER_ITEMS = 5; 

        const RARITY_MAP = {
            0: { label: "unset", color: "text-gray-400 border-gray-600 bg-gray-800" },
            1: { label: "Common", color: "text-gray-400 border-gray-600 bg-gray-800" },
            2: { label: "Rare", color: "text-blue-400 border-blue-600 bg-blue-900/20" },
            3: { label: "Ultra Rare", color: "text-purple-400 border-purple-600 bg-purple-900/20" },
        };

        function cosineSimilarity(a, b) {
            let dot = 0;
            for (let i = 0; i < a.length; i++) {
                dot += a[i] * b[i];
            }
            let magA = 0, magB = 0;
            for (let i = 0; i < a.length; i++) magA += a[i] * a[i];
            for (let i = 0; i < b.length; i++) magB += b[i] * b[i];
            
            return dot / (Math.sqrt(magA) * Math.sqrt(magB));
        }

        // --- IndexedDB Helpers ---
        const DB_NAME = 'vmkInventoryDB';
        const DB_VERSION = 4; // Bumped version to change keyPath from 'id' to 'type'
        const STORE_ITEMS = 'items';
        const STORE_IMAGES = 'images';
        const STORE_METADATA = 'metadata';
        const STORE_EMBEDDINGS = 'embeddings';

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // --- VERSION 4 MIGRATION: Switch from 'id' to 'type' ---
                    // If upgrading from an older version, we must delete the old stores 
                    // because we cannot change keyPath in-place.
                    if (event.oldVersion < 4) {
                        if (db.objectStoreNames.contains(STORE_ITEMS)) {
                            db.deleteObjectStore(STORE_ITEMS);
                        }
                        if (db.objectStoreNames.contains(STORE_EMBEDDINGS)) {
                            db.deleteObjectStore(STORE_EMBEDDINGS);
                        }
                    }
                    
                    if (!db.objectStoreNames.contains(STORE_ITEMS)) {
                        // KEY CHANGE: keyPath is now 'type'
                        db.createObjectStore(STORE_ITEMS, { keyPath: 'type' });
                    }
                    if (!db.objectStoreNames.contains(STORE_IMAGES)) {
                        db.createObjectStore(STORE_IMAGES, { keyPath: 'filename' });
                    }
                    if (!db.objectStoreNames.contains(STORE_METADATA)) {
                        db.createObjectStore(STORE_METADATA, { keyPath: 'key' });
                    }
                    if (!db.objectStoreNames.contains(STORE_EMBEDDINGS)) {
                         // KEY CHANGE: keyPath is now 'type' to match items
                        db.createObjectStore(STORE_EMBEDDINGS, { keyPath: 'type' });
                    }
                };
            });
        }

        // 1. Separate saving Images (Heavy) - Now merges instead of clearing
        async function saveImagesToIndexedDB(imageFileMap, existingImageMap = null) {
            try {
                const db = await openDB();
                const tx = db.transaction([STORE_IMAGES], 'readwrite');
                const imagesStore = tx.objectStore(STORE_IMAGES);
                
                // Only save new images (merge, don't clear)
                let newCount = 0;
                for (const [filename, fileObj] of imageFileMap.entries()) {
                    // Check if image already exists (by filename)
                    if (!existingImageMap || !existingImageMap.has(filename)) {
                        imagesStore.put({ filename, blob: fileObj });
                        newCount++;
                    }
                }

                await new Promise((resolve, reject) => {
                    tx.oncomplete = () => {
                        if (newCount > 0) {
                            console.log(`Saved ${newCount} new images to IndexedDB.`);
                        }
                        resolve();
                    };
                    tx.onerror = () => reject(tx.error);
                    tx.onabort = () => reject(new Error("Image transaction aborted"));
                });
            } catch (e) {
                console.error("Failed to save images:", e);
                throw e;
            }
        }

        // 2. Efficient Data Saver - Now merges instead of clearing
        async function saveDataToIndexedDB(items, metadata) {
            try {
                if (!items || items.length === 0) {
                    console.warn("Attempted to save empty items list to DB");
                    return;
                }

                const db = await openDB();
                const tx = db.transaction([STORE_ITEMS, STORE_METADATA], 'readwrite');
                
                // Save items (merge, don't clear)
                const itemsStore = tx.objectStore(STORE_ITEMS);
                
                let putCount = 0;
                items.forEach(item => {
                    try {
                        itemsStore.put(item);
                        putCount++;
                    } catch (err) {
                        console.error("Error putting item:", item, err);
                    }
                });

                // Save metadata
                if (metadata) {
                    const metadataStore = tx.objectStore(STORE_METADATA);
                    metadataStore.put({ key: 'extraction', ...metadata });
                }

                await new Promise((resolve, reject) => {
                    tx.oncomplete = () => {
                        console.log(`Successfully saved ${putCount} items to DB.`);
                        resolve();
                    };
                    tx.onerror = () => reject(tx.error);
                    tx.onabort = () => reject(new Error("Data transaction aborted"));
                });
            } catch (e) {
                console.error("Failed to save data:", e);
                throw e;
            }
        }

        // 3. Save Embeddings to IndexedDB
        async function saveEmbeddingsToIndexedDB(embeddingsMap) {
            try {
                if (!embeddingsMap || embeddingsMap.size === 0) return;

                const db = await openDB();
                const tx = db.transaction([STORE_EMBEDDINGS], 'readwrite');
                const embeddingsStore = tx.objectStore(STORE_EMBEDDINGS);
                
                let savedCount = 0;
                for (const [itemType, vector] of embeddingsMap.entries()) {
                    try {
                        embeddingsStore.put({ type: itemType, vector: Array.from(vector) });
                        savedCount++;
                    } catch (err) {
                        console.error("Error saving embedding for item:", itemType, err);
                    }
                }

                await new Promise((resolve, reject) => {
                    tx.oncomplete = () => {
                        if (savedCount > 0) {
                            console.log(`Saved ${savedCount} embeddings to IndexedDB.`);
                        }
                        resolve();
                    };
                    tx.onerror = () => reject(tx.error);
                    tx.onabort = () => reject(new Error("Embeddings transaction aborted"));
                });
            } catch (e) {
                console.error("Failed to save embeddings:", e);
                throw e;
            }
        }

        // 4. Load Embeddings from IndexedDB
        async function loadEmbeddingsFromIndexedDB() {
            try {
                const db = await openDB();
                const tx = db.transaction([STORE_EMBEDDINGS], 'readonly');
                const embeddingsStore = tx.objectStore(STORE_EMBEDDINGS);
                
                const embeddingsRecords = await new Promise((resolve, reject) => {
                    const req = embeddingsStore.getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });

                // Convert to Map: itemType -> vector array
                const embeddingsMap = new Map();
                for (const record of embeddingsRecords) {
                    embeddingsMap.set(record.type, record.vector);
                }

                return embeddingsMap;
            } catch (e) {
                console.error('Error loading embeddings from IndexedDB:', e);
                return new Map();
            }
        }

        async function loadFromIndexedDB() {
            try {
                const db = await openDB();
                const tx = db.transaction([STORE_ITEMS, STORE_IMAGES, STORE_METADATA, STORE_EMBEDDINGS], 'readonly');
                
                // Load items
                const itemsStore = tx.objectStore(STORE_ITEMS);
                const items = await new Promise((resolve, reject) => {
                    const req = itemsStore.getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });

                // Load images
                const imagesStore = tx.objectStore(STORE_IMAGES);
                const imageRecords = await new Promise((resolve, reject) => {
                    const req = imagesStore.getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });

                // Convert image blobs back to object URLs
                const imageMap = new Map();
                for (const record of imageRecords) {
                    imageMap.set(record.filename, URL.createObjectURL(record.blob));
                }

                // Load metadata
                const metadataStore = tx.objectStore(STORE_METADATA);
                const metadataRecord = await new Promise((resolve, reject) => {
                    const req = metadataStore.get('extraction');
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });

                const metadata = metadataRecord ? { 
                    timestamp: metadataRecord.timestamp, 
                    Date: metadataRecord.Date 
                } : null;

                // Load embeddings
                const embeddingsStore = tx.objectStore(STORE_EMBEDDINGS);
                const embeddingsRecords = await new Promise((resolve, reject) => {
                    const req = embeddingsStore.getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });

                // Convert embeddings to Map: itemType -> vector array
                const embeddingsMap = new Map();
                for (const record of embeddingsRecords) {
                    embeddingsMap.set(record.type, record.vector);
                }

                return { items, imageMap, metadata, embeddingsMap };
            } catch (e) {
                console.error('Error loading from IndexedDB:', e);
                return { items: [], imageMap: new Map(), metadata: null, embeddingsMap: new Map() };
            }
        }

        async function clearIndexedDB() {
            try {
                const db = await openDB();
                const tx = db.transaction([STORE_ITEMS, STORE_IMAGES, STORE_METADATA, STORE_EMBEDDINGS], 'readwrite');
                await tx.objectStore(STORE_ITEMS).clear();
                await tx.objectStore(STORE_IMAGES).clear();
                await tx.objectStore(STORE_METADATA).clear();
                await tx.objectStore(STORE_EMBEDDINGS).clear();
                await new Promise((resolve, reject) => {
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            } catch (e) {
                console.error('Error clearing IndexedDB:', e);
            }
        }

        // Get images from IndexedDB as blobs for export
        async function getImagesFromIndexedDB() {
            try {
                const db = await openDB();
                const tx = db.transaction([STORE_IMAGES], 'readonly');
                const imagesStore = tx.objectStore(STORE_IMAGES);
                const imageRecords = await new Promise((resolve, reject) => {
                    const req = imagesStore.getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });

                // Return Map of filename -> blob
                const imageMap = new Map();
                for (const record of imageRecords) {
                    imageMap.set(record.filename, record.blob);
                }
                return imageMap;
            } catch (e) {
                console.error('Error getting images from IndexedDB:', e);
                return new Map();
            }
        }

        // --- Components ---

        const Modal = ({ isOpen, onClose, title, message, onConfirm, confirmText = "Confirm", cancelText = "Cancel" }) => {
            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm" onClick={onClose}>
                    <div className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl" onClick={(e) => e.stopPropagation()}>
                        <h3 className="text-lg font-semibold text-slate-200 mb-3">{title}</h3>
                        <p className="text-slate-400 mb-6">{message}</p>
                        <div className="flex justify-end gap-3">
                            <button
                                onClick={onClose}
                                className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                            >
                                {cancelText}
                            </button>
                            <button
                                onClick={onConfirm}
                                className="px-4 py-2 text-sm bg-red-600 hover:bg-red-500 text-white rounded-lg transition-colors font-semibold"
                            >
                                {confirmText}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const ExportFormatModal = ({ isOpen, onClose, onSelectFormat }) => {
            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm" onClick={onClose}>
                    <div className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl" onClick={(e) => e.stopPropagation()}>
                        <h3 className="text-lg font-semibold text-slate-200 mb-2">Export</h3>
                        <p className="text-sm text-slate-400 mb-6">select a format to export to</p>
                        <div className="space-y-2 mb-6">
                            <button
                                onClick={() => onSelectFormat('csv')}
                                className="w-full text-left px-4 py-3 text-sm text-slate-300 hover:bg-slate-800 rounded-lg transition-colors border border-slate-700 hover:border-slate-600"
                            >
                                CSV
                            </button>
                            <button
                                onClick={() => onSelectFormat('excel')}
                                className="w-full text-left px-4 py-3 text-sm text-slate-300 hover:bg-slate-800 rounded-lg transition-colors border border-slate-700 hover:border-slate-600"
                            >
                                Excel
                            </button>
                            <button
                                onClick={() => onSelectFormat('pdf')}
                                className="w-full text-left px-4 py-3 text-sm text-slate-300 hover:bg-slate-800 rounded-lg transition-colors border border-slate-700 hover:border-slate-600"
                            >
                                PDF
                            </button>
                        </div>
                        <div className="flex justify-end">
                            <button
                                onClick={onClose}
                                className="px-4 py-2 text-sm text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                            >
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const FileMenu = ({ onSaveToDesktop, onExportFor, onClear, onUpdateInventory }) => {
            const [isOpen, setIsOpen] = useState(false);
            const menuRef = useRef(null);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (menuRef.current && !menuRef.current.contains(event.target)) {
                        setIsOpen(false);
                    }
                };

                if (isOpen) {
                    document.addEventListener('mousedown', handleClickOutside);
                }

                return () => {
                    document.removeEventListener('mousedown', handleClickOutside);
                };
            }, [isOpen]);

            return (
                <div className="relative" ref={menuRef}>
                    <button
                        onClick={() => setIsOpen(!isOpen)}
                        className="flex items-center space-x-2 px-4 py-2 text-sm text-slate-300 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                    >
                        <span>File</span>
                        <ChevronDown className={`w-4 h-4 transition-transform ${isOpen ? 'rotate-180' : ''}`} />
                    </button>

                    {isOpen && (
                        <div className="absolute right-0 mt-2 w-48 bg-slate-800 border border-slate-700 rounded-lg shadow-xl z-50 overflow-hidden">
                            <button
                                onClick={() => {
                                    onUpdateInventory();
                                    setIsOpen(false);
                                }}
                                className="w-full text-left px-4 py-2 text-sm text-slate-300 hover:bg-slate-700 transition-colors border-t border-slate-700"
                            >
                                Upload New Extraction
                            </button>
                            <button
                                onClick={() => {
                                    onSaveToDesktop();
                                    setIsOpen(false);
                                }}
                                className="w-full text-left px-4 py-2 text-sm text-slate-300 hover:bg-slate-700 transition-colors"
                            >
                                Save to Desktop
                            </button>
                            <button
                                onClick={() => {
                                    onExportFor();
                                    setIsOpen(false);
                                }}
                                className="w-full text-left px-4 py-2 text-sm text-slate-300 hover:bg-slate-700 transition-colors"
                            >
                                Export...
                            </button>

                            <button
                                onClick={() => {
                                    onClear();
                                    setIsOpen(false);
                                }}
                                className="w-full text-left px-4 py-2 text-sm text-slate-300 hover:bg-slate-700 transition-colors border-t border-slate-700"
                            >
                                Delete Inventory
                            </button>
                        </div>
                    )}
                </div>
            );
        };

        const FileUploader = ({ onDataLoaded, hasExistingData }) => {
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            const inputRef = useRef(null);

            useEffect(() => {
                if (inputRef.current) {
                    inputRef.current.setAttribute("webkitdirectory", "");
                    inputRef.current.setAttribute("directory", "");
                }
            }, []);

            const handleFolderSelect = async (e) => {
                if (hasExistingData) {
                    const confirmed = confirm(
                        "⚠️ Warning: Uploading a new file will replace all existing data.\n\n" +
                        "Do you want to continue?"
                    );
                    if (!confirmed) {
                        e.target.value = ''; 
                        return;
                    }
                }

                setLoading(true);
                setError(null);
                
                try {
                    const files = Array.from(e.target.files);
                    if (files.length === 0) throw new Error("No folder selected or folder is empty.");

                    const dataFile = files.find(f => f.name.toLowerCase() === "furniture_data.txt" || f.name.toLowerCase().endsWith(".json"));
                    if (!dataFile) throw new Error("Could not find 'furniture_data.txt'.");

                    const urlMap = new Map();
                    const fileMap = new Map(); // Store Raw Files for DB saving

                    files.forEach(file => {
                        if (file.type.startsWith('image/')) {
                            // URL for immediate display
                            urlMap.set(file.name, URL.createObjectURL(file));
                            // Raw File for DB saving (Fixes transaction bugs)
                            fileMap.set(file.name, file);
                        }
                    });

                    const text = await readFileAsText(dataFile);
                    const { data: enrichedData, metadata } = parseAndEnrichData(text);
                    
                    // Pass both maps
                    onDataLoaded(enrichedData, urlMap, metadata, fileMap);

                } catch (err) {
                    console.error(err);
                    setError(err.message);
                } finally {
                    setLoading(false);
                }
            };

            const readFileAsText = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (event) => resolve(event.target.result);
                    reader.onerror = (error) => reject(error);
                    reader.readAsText(file);
                });
            };

            const parseAndEnrichData = (rawText) => {
                let text = rawText.trim();
                // Handle trailing commas if present
                if (text.endsWith(',') || text.endsWith(',]')) text = text.replace(/,(\s*\]?)$/, '$1');
                
                // FIXED: Don't blindly wrap in brackets. Try parsing first.
                let json;
                try {
                    json = JSON.parse(text);
                } catch (e) {
                    // Fallback: Try wrapping in brackets (for bare object lists)
                    try {
                        json = JSON.parse(`[${text}]`);
                    } catch (e2) {
                        throw new Error("Failed to parse JSON. Ensure the file contains a valid JSON array.");
                    }
                }
                
                // Handle new format with metadata (object with data property)
                let dataArray;
                let metadata = null;

                // Helper to extract if it's the root object
                const extractFromObject = (obj) => {
                    if (obj && typeof obj === 'object' && obj.data && Array.isArray(obj.data)) {
                        return {
                            data: obj.data,
                            meta: { timestamp: obj.timestamp, Date: obj.Date }
                        };
                    }
                    return null;
                };

                // Check direct object
                let extracted = extractFromObject(json);
                
                // Check if it got wrapped in an array accidentally or intentionally (length 1 array containing the root object)
                if (!extracted && Array.isArray(json) && json.length === 1) {
                    extracted = extractFromObject(json[0]);
                }

                if (extracted) {
                    dataArray = extracted.data;
                    metadata = extracted.meta;
                } else if (Array.isArray(json)) {
                    // Old format (direct array of items)
                    dataArray = json;
                } else {
                    throw new Error("File content is not a valid JSON array or object with data property.");
                }

                const enrichedData = dataArray.map((item, idx) => ({
                    // CRITICAL: Prioritize 'type' as the main ID.
                    // Fallback to existing id or generate temp.
                    type: item.type || item.id || `temp-${idx}`, 
                    id: item.id || `temp-${idx}`, // Keep id for legacy/display if needed
                    ...item,
                    name: item.name || "Unknown Item",
                    image: item.image || "",
                    quantity: item.count !== undefined ? item.count : (item.quantity || 0), 
                    price: item.price !== undefined ? item.price : 0,
                    rarity: item.rarity !== undefined ? item.rarity : 0
                }));

                return { data: enrichedData, metadata };
            };

            return (
                <div className="flex flex-col items-center justify-center h-full space-y-6 p-8 text-center bg-slate-950 text-slate-100 animate-in fade-in duration-700">
                    <div className="bg-slate-900/50 p-10 rounded-2xl border border-slate-800 shadow-2xl max-w-lg w-full backdrop-blur-sm">
                        <div className="bg-blue-500/10 p-4 rounded-full w-24 h-24 mx-auto mb-6 flex items-center justify-center">
                            <FolderOpen className="w-12 h-12 text-blue-500" />
                        </div>
                        
                        <h1 className="text-3xl font-bold mb-3 bg-gradient-to-r from-blue-400 to-indigo-400 bg-clip-text text-transparent">
                            Import Inventory
                        </h1>
                        
                        <p className="text-slate-400 mb-8 leading-relaxed">
                            Select the folder containing your data file and images.
                        </p>

                        <label className="relative group flex items-center justify-center px-6 py-4 bg-blue-600 hover:bg-blue-500 text-white font-semibold rounded-xl cursor-pointer transition-all hover:scale-[1.02] active:scale-[0.98] w-full shadow-lg hover:shadow-blue-500/25">
                            {loading ? (
                                <div className="flex items-center gap-2">
                                    <RefreshCw className="w-5 h-5 animate-spin" />
                                    <span>Processing Data...</span>
                                </div>
                            ) : (
                                <span>Select Folder</span>
                            )}
                            <input 
                                ref={inputRef}
                                type="file" 
                                className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                                onChange={handleFolderSelect}
                                disabled={loading}
                            />
                        </label>

                        {error && (
                            <div className="mt-6 p-4 bg-red-950/30 border border-red-900/50 text-red-200 rounded-lg text-sm flex items-start gap-3 text-left animate-in slide-in-from-top-2">
                                <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5 text-red-400" />
                                <span>{error}</span>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const ItemRow = React.memo(({ item, index, style, imageMap, onUpdate }) => {
            const imageUrl = imageMap.get(item.image);
            const rarityStyle = RARITY_MAP[item.rarity] || RARITY_MAP[0];

            return (
                <div 
                    style={style} 
                    className="absolute w-full flex items-center border-b border-slate-800/50 hover:bg-slate-800/30 transition-colors px-4 group"
                >
                    <div className="w-12 text-slate-600 text-sm font-mono flex-shrink-0">{index + 1}</div>

                    <div className="w-20 h-20 p-2 flex-shrink-0">
                        <div className="w-full h-full rounded-lg bg-slate-800/50 border border-slate-700/50 overflow-hidden relative">
                            {imageUrl ? (
                                <img 
                                    src={imageUrl} 
                                    alt={item.name} 
                                    className="w-full h-full object-contain hover:scale-110 transition-transform duration-300" 
                                    loading="lazy"
                                />
                            ) : (
                                <div className="w-full h-full flex flex-col items-center justify-center text-slate-600">
                                    <ImageIcon className="w-5 h-5 opacity-40" />
                                </div>
                            )}
                        </div>
                    </div>

                    <div className="flex-1 px-4 min-w-0">
                        <div className="font-medium text-slate-200 truncate group-hover:text-blue-300 transition-colors" title={item.name}>
                            {item.name}
                        </div>
                        <div className="text-xs text-slate-500 font-mono truncate mt-0.5" title={item.type || item.id}>
                            {item.type || item.id}
                        </div>
                    </div>

                    <div className="w-28 px-2">
                        <label className="text-[10px] text-slate-500 uppercase font-bold tracking-wider mb-1 block">Qty</label>
                        <input 
                            type="number" 
                            className="w-full bg-slate-900 border border-slate-700 rounded px-2 py-1.5 text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500/50 focus:outline-none text-right text-slate-200 transition-all"
                            value={item.quantity}
                            min="0"
                            onChange={(e) => onUpdate(item.actualIndex, 'quantity', parseInt(e.target.value) || 0)}
                        />
                    </div>

                    <div className="w-32 px-2">
                        <label className="text-[10px] text-slate-500 uppercase font-bold tracking-wider mb-1 block">Price</label>
                        <div className="relative">
                            <span className="absolute left-2 top-1.5 text-slate-500 text-sm">$</span>
                            <input 
                                type="number" 
                                className="w-full bg-slate-900 border border-slate-700 rounded pl-5 pr-2 py-1.5 text-sm focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500/50 focus:outline-none text-right text-slate-200 transition-all"
                                value={item.price}
                                placeholder="0"
                                min="0"
                                onChange={(e) => onUpdate(item.actualIndex, 'price', e.target.value)}
                            />
                        </div>
                    </div>

                    <div className="w-36 px-2">
                        <label className="text-[10px] text-slate-500 uppercase font-bold tracking-wider mb-1 block">Rarity</label>
                        <select 
                            className={`w-full border rounded px-2 py-1.5 text-xs font-medium focus:outline-none appearance-none cursor-pointer transition-all ${rarityStyle.color} ${rarityStyle.bg || 'bg-slate-900'}`}
                            value={item.rarity}
                            onChange={(e) => onUpdate(item.actualIndex, 'rarity', parseInt(e.target.value))}
                        >
                            {Object.entries(RARITY_MAP).map(([val, config]) => (
                                <option key={val} value={val} className="bg-slate-800 text-slate-200">
                                    {config.label}
                                </option>
                            ))}
                        </select>
                    </div>
                </div>
            );
        });

        const VirtualList = ({ items, imageMap, onUpdateItem }) => {
            const containerRef = useRef(null);
            const [scrollTop, setScrollTop] = useState(0);
            const [containerHeight, setContainerHeight] = useState(0);

            useEffect(() => {
                if (!containerRef.current) return;
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        setContainerHeight(entry.contentRect.height);
                    }
                });
                resizeObserver.observe(containerRef.current);
                return () => resizeObserver.disconnect();
            }, []);

            const handleScroll = (e) => {
                setScrollTop(e.target.scrollTop);
            };

            const totalHeight = items.length * ROW_HEIGHT;
            const startIndex = Math.max(0, Math.floor(scrollTop / ROW_HEIGHT) - BUFFER_ITEMS);
            const endIndex = Math.min(
                items.length - 1,
                Math.floor((scrollTop + containerHeight) / ROW_HEIGHT) + BUFFER_ITEMS
            );

            const visibleItems = useMemo(() => {
                const rows = [];
                for (let i = startIndex; i <= endIndex; i++) {
                    const item = items[i];
                    rows.push(
                        <ItemRow 
                            // Use TYPE as key
                            key={item.type || i} 
                            index={i}
                            item={item}
                            style={{ top: i * ROW_HEIGHT, height: ROW_HEIGHT }}
                            imageMap={imageMap}
                            onUpdate={onUpdateItem}
                        />
                    );
                }
                return rows;
            }, [startIndex, endIndex, items, imageMap, onUpdateItem]);

            return (
                <div 
                    ref={containerRef}
                    className="flex-1 overflow-y-auto relative bg-slate-950 scroll-smooth virtual-scroller"
                    onScroll={handleScroll}
                >
                    <div style={{ height: totalHeight, position: 'relative', width: '100%' }}>
                        {items.length > 0 ? visibleItems : (
                            <div className="absolute inset-0 flex flex-col items-center justify-center text-slate-500 opacity-60">
                                <Search className="w-12 h-12 mb-2" />
                                <span className="text-lg">No matching items found</span>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const App = () => {
            // Data & State
            const [data, setData] = useState(null);
            const [imageMap, setImageMap] = useState(null);
            const [extractionDate, setExtractionDate] = useState(null);
            const [isLoadingFromDB, setIsLoadingFromDB] = useState(true);
            const [hasStoredData, setHasStoredData] = useState(false);
            
            // AI State
            const [pipeline, setPipeline] = useState(null);
            const [embeddings, setEmbeddings] = useState(null);
            const [indexingProgress, setIndexingProgress] = useState(0); 
            const [isAIReady, setIsAIReady] = useState(false);
            
            // Search State
            const [searchQuery, setSearchQuery] = useState("");
            const [searchResults, setSearchResults] = useState(null);
            const [isSearching, setIsSearching] = useState(false);

            // Modal State
            const [showFirstClearModal, setShowFirstClearModal] = useState(false);
            const [showSecondClearModal, setShowSecondClearModal] = useState(false);
            const [showExportFormatModal, setShowExportFormatModal] = useState(false);
            const [showUpdateConfirmModal, setShowUpdateConfirmModal] = useState(false);
            const [pendingUpdateData, setPendingUpdateData] = useState(null);
            const [showSaveToDesktopModal, setShowSaveToDesktopModal] = useState(false);

            // File input ref for update inventory
            const updateInventoryInputRef = useRef(null);

            // 0. Load from IndexedDB on mount
            useEffect(() => {
                const loadData = async () => {
                    try {
                        const { items, imageMap: loadedImageMap, metadata, embeddingsMap } = await loadFromIndexedDB();
                        if (items && items.length > 0) {
                            const indexedData = items.map((d, i) => ({ ...d, actualIndex: i }));
                            setData(indexedData);
                            setImageMap(loadedImageMap);
                            setHasStoredData(true);
                            if (metadata) {
                                setExtractionDate(metadata.Date);
                            }
                            
                            // Convert embeddings Map to array format (matching item order)
                            // Use TYPE for lookup
                            if (embeddingsMap && embeddingsMap.size > 0) {
                                const embeddingsArray = indexedData.map(item => embeddingsMap.get(item.type) || null);
                                // Only set if we have at least some embeddings
                                if (embeddingsArray.some(e => e !== null)) {
                                    setEmbeddings(embeddingsArray);
                                }
                            }
                        } else {
                            setHasStoredData(false);
                        }
                    } catch (e) {
                        console.error('Error loading from IndexedDB:', e);
                        setHasStoredData(false);
                    } finally {
                        setIsLoadingFromDB(false);
                    }
                };
                loadData();
            }, []);

            // 1. Initialize Transformers Pipeline
            useEffect(() => {
                const initAI = async () => {
                    if (!window.pipeline) return; 

                    try {
                        const pipe = await window.pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2', {
                            quantized: true 
                        });
                        setPipeline(() => pipe);
                        setIsAIReady(true);
                    } catch (e) {
                        console.error("AI Model Init Failed:", e);
                    }
                };

                const checkInterval = setInterval(() => {
                    if (window.pipeline) {
                        clearInterval(checkInterval);
                        initAI();
                    }
                }, 100);

                return () => clearInterval(checkInterval);
            }, []);

            // 2. Index Data when Loaded - Only generate missing embeddings
            useEffect(() => {
                if (!data || !pipeline) return;

                const generateEmbeddings = async () => {
                    // Load existing embeddings from DB
                    const existingEmbeddingsMap = await loadEmbeddingsFromIndexedDB();
                    
                    // Determine which items need embeddings
                    const itemsNeedingEmbeddings = [];
                    const itemsNeedingRegeneration = [];
                    const vectors = [];
                    
                    // Check each item
                    for (let i = 0; i < data.length; i++) {
                        const item = data[i];
                        // Use TYPE to look up embedding
                        const existingEmbedding = existingEmbeddingsMap.get(item.type);
                        
                        if (!existingEmbedding) {
                            // Missing embedding - need to generate
                            itemsNeedingEmbeddings.push({ index: i, item });
                            vectors.push(null); // placeholder
                        } else {
                            // Check if name changed (need to regenerate)
                            const existingItem = data.find(d => d.type === item.type);
                            // We'll check by comparing with stored item name if we have it
                            // For now, assume if embedding exists and item exists, it's valid
                            vectors.push(existingEmbedding);
                        }
                    }
                    
                    // Also check for name changes by loading existing items from DB
                    const db = await openDB();
                    const tx = db.transaction([STORE_ITEMS], 'readonly');
                    const itemsStore = tx.objectStore(STORE_ITEMS);
                    const existingItems = await new Promise((resolve, reject) => {
                        const req = itemsStore.getAll();
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => reject(req.error);
                    });
                    
                    // Use TYPE for map key
                    const existingItemsMap = new Map(existingItems.map(item => [item.type, item]));
                    
                    // Re-check for name changes
                    for (let i = 0; i < data.length; i++) {
                        const item = data[i];
                        const existingItem = existingItemsMap.get(item.type);
                        const existingEmbedding = existingEmbeddingsMap.get(item.type);
                        
                        if (existingItem && existingEmbedding && existingItem.name !== item.name) {
                            // Name changed - need to regenerate
                            itemsNeedingRegeneration.push({ index: i, item });
                            vectors[i] = null; // mark for regeneration
                        }
                    }
                    
                    const totalNeedingGeneration = itemsNeedingEmbeddings.length + itemsNeedingRegeneration.length;
                    
                    if (totalNeedingGeneration === 0) {
                        // All embeddings exist and are up to date
                        setEmbeddings(vectors);
                        setIndexingProgress(100);
                        return;
                    }
                    
                    setIndexingProgress(0);
                    
                    // Generate embeddings for items that need them
                    const itemsToProcess = [...itemsNeedingEmbeddings, ...itemsNeedingRegeneration];
                    const embeddingsToSave = new Map();
                    
                    const CHUNK_SIZE = 10;
                    for (let i = 0; i < itemsToProcess.length; i += CHUNK_SIZE) {
                        const chunk = itemsToProcess.slice(i, i + CHUNK_SIZE);
                        const promises = chunk.map(async ({ index, item }) => {
                            const output = await pipeline(`Furniture item: ${item.name}`, { pooling: 'mean', normalize: true });
                            // Return item.type as identifier
                            return { index, itemType: item.type, vector: Array.from(output.data) };
                        });
                        
                        const results = await Promise.all(promises);
                        for (const { index, itemType, vector } of results) {
                            vectors[index] = vector;
                            embeddingsToSave.set(itemType, vector);
                        }
                        
                        setIndexingProgress(Math.round(((i + CHUNK_SIZE) / itemsToProcess.length) * 100));
                        
                        // Save incrementally
                        if (embeddingsToSave.size >= CHUNK_SIZE) {
                            await saveEmbeddingsToIndexedDB(embeddingsToSave);
                            embeddingsToSave.clear();
                        }
                        
                        await new Promise(r => setTimeout(r, 0));
                    }
                    
                    // Save any remaining embeddings
                    if (embeddingsToSave.size > 0) {
                        await saveEmbeddingsToIndexedDB(embeddingsToSave);
                    }
                    
                    setEmbeddings(vectors);
                    setIndexingProgress(100);
                };

                generateEmbeddings();
            }, [data, pipeline]);

            // 3. Search Logic
            useEffect(() => {
                if (!searchQuery.trim()) {
                    setSearchResults(null);
                    return;
                }

                if (!embeddings || !pipeline) {
                    const lowerQuery = searchQuery.toLowerCase();
                    const filtered = data.filter(item => 
                        item.name.toLowerCase().includes(lowerQuery) || 
                        (item.type && item.type.toLowerCase().includes(lowerQuery))
                    );
                    setSearchResults(filtered);
                    return;
                }

                const runSearch = async () => {
                    setIsSearching(true);
                    
                    const queryOutput = await pipeline(`Furniture item: ${searchQuery}`, { pooling: 'mean', normalize: true });
                    const queryVector = queryOutput.data;

                    const lowerQuery = searchQuery.toLowerCase();
                    
                    const scoredItems = data.map((item, index) => {
                        let score = cosineSimilarity(queryVector, embeddings[index]);
                        
                        if (item.name.toLowerCase().includes(lowerQuery)) {
                            score += 1.0; 
                        }
                        
                        return { ...item, score, actualIndex: index }; 
                    });

                    scoredItems.sort((a, b) => b.score - a.score);
                    const filtered = scoredItems.filter(item => item.score > 0.25);

                    setSearchResults(filtered);
                    setIsSearching(false);
                };

                const timeoutId = setTimeout(runSearch, 300);
                return () => clearTimeout(timeoutId);

            }, [searchQuery, embeddings, pipeline, data]);


            // Handlers
            const handleDataLoaded = async (loadedData, loadedUrlMap, metadata, loadedFileMap) => {
                try {
                    // Load existing data from IndexedDB for smart merging
                    const { items: existingItems, imageMap: existingImageMap, embeddingsMap: existingEmbeddingsMap } = await loadFromIndexedDB();
                    
                    // Create maps for efficient lookup using TYPE
                    const existingItemsMap = new Map(existingItems.map(item => [item.type, item]));
                    const existingImageFilenames = new Set(existingImageMap.keys());
                    
                    // Build merged data: existing items + new items
                    const mergedItems = [];
                    const processedItemTypes = new Set(); // Track which items we've already processed
                    const newImageFileMap = new Map();
                    const itemsNeedingEmbeddings = [];
                    
                    // Process new items
                    for (const newItem of loadedData) {
                        // Ensure we have a valid TYPE
                        if (!newItem.type) {
                            console.warn('Skipping item without Type:', newItem);
                            continue;
                        }

                        const existingItem = existingItemsMap.get(newItem.type);
                        
                        if (existingItem) {
                            // Item exists - check if name changed (need to regenerate embedding)
                            if (existingItem.name !== newItem.name) {
                                itemsNeedingEmbeddings.push(newItem);
                            }
                            // Merge: preserve existing item's data, update with new data (especially quantity)
                            const mergedItem = {
                                ...existingItem,
                                ...newItem,
                                type: existingItem.type, // Explicitly preserve existing TYPE
                                price: existingItem.price !== undefined ? existingItem.price : (newItem.price || 0),
                                rarity: existingItem.rarity !== undefined ? existingItem.rarity : (newItem.rarity || 0),
                                image: existingItem.image || newItem.image || ''
                            };
                            mergedItems.push(mergedItem);
                            processedItemTypes.add(existingItem.type);
                        } else {
                            // New item - add it
                            mergedItems.push(newItem);
                            itemsNeedingEmbeddings.push(newItem);
                            processedItemTypes.add(newItem.type);
                            
                            // Check if this item's image is new (match by item.image property = filename)
                            if (newItem.image && !existingImageFilenames.has(newItem.image)) {
                                // Find the image file that matches this item's image property
                                const imageFile = loadedFileMap.get(newItem.image);
                                if (imageFile) {
                                    newImageFileMap.set(newItem.image, imageFile);
                                }
                            }
                        }
                    }
                    
                    // Also keep existing items that weren't in the new upload
                    for (const existingItem of existingItems) {
                        if (!processedItemTypes.has(existingItem.type)) {
                            mergedItems.push(existingItem);
                        }
                    }
                    
                    // Add new images that don't match existing items (by item.image property)
                    for (const [filename, file] of loadedFileMap.entries()) {
                        if (!existingImageFilenames.has(filename)) {
                            // Check if any new item uses this image (by matching item.image to filename)
                            const itemUsingImage = loadedData.find(item => item.image === filename);
                            if (itemUsingImage && !existingItemsMap.has(itemUsingImage.type)) {
                                newImageFileMap.set(filename, file);
                            }
                        }
                    }
                    
                    // Index the merged data
                    const indexedData = mergedItems.map((d, i) => ({ ...d, actualIndex: i }));
                    
                    // Build merged image map
                    const mergedImageMap = new Map(existingImageMap);
                    for (const [filename, url] of loadedUrlMap.entries()) {
                        if (!mergedImageMap.has(filename)) {
                            mergedImageMap.set(filename, url);
                        }
                    }
                    // Also add new images from fileMap
                    for (const [filename, file] of newImageFileMap.entries()) {
                        if (!mergedImageMap.has(filename)) {
                            mergedImageMap.set(filename, URL.createObjectURL(file));
                        }
                    }
                    
                    // Revoke old blob URLs if needed
                    if (imageMap) {
                        imageMap.forEach(url => {
                            if (url.startsWith('blob:') && !Array.from(mergedImageMap.values()).includes(url)) {
                                URL.revokeObjectURL(url);
                            }
                        });
                    }
                    
                    setData(indexedData);
                    setImageMap(mergedImageMap);
                    setHasStoredData(true);
                    
                    // Clear embeddings to trigger regeneration for new/changed items
                    setEmbeddings(null);
                    
                    if (metadata && metadata.Date) {
                        setExtractionDate(metadata.Date);
                    } else {
                        setExtractionDate(null);
                    }

                    // STEP 1: Save only new images
                    if (newImageFileMap.size > 0) {
                        await saveImagesToIndexedDB(newImageFileMap, existingImageMap);
                    }

                    // STEP 2: Save merged data
                    await saveDataToIndexedDB(indexedData, metadata);
                    
                    console.log(`Merged ${mergedItems.length} items (${itemsNeedingEmbeddings.length} new/changed). Saved ${newImageFileMap.size} new images.`);

                } catch (e) {
                    console.error('Error saving to IndexedDB:', e);
                    alert(`Error saving to storage: ${e.message}\n\nYour data is loaded but may not persist after closing the browser.`);
                }
            };

            const handleUpdateItem = useCallback((actualIndex, field, value) => {
                setData(prevData => {
                    const newData = [...prevData];
                    const oldItem = newData[actualIndex];
                    newData[actualIndex] = { ...newData[actualIndex], [field]: value };
                    
                    // If name changed, regenerate embedding
                    if (field === 'name' && oldItem.name !== value && pipeline) {
                        (async () => {
                            try {
                                const output = await pipeline(`Furniture item: ${value}`, { pooling: 'mean', normalize: true });
                                const newVector = Array.from(output.data);
                                
                                // Update embeddings array
                                setEmbeddings(prevEmbeddings => {
                                    if (!prevEmbeddings) return prevEmbeddings;
                                    const updated = [...prevEmbeddings];
                                    updated[actualIndex] = newVector;
                                    return updated;
                                });
                                
                                // Save to IndexedDB (Using TYPE as key)
                                const embeddingsToSave = new Map();
                                embeddingsToSave.set(newData[actualIndex].type, newVector);
                                await saveEmbeddingsToIndexedDB(embeddingsToSave);
                            } catch (e) {
                                console.error('Error regenerating embedding for name change:', e);
                            }
                        })();
                    }
                    
                    // Efficient Save: Only update the Items/JSON store.
                    // DO NOT re-save images here.
                    clearTimeout(window._saveTimeout);
                    window._saveTimeout = setTimeout(async () => {
                        try {
                             await saveDataToIndexedDB(newData, extractionDate ? { timestamp: Date.now(), Date: extractionDate } : null);
                        } catch (e) {
                            console.error('Error auto-saving changes:', e);
                        }
                    }, 1000); 
                    
                    return newData;
                });
            }, [extractionDate, pipeline]);

            const handleExport = async () => {
                if (!data) return;
                
                try {
                    // Get current date in the same format as extraction date (matching extractor format)
                    const now = new Date();
                    const currentDate = now.toLocaleString('en-US', {
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        timeZoneName: 'short'
                    });
                    const currentTimestamp = now.getTime();
                    
                    // Prepare export data in the format expected by import
                    const exportData = data.map(({ actualIndex, score, ...item }) => item);
                    const exportObject = {
                        data: exportData,
                        timestamp: currentTimestamp,
                        Date: currentDate
                    };
                    
                    // Get images from IndexedDB
                    const imageBlobs = await getImagesFromIndexedDB();
                    
                    // Create ZIP file
                    const zip = new JSZip();
                    
                    // Add data file (named exactly as import expects)
                    zip.file("furniture_data.txt", JSON.stringify(exportObject, null, 2));
                    
                    // Add all images
                    for (const [filename, blob] of imageBlobs.entries()) {
                        zip.file(filename, blob);
                    }
                    
                    // Generate ZIP and download
                    const zipBlob = await zip.generateAsync({ type: "blob" });
                    const url = URL.createObjectURL(zipBlob);
                    const a = document.createElement("a");
                    a.href = url;
                    // Format date as YYYY-MM-DD for filename
                    const dateStr = now.toISOString().split('T')[0];
                    a.download = `my_vmk_furniture_${dateStr}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    console.log(`Exported ${exportData.length} items and ${imageBlobs.size} images to ZIP file.`);
                } catch (e) {
                    console.error('Error exporting data:', e);
                    alert(`Error exporting data: ${e.message}`);
                }
            };

            const handleUpdateInventory = () => {
                // Show confirmation modal first
                setShowUpdateConfirmModal(true);
            };

            const handleUpdateInventoryConfirm = () => {
                // Close modal and trigger file input
                setShowUpdateConfirmModal(false);
                if (updateInventoryInputRef.current) {
                    updateInventoryInputRef.current.click();
                }
            };

            const handleUpdateInventoryFileSelect = async (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) {
                    e.target.value = '';
                    return;
                }

                try {
                    const dataFile = files.find(f => f.name.toLowerCase() === "furniture_data.txt" || f.name.toLowerCase().endsWith(".json"));
                    if (!dataFile) {
                        alert("Could not find 'furniture_data.txt'.");
                        e.target.value = '';
                        return;
                    }

                    const urlMap = new Map();
                    const fileMap = new Map();

                    files.forEach(file => {
                        if (file.type.startsWith('image/')) {
                            urlMap.set(file.name, URL.createObjectURL(file));
                            fileMap.set(file.name, file);
                        }
                    });

                    const text = await readFileAsText(dataFile);
                    const { data: enrichedData, metadata } = parseAndEnrichData(text);

                    // Process update directly (confirmation was already shown)
                    await handleUpdateInventoryData(enrichedData, urlMap, metadata, fileMap);
                    e.target.value = ''; // Reset input
                } catch (err) {
                    console.error(err);
                    alert(`Error reading file: ${err.message}`);
                    e.target.value = '';
                }
            };

            const handleUpdateInventoryData = async (loadedData, loadedUrlMap, metadata, loadedFileMap) => {
                try {
                    // Load existing data from IndexedDB
                    const { items: existingItems, imageMap: existingImageMap, embeddingsMap: existingEmbeddingsMap } = await loadFromIndexedDB();

                    // Create maps for efficient lookup using TYPE
                    const existingItemsMap = new Map(existingItems.map(item => [item.type, item]));
                    const existingImageFilenames = new Set(existingImageMap.keys());

                    // Build updated data
                    const updatedItems = [];
                    const newImageFileMap = new Map();
                    const itemsNeedingEmbeddings = [];

                    // Process loaded items
                    for (const newItem of loadedData) {
                        // Use TYPE for lookup
                        const existingItem = existingItemsMap.get(newItem.type);

                        if (existingItem) {
                            // Item exists - update quantity only, preserve price, rarity, and image
                            updatedItems.push({
                                ...existingItem,
                                quantity: newItem.quantity || existingItem.quantity || 0
                                // Price and rarity are preserved from existingItem
                                // Image is preserved from existingItem
                            });
                            // Don't add to itemsNeedingEmbeddings since we're not changing name
                        } else {
                            // New item - add it completely with image
                            updatedItems.push(newItem);
                            itemsNeedingEmbeddings.push(newItem);

                            // Add image for new item
                            if (newItem.image && !existingImageFilenames.has(newItem.image)) {
                                const imageFile = loadedFileMap.get(newItem.image);
                                if (imageFile) {
                                    newImageFileMap.set(newItem.image, imageFile);
                                }
                            }
                        }
                    }

                    // Keep existing items that weren't in the update
                    for (const existingItem of existingItems) {
                        // Check using TYPE
                        if (!loadedData.find(item => item.type === existingItem.type)) {
                            updatedItems.push(existingItem);
                        }
                    }

                    // Add new images that don't match existing items
                    for (const [filename, file] of loadedFileMap.entries()) {
                        if (!existingImageFilenames.has(filename)) {
                            const itemUsingImage = loadedData.find(item => item.image === filename);
                            if (itemUsingImage && !existingItemsMap.has(itemUsingImage.type)) {
                                newImageFileMap.set(filename, file);
                            }
                        }
                    }

                    // Index the updated data
                    const indexedData = updatedItems.map((d, i) => ({ ...d, actualIndex: i }));

                    // Build merged image map
                    const mergedImageMap = new Map(existingImageMap);
                    for (const [filename, url] of loadedUrlMap.entries()) {
                        if (!mergedImageMap.has(filename)) {
                            mergedImageMap.set(filename, url);
                        }
                    }
                    for (const [filename, file] of newImageFileMap.entries()) {
                        if (!mergedImageMap.has(filename)) {
                            mergedImageMap.set(filename, URL.createObjectURL(file));
                        }
                    }

                    // Revoke old blob URLs if needed
                    if (imageMap) {
                        imageMap.forEach(url => {
                            if (url.startsWith('blob:') && !Array.from(mergedImageMap.values()).includes(url)) {
                                URL.revokeObjectURL(url);
                            }
                        });
                    }

                    setData(indexedData);
                    setImageMap(mergedImageMap);
                    setHasStoredData(true);

                    // Clear embeddings to trigger regeneration for new items only
                    setEmbeddings(null);

                    // Don't update extraction date for updates

                    // STEP 1: Save only new images (for new items)
                    if (newImageFileMap.size > 0) {
                        await saveImagesToIndexedDB(newImageFileMap, existingImageMap);
                    }

                    // STEP 2: Save updated data
                    await saveDataToIndexedDB(indexedData, extractionDate ? { timestamp: Date.now(), Date: extractionDate } : null);

                    console.log(`Updated inventory: ${updatedItems.length} items (${itemsNeedingEmbeddings.length} new). Saved ${newImageFileMap.size} new images.`);

                } catch (e) {
                    console.error('Error updating inventory:', e);
                    alert(`Error updating inventory: ${e.message}`);
                }
            };

            const readFileAsText = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (event) => resolve(event.target.result);
                    reader.onerror = (error) => reject(error);
                    reader.readAsText(file);
                });
            };

            const parseAndEnrichData = (rawText) => {
                let text = rawText.trim();
                if (text.endsWith(',') || text.endsWith(',]')) text = text.replace(/,(\s*\]?)$/, '$1');

                let json;
                try {
                    json = JSON.parse(text);
                } catch (e) {
                    try {
                        json = JSON.parse(`[${text}]`);
                    } catch (e2) {
                        throw new Error("Failed to parse JSON. Ensure the file contains a valid JSON array.");
                    }
                }

                let dataArray;
                let metadata = null;

                const extractFromObject = (obj) => {
                    if (obj && typeof obj === 'object' && obj.data && Array.isArray(obj.data)) {
                        return {
                            data: obj.data,
                            meta: { timestamp: obj.timestamp, Date: obj.Date }
                        };
                    }
                    return null;
                };

                let extracted = extractFromObject(json);

                if (!extracted && Array.isArray(json) && json.length === 1) {
                    extracted = extractFromObject(json[0]);
                }

                if (extracted) {
                    dataArray = extracted.data;
                    metadata = extracted.meta;
                } else if (Array.isArray(json)) {
                    dataArray = json;
                } else {
                    throw new Error("File content is not a valid JSON array or object with data property.");
                }

                const enrichedData = dataArray.map((item, idx) => ({
                    // CRITICAL: Type is now primary ID
                    type: item.type || item.id || `temp-${idx}`,
                    id: item.id || `temp-${idx}`,
                    ...item,
                    name: item.name || "Unknown Item",
                    image: item.image || "",
                    quantity: item.count !== undefined ? item.count : (item.quantity || 0),
                    price: item.price !== undefined ? item.price : 0,
                    rarity: item.rarity !== undefined ? item.rarity : 0
                }));

                return { data: enrichedData, metadata };
            };

            const handleClear = () => {
                setShowFirstClearModal(true);
            };

            const handleFirstClearConfirm = () => {
                setShowFirstClearModal(false);
                setShowSecondClearModal(true);
            };

            const handleSecondClearConfirm = async () => {
                setShowSecondClearModal(false);
                    if (imageMap) imageMap.forEach(url => URL.revokeObjectURL(url));
                    setData(null);
                    setImageMap(null);
                    setExtractionDate(null);
                    setHasStoredData(false);
                    setEmbeddings(null);
                    setIndexingProgress(0);
                    setSearchQuery("");
                    await clearIndexedDB();
            };

            const handleSaveToDesktop = () => {
                if (!data) return;
                setShowSaveToDesktopModal(true);
            };

            const handleSaveToDesktopConfirm = async () => {
                setShowSaveToDesktopModal(false);
                if (!data) return;

                try {
                    // Wait for sql.js to be available
                    let initSqlJs = window.initSqlJs;
                    if (!initSqlJs) {
                        // Wait a bit for the script to load
                        await new Promise((resolve) => {
                            let attempts = 0;
                            const checkInterval = setInterval(() => {
                                attempts++;
                                if (window.initSqlJs) {
                                    initSqlJs = window.initSqlJs;
                                    clearInterval(checkInterval);
                                    resolve();
                                } else if (attempts > 50) {
                                    clearInterval(checkInterval);
                                    resolve();
                                }
                            }, 100);
                        });
                    }
                    
                    if (!initSqlJs) {
                        throw new Error('SQL.js library not loaded. Please refresh the page and try again.');
                    }
                    
                    const SQL = await initSqlJs({
                        locateFile: file => `https://cdn.jsdelivr.net/npm/sql.js@1.10.3/dist/${file}`
                    });
                    const db = new SQL.Database();

                    // Create tables
                    db.run(`
                        CREATE TABLE IF NOT EXISTS metadata (
                            key TEXT PRIMARY KEY,
                            value TEXT
                        );
                    `);

                    db.run(`
                        CREATE TABLE IF NOT EXISTS items (
                            type TEXT PRIMARY KEY, 
                            id TEXT,
                            name TEXT,
                            quantity INTEGER,
                            price REAL,
                            rarity INTEGER,
                            image TEXT,
                            data TEXT
                        );
                    `);

                    db.run(`
                        CREATE TABLE IF NOT EXISTS images (
                            filename TEXT PRIMARY KEY,
                            data BLOB
                        );
                    `);

                    // Get current date
                    const now = new Date();
                    const currentDate = now.toLocaleString('en-US', {
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        timeZoneName: 'short'
                    });
                    const currentTimestamp = now.getTime();

                    // Save metadata
                    db.run(`INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)`, ['timestamp', currentTimestamp.toString()]);
                    db.run(`INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)`, ['date', currentDate]);

                    // Prepare export data
                    const exportData = data.map(({ actualIndex, score, ...item }) => item);
                    const exportObject = {
                        data: exportData,
                        timestamp: currentTimestamp,
                        Date: currentDate
                    };

                    // Save items - TYPE is primary key
                    const stmt = db.prepare(`INSERT OR REPLACE INTO items (type, id, name, quantity, price, rarity, image, data) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`);
                    for (const item of exportData) {
                        stmt.run([
                            item.type || item.id || '',
                            item.id || '',
                            item.name || '',
                            item.quantity || 0,
                            item.price || 0,
                            item.rarity || 0,
                            item.image || '',
                            JSON.stringify(item)
                        ]);
                    }
                    stmt.free();

                    // Get images from IndexedDB and save to database
                    const imageBlobs = await getImagesFromIndexedDB();
                    const imageStmt = db.prepare(`INSERT OR REPLACE INTO images (filename, data) VALUES (?, ?)`);
                    
                    for (const [filename, blob] of imageBlobs.entries()) {
                        const arrayBuffer = await blob.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);
                        imageStmt.run([filename, uint8Array]);
                    }
                    imageStmt.free();

                    // Export database to file
                    const dbData = db.export();
                    const dbBlob = new Blob([dbData], { type: 'application/x-sqlite3' });
                    const url = URL.createObjectURL(dbBlob);
                    const a = document.createElement("a");
                    a.href = url;
                    const dateStr = now.toISOString().split('T')[0];
                    a.download = `my_vmk_furniture_${dateStr}.db`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    db.close();
                    console.log(`Saved ${exportData.length} items and ${imageBlobs.size} images to database file.`);
                } catch (e) {
                    console.error('Error saving to desktop:', e);
                    alert(`Error saving to desktop: ${e.message}`);
                }
            };

            const handleExportFor = () => {
                setShowExportFormatModal(true);
            };

            const handleExportFormat = async (format) => {
                setShowExportFormatModal(false);
                if (!data) return;

                const now = new Date();
                const dateStr = now.toISOString().split('T')[0];

                try {
                    // Get images from IndexedDB for exports
                    const imageBlobs = await getImagesFromIndexedDB();

                    switch (format) {
                        case 'csv':
                            await exportToCSV(data, dateStr, imageBlobs);
                            break;
                        case 'excel':
                            await exportToExcel(data, dateStr, imageBlobs);
                            break;
                        case 'pdf':
                            await exportToPDF(data, dateStr, imageBlobs);
                            break;
                    }
                } catch (e) {
                    console.error(`Error exporting to ${format}:`, e);
                    alert(`Error exporting to ${format}: ${e.message}`);
                }
            };

            const exportToCSV = (data, dateStr, imageBlobs) => {
                // Prepare CSV headers (no Image column)
                const headers = ['Type', 'Name', 'Quantity', 'Price', 'Rarity'];
                const rows = data.map(item => [
                    item.type || item.id || '',
                    item.name || '',
                    item.quantity || 0,
                    item.price || 0,
                    RARITY_MAP[item.rarity]?.label || 'unset'
                ]);

                // Combine headers and rows
                const csvContent = [
                    headers.join(','),
                    ...rows.map(row => row.map(cell => {
                        // Escape commas and quotes in cell values
                        const cellStr = String(cell);
                        if (cellStr.includes(',') || cellStr.includes('"') || cellStr.includes('\n')) {
                            return `"${cellStr.replace(/"/g, '""')}"`;
                        }
                        return cellStr;
                    }).join(','))
                ].join('\n');

                // Create blob and download plain CSV file
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `my_vmk_furniture_${dateStr}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const exportToExcel = async (data, dateStr, imageBlobs) => {
                // Use ExcelJS for image support
                const ExcelJS = window.ExcelJS;
                const workbook = new ExcelJS.Workbook();
                const worksheet = workbook.addWorksheet('Inventory');

                // Set column headers
                worksheet.columns = [
                    { header: 'Image', key: 'image', width: 15 },
                    { header: 'Type', key: 'type', width: 20 },
                    { header: 'Name', key: 'name', width: 30 },
                    { header: 'Quantity', key: 'quantity', width: 10 },
                    { header: 'Price', key: 'price', width: 12 },
                    { header: 'Rarity', key: 'rarity', width: 15 }
                ];

                // Style header row
                const headerRow = worksheet.getRow(1);
                headerRow.font = { bold: true };
                headerRow.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: 'FFE0E0E0' }
                };
                headerRow.alignment = { vertical: 'middle', horizontal: 'center' };

                // Set column alignments
                worksheet.getColumn(1).alignment = { vertical: 'middle', horizontal: 'center' }; // Image
                worksheet.getColumn(2).alignment = { vertical: 'middle', horizontal: 'left' }; // Type
                worksheet.getColumn(3).alignment = { vertical: 'middle', horizontal: 'left' }; // Name
                worksheet.getColumn(4).alignment = { vertical: 'middle', horizontal: 'center' }; // Quantity
                worksheet.getColumn(5).alignment = { vertical: 'middle', horizontal: 'right' }; // Price
                worksheet.getColumn(6).alignment = { vertical: 'middle', horizontal: 'center' }; // Rarity

                // Add data rows with images
                for (let i = 0; i < data.length; i++) {
                    const item = data[i];
                    const row = worksheet.addRow({
                        type: item.type || item.id || '',
                        name: item.name || '',
                        quantity: item.quantity || 0,
                        price: item.price || 0,
                        rarity: RARITY_MAP[item.rarity]?.label || 'unset'
                    });

                    // Set row height for images
                    row.height = 60;

                    // Set alignment for each cell
                    row.getCell(1).alignment = { vertical: 'middle', horizontal: 'center' }; // Image
                    row.getCell(2).alignment = { vertical: 'middle', horizontal: 'left' }; // Type
                    row.getCell(3).alignment = { vertical: 'middle', horizontal: 'left' }; // Name
                    row.getCell(4).alignment = { vertical: 'middle', horizontal: 'center' }; // Quantity
                    row.getCell(5).alignment = { vertical: 'middle', horizontal: 'right' }; // Price
                    row.getCell(6).alignment = { vertical: 'middle', horizontal: 'center' }; // Rarity

                    // Add image if available
                    if (item.image && imageBlobs.has(item.image)) {
                        try {
                            const imageBlob = imageBlobs.get(item.image);

                            // Convert blob to array buffer
                            const arrayBuffer = await imageBlob.arrayBuffer();

                            // Determine image extension
                            let extension = 'jpeg';
                            if (imageBlob.type === 'image/png') {
                                extension = 'png';
                            } else if (imageBlob.type === 'image/gif') {
                                extension = 'gif';
                            }

                            // Add image to the first column (Image column)
                            const imageId = workbook.addImage({
                                buffer: arrayBuffer,
                                extension: extension
                            });

                            // Position image in the cell (column A, current row)
                            // Center the image in the cell
                            const imageSize = 50;
                            const cellWidth = worksheet.getColumn(1).width || 15;
                            const cellHeight = row.height || 60;

                            // Calculate offset to center image (in Excel units: 1 col = ~64px, 1 row = ~20px)
                            const colOffset = ((cellWidth * 7) - imageSize) / 2 / 7; // Convert to column units
                            const rowOffset = ((cellHeight - imageSize) / 2) / 20; // Convert to row units

                            worksheet.addImage(imageId, {
                                tl: { col: 0 + colOffset, row: i + 1 + rowOffset },
                                ext: { width: imageSize, height: imageSize }
                            });
                        } catch (e) {
                            console.warn('Error adding image to Excel:', e);
                            // If image fails, just leave the cell empty
                        }
                    }
                }

                // Generate buffer and download
                const buffer = await workbook.xlsx.writeBuffer();
                const blob = new Blob([buffer], {
                    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `my_vmk_furniture_${dateStr}.xlsx`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const exportToPDF = async (data, dateStr, imageBlobs) => {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                // Set up PDF
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const margin = 15;
                const startY = 20;
                let currentY = startY;
                const imageSize = 25; // Size for thumbnail images
                const rowHeight = Math.max(8, imageSize + 4); // Adjust row height for images
                const maxY = pageHeight - margin;

                // Title
                doc.setFontSize(16);
                doc.text('VMK Furniture Inventory', margin, currentY);
                currentY += 10;

                // Date
                doc.setFontSize(10);
                doc.setTextColor(100, 100, 100);
                doc.text(`Exported: ${dateStr}`, margin, currentY);
                currentY += 8;

                // Table headers
                doc.setFontSize(10);
                doc.setTextColor(0, 0, 0);
                doc.setFont(undefined, 'bold');
                const headers = ['Image', 'Type', 'Name', 'Qty', 'Price', 'Rarity'];
                const colWidths = [30, 25, 60, 15, 20, 25];
                let xPos = margin;

                headers.forEach((header, idx) => {
                    doc.text(header, xPos, currentY);
                    xPos += colWidths[idx];
                });

                currentY += rowHeight;
                doc.setDrawColor(200, 200, 200);
                doc.line(margin, currentY, pageWidth - margin, currentY);
                currentY += 3;

                // Table rows with images
                doc.setFont(undefined, 'normal');
                doc.setFontSize(8);

                for (let index = 0; index < data.length; index++) {
                    const item = data[index];

                    // Check if we need a new page
                    if (currentY + rowHeight > maxY) {
                        doc.addPage();
                        currentY = startY;
                    }

                    xPos = margin;

                    // Add image if available
                    if (item.image && imageBlobs.has(item.image)) {
                        try {
                            const imageBlob = imageBlobs.get(item.image);
                            const imageUrl = URL.createObjectURL(imageBlob);

                            // Convert blob to base64 for PDF
                            const reader = new FileReader();
                            await new Promise((resolve, reject) => {
                                reader.onload = () => {
                                    try {
                                        const base64 = reader.result;
                                        // Add image to PDF
                                        doc.addImage(base64, 'JPEG', xPos, currentY - imageSize + 2, imageSize - 4, imageSize - 4);
                                        URL.revokeObjectURL(imageUrl);
                                        resolve();
                                    } catch (e) {
                                        console.warn('Error adding image to PDF:', e);
                                        URL.revokeObjectURL(imageUrl);
                                        resolve(); // Continue without image
                                    }
                                };
                                reader.onerror = () => {
                                    URL.revokeObjectURL(imageUrl);
                                    resolve(); // Continue without image
                                };
                                reader.readAsDataURL(imageBlob);
                            });
                        } catch (e) {
                            console.warn('Error processing image for PDF:', e);
                        }
                    }

                    xPos += colWidths[0]; // Move past image column

                    const rowData = [
                        ((item.type || item.id) || '').substring(0, 15),
                        (item.name || '').substring(0, 25),
                        String(item.quantity || 0),
                        `$${item.price || 0}`,
                        (RARITY_MAP[item.rarity]?.label || 'unset').substring(0, 12)
                    ];

                    rowData.forEach((cell, idx) => {
                        doc.text(cell, xPos, currentY);
                        xPos += colWidths[idx + 1]; // +1 because we skipped image column
                    });

                    currentY += rowHeight;
                }

                // Save PDF
                doc.save(`my_vmk_furniture_${dateStr}.pdf`);
            };

            const displayItems = searchResults || data;

            return (
                <div className="flex flex-col h-screen w-full bg-slate-950 text-slate-100 font-sans overflow-hidden">
                    <div className="bg-slate-900 border-b border-slate-800 px-6 py-4 flex items-center justify-between shadow-xl z-10 shrink-0 gap-4">
                        <div className="flex items-center space-x-3 shrink-0">
                            <img 
                                src="./logo.png" 
                                alt="Logo" 
                                className="w-16 h-12 rounded-lg shadow-lg shadow-blue-900/20 object-contain bg-slate-800 border border-slate-700"
                                onError={(e) => {
                                    e.target.style.display = 'none';
                                    e.target.nextSibling.style.display = 'flex';
                                }}
                            />
                            <div className="hidden bg-blue-600 p-2 rounded-lg shadow-lg shadow-blue-900/20 items-center justify-center">
                                <Package className="text-white w-5 h-5" />
                            </div>

                            <div className="hidden md:block">
                                <h1 className="text-lg font-bold tracking-tight text-white">Inventory Manager</h1>
                                {data && (
                                    <div className="flex items-center gap-2 mt-0.5 flex-wrap">
                                        <span className="bg-slate-800 text-slate-400 text-[10px] px-1.5 py-0.5 rounded border border-slate-700">
                                            {data.length.toLocaleString()} items
                                        </span>

                                    </div>
                                )}
                            </div>
                        </div>

                        {data && (
                            <div className="flex-1 max-w-xl relative group">
                                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                    <Search className={`w-4 h-4 ${isSearching ? 'text-blue-400 animate-pulse' : 'text-slate-500'}`} />
                                </div>
                                <input 
                                    type="text"
                                    className="block w-full pl-10 pr-10 py-2 border border-slate-700 rounded-xl leading-5 bg-slate-800 text-slate-300 placeholder-slate-500 focus:outline-none focus:bg-slate-900 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-all sm:text-sm"
                                    placeholder={embeddings ? "Search (e.g. 'Office chair' finds 'Stool')" : "Searching by text..."}
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                />
                                {searchQuery && (
                                    <button 
                                        className="absolute inset-y-0 right-0 pr-3 flex items-center text-slate-500 hover:text-white"
                                        onClick={() => setSearchQuery('')}
                                    >
                                        <X className="w-4 h-4" />
                                    </button>
                                )}
                                
                                {indexingProgress < 100 && indexingProgress > 0 && (
                                    <div className="absolute -bottom-3 left-0 w-full h-1 bg-slate-800 rounded-full overflow-hidden">
                                        <div 
                                            className="h-full bg-blue-500 transition-all duration-300"
                                            style={{ width: `${indexingProgress}%` }}
                                        />
                                    </div>
                                )}
                            </div>
                        )}

                        {data && (
                            <div className="flex items-center space-x-3 shrink-0">
                                <div className="flex items-center gap-2 px-3 py-1.5 bg-slate-800/50 rounded-lg border border-slate-800" title={embeddings ? "AI Ready" : "Loading Model..."}>
                                    <Brain className={`w-4 h-4 ${isAIReady ? 'text-purple-400' : 'text-slate-600 animate-pulse'}`} />
                                    {indexingProgress < 100 && indexingProgress > 0 && (
                                        <span className="text-[10px] text-slate-400 hidden sm:inline">{indexingProgress}%</span>
                                    )}
                                </div>

                                <FileMenu
                                    onSaveToDesktop={handleSaveToDesktop}
                                    onExportFor={handleExportFor}
                                    onClear={handleClear}
                                    onUpdateInventory={handleUpdateInventory}
                                />
                            </div>
                        )}
                    </div>

                    <div className="flex-1 overflow-hidden relative flex flex-col">
                        {isLoadingFromDB ? (
                            <div className="flex flex-col items-center justify-center h-full space-y-4 text-slate-400">
                                <RefreshCw className="w-8 h-8 animate-spin" />
                                <span>Loading saved data...</span>
                            </div>
                        ) : !data ? (
                            <FileUploader onDataLoaded={handleDataLoaded} hasExistingData={hasStoredData} />
                        ) : (
                            <>
                                <div className="flex items-center bg-slate-900/80 backdrop-blur border-b border-slate-800 px-4 py-3 text-xs font-bold text-slate-500 uppercase tracking-wider shrink-0 select-none">
                                    <div className="w-12">#</div>
                                    <div className="w-20 text-center">Preview</div>
                                    <div className="flex-1 px-4">Item Details {searchQuery && `(Found ${displayItems.length})`}</div>
                                    <div className="w-28 px-2">Stock</div>
                                    <div className="w-32 px-2">Price</div>
                                    <div className="w-36 px-2">Rarity</div>
                                </div>
                                
                                <VirtualList 
                                    items={displayItems} 
                                    imageMap={imageMap} 
                                    onUpdateItem={handleUpdateItem} 
                                />
                            </>
                        )}
                    </div>

                    <Modal
                        isOpen={showFirstClearModal}
                        onClose={() => setShowFirstClearModal(false)}
                        title="Warning"
                        message="This will clear your inventory manager. Make sure you have saved a copy to your Desktop."
                        onConfirm={handleFirstClearConfirm}
                        confirmText="Next"
                        cancelText="Cancel"
                    />

                    <Modal
                        isOpen={showSecondClearModal}
                        onClose={() => setShowSecondClearModal(false)}
                        title="Confirm"
                        message="are you sure u want to clear your inventory manager?"
                        onConfirm={handleSecondClearConfirm}
                        confirmText="Confirm"
                        cancelText="Cancel"
                    />

                    <ExportFormatModal
                        isOpen={showExportFormatModal}
                        onClose={() => setShowExportFormatModal(false)}
                        onSelectFormat={handleExportFormat}
                    />

                    <Modal
                        isOpen={showUpdateConfirmModal}
                        onClose={() => {
                            setShowUpdateConfirmModal(false);
                            setPendingUpdateData(null);
                        }}
                        title="Upload new extraction"
                        message="This will update quantities for existing items and/or add any new or missing items."
                        onConfirm={handleUpdateInventoryConfirm}
                        confirmText="Confirm"
                        cancelText="Cancel"
                    />

                    <Modal
                        isOpen={showSaveToDesktopModal}
                        onClose={() => setShowSaveToDesktopModal(false)}
                        title="Save to Desktop"
                        message="this will save a local copy of your inventory on your desktop, which you can share or re-open to view"
                        onConfirm={handleSaveToDesktopConfirm}
                        confirmText="Save"
                        cancelText="Cancel"
                    />

                    {/* Hidden file input for update inventory */}
                    <input
                        ref={updateInventoryInputRef}
                        type="file"
                        style={{ display: 'none' }}
                        webkitdirectory=""
                        directory=""
                        onChange={handleUpdateInventoryFileSelect}
                    />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>